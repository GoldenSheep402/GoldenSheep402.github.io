{"posts":[{"title":"再观《放牛班的春天》","text":"小小的观后感有人说，这部电影让人明白了何为师德，何为园丁。 在这所叫做“池塘之底”的辅育院中，以为矮胖的老师和一群顽劣不堪的孩子们却碰撞出了动人的歌声。 在这歌声中隐藏这的是孩子们对世界的渴望。 这部电影，没有高饱和度，也没有宏大的场面，但它却像一部美丽的童话，满是对希望的赞颂。 它多面而又真实，没有一个孩子出生就是邪恶的，打骂和体罚只会令他们的肉体屈服。但在我看来，这些孩子们的调皮行为更像是为了引起他人的注意，而不是怀揣着恶意去伤害他人。 王尔德说，生活在阴沟里，依然有仰望星空的权利。是的，无论你是成年人还是孩童，无论现在是家财万贯还是一贫如洗，即使跌入“池塘之底”，也依然可以找寻自己内心的光明。不得不说，影片主题深刻，一帧帧画面和一句句台词都闪耀着人性的光芒。 希望我也能变得更加温暖，让自己让身边的人变得更好，让生活让世界变得更美。 纸飞机飞出窗口，蓝天下挥舞的小手，童年像一串串鸽子，拍打翅膀，一飞就永不回头","link":"/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/"},{"title":"使用Alist挂载OneDrive网盘","text":"首先白嫖OneDrive的5T云盘申请微软开发者账号申请地址：https://developer.microsoft.com/zh-cn/microsoft-365/dev-program 点击立即加入！ 注册开发者根据指引填写各类资料后注册。 公司的话随便写 设置E5订阅[] 至此，账户就已经拥有为期90天的E5订阅了，并一次性申请了25个用户许可证。 如果你只是自己用，现在已经可以使用”用户名@域.onmicrosoft.com” 和之前设置的密码登录你电脑上的Office了。 获取5T容量[] 保存后OneDrive容量即升级成5T! 续期E5开发者账户自行上网找办法~~ 为Alist先注册一个API[ Web的url是 https://tool.nn.ci/onedrive/callback 下文还会用到 [ 这个就是client secert的值，先保存下来 [ 给api获取读写权限 到这里OneDrive设置已经完成,下面去https://tool.nn.ci/onedrive/request 获取刷新令牌, 莱斯沟~ [ 生成refresh token client_id : 客户端ID client_secret : 客户端密钥 redirect_uri : 重定向URL refresh_token : 刷新令牌 Alist是什么Alist 是一款支持多种存储的目录文件列表程序，支持 web 浏览与 webdav，后端基于gin，前端使用react。 官网地址 官网文档 支持存储类型 本地存储 阿里云盘 OneDrive / Sharepoint 天翼云盘 GoogleDrive 123 云盘 蓝奏云 Alist FTP PikPak 闪电盘 S3 WebDav Teambition（中国，国际） 分秒帧 和彩云 (个人云, 家庭云) Yandex.Disk 百度网盘 夸克网盘 迅雷云盘 部署 安装 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install 更新 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update 卸载 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall 自定义安装路径 123456 # 安装curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install /home/power # 更新curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update /home/power # 卸载curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall /home/power 访问服务脚本部署完成后，Alist默认分配5244端口，密码则会在安装后显示。 1http://YOUR_IP:5244/ 本地目录配置挂载路径：既网盘挂载后路径，可以随意。 地区：选网盘所在地。 客户端ID：client-id 客户端秘钥：client-secret 重定向URI:https://tool.nn.ci/onedrive/callback （不保证时效） 刷新令牌：refresh-token 将这些数据保存后就能看到主页的网盘目录了。 参考 OneDrive | Alist Document (nn.ci)","link":"/2022/11/05/00%E4%BD%BF%E7%94%A8Alist%E6%8C%82%E8%BD%BDOneDrive%E7%BD%91%E7%9B%98/"},{"title":"SQL概述","text":"1.SQL概述1.1 SQL背景知识 在1974年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。 SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道 ，由IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ，SQL-92 ，SQL-99 等标准。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。 1.2 SQL分类 DDL（Data Definition Languages 数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。 DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。 2.1 SQL语法的规则与规范 SQL 可以写为一行或者是多行。为了提高可读性，可将字句分行。 每条命令以；or \\g or \\G 结束。(部分数据库要求) 2.2 SQL大小写规范 MySQL 在 Windows下对大写不敏感。 MySQL 在Linux下对大小写敏感。 数据库名、表名、表的别名、变量名严格区分大小写。 关键字、函数名、字段名、字段别名是忽略大小写的。 推荐的书写规范： 数据库名、表名、表别名、字段名、字段别名使用小写。 SQL关键字、函数名、绑定变量使用大写。 2.3 命名规则 数据库、表名不得超过30个字符，变量名限制为29个。 只能包含 A–Z, a–z, 0–9, _共63个字符。 数据库名、表名、字段名等对象名中间不要包含空格。 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来。 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了。 例： 1234567#以下两句是一样的，不区分大小写show databases;SHOW DATABASES;#创建表格#create table student info(...); #表名错误，因为表名有空格create table student_info(...);","link":"/2022/11/26/02SQL%E6%A6%82%E8%BF%B0/"},{"title":"My-First-Blog","text":"My-First-Blog建一个属于自己的博客是我很早就有的想法，但是一直没能有机会与动力去实现。 真正开始行动是在2022/11/04的晚上，因为那天早上刚挂载了网盘，于是特别有兴致，打算一鼓作气。 然而，我几乎踩遍了所有的坑（或许这是我的天赋吧），最后在各位学长学姐的帮助下顺利上线了我的博客，在这里对那几位学长学姐的帮助表达我由衷的感谢！ 一.对目前生活的些许看法 到了大学怎么说，没有高中那些好朋友在身边玩耍，隐隐约约感到高中班主任所说的：“到大学是孤独的旅途”这句话的合理之处了，但生活还是很充实而美好的！ 搁置了很久的阅读还没开始（2022/11/05 还在读Loita），立个小flag——一个月一本！保证基本的阅读。 希望家里的妹妹有认真学习哈，（其实无所谓傲，毕竟我小学可不是个乖孩子） 又熬夜辣~~ 下次一定 二.小想法多花点时间学学曾经没能接触的知识，总算从高中学习中脱离出来了，高中也玩够了是时候achieve something辣！ 三.还有什么吗？？？？Who knows~","link":"/2022/11/04/04My%20First%20Blog/"},{"title":"Rust-note-02数据类型","text":"数据类型 标量和复合类型 Rust是静态编译语言，在编译的同时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出它的具体类型 但如果可能的类型太多（例如将string转换为整数的parse方法），就必须添加类型的标注 标量类型 一个标量代表一个单一的值 Rust有四个主要的标量类型： 整数类型 浮点类型 布尔类型 字符类型 整数类型 就是个整数 例如u32是一个无符号整数类型，占据32位空间 无符号用u开头 浮点类型 Rust有两种基础的浮点类型 f32 f64 Rust的浮点类型使用了IEEE-754标注来表述 f64是默认类型，因为在现代CPU上f64和f32速度差不多，且精度更高 布尔类型 true 和 false 两个值 一个字节 符号是bool 字符类型 Rust中的char类型用来表示最基础的单个字符 字符类型的字面值使用单引号 占用4个字节 使用Unicode编码 复合类型 Tuple 可以使用模式匹配来解构一个Tuple来获取值 12345fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;{}, {}, {}&quot;, x, y, z);} 访问Tuple的元素 在Tuple变量使用点标记，后接元素索引 1234fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); println!(&quot;{}, {}, {}&quot;, tup.0, tup.1, tup.2);} 数组 声明方法：在一个中括号中，各值用逗号分隔 数组的用处 如果想让数据存放在stack中而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处 数组没有Vector灵活 Vector和数组类似，它由标准库提供 Vector的长度可以改变 数组的类型 数组的类型可以以这种形式表示：[类型; 长度] let a[i32;5] = [1,2,3,4,5]; 另一种声明数组的方法 如果数组的每个元素值都相同，那么可以在： 在中括号中指定初始值 然后是一个 ; 最后是数组长度 let a[3;5]; 等价于 let a = [3,3,3,3,3]; 访问数组的元素 数组是Stack上分配的单个块的内存 可以使用索引 123456789101112131415161718fn main() { let months = [ &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; ]; let first = months[0]; let second = months[1];} 如果访问的索引超出了数组的范围，那么： 编译会通过 运行保存（runtime时panic） Rust不会允许其访问相应地址的内存","link":"/2022/12/04/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Rust-note-03函数","text":"Rust 函数基本形式 fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt; 函数参数12345678fn main(){ another_function(5, 6);}fn another_function(x: i32, y: i32) { println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 6 函数体的语句与表达式Rust 的函数体由以表达式(expression)结尾的语句(statement)组成 123456789101112fn main() { let x = 5; let y = { let x = 3; x + 1 // 这是一个表达式，它的值是整个函数的的结果值 // 被叫做函数体表达式(后面不能有;有的话就是一条statement) }; println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 4 函数的返回值 在-&gt;符号后面声明函数的返回值类型，但不可为返回值命名 在Rust中，返回值是函数体中最后一个表达式的值 若需要提前返回，使用return关键字，并指定一个值 大部分函数都是默认使用最后一个表达式作为返回的值 123fn five() -&gt; i32 { 5 //返回值就是5}","link":"/2022/12/04/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/"},{"title":"Rust-note-01变量与可变性","text":"变量与可变性 声明变量用let关键字 默认下是不可变（Immutable） 可以加入mut，使变量可变 变量与常量 常量（constant）,常量在绑定值后也是不可变，但是有许多不同： 不可使用mut，常量永远不可变 声明常量使用const关键字，且类型必须被标注 常量可以在任何作用域中被声明 Shadowing 可以使用相同的名字声明新的变量，新的变量会被shadow之前声明的同名变量 在后续代码中，这个名字代表的就是新的变量","link":"/2022/12/04/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"},{"title":"Rust-note-04所有权","text":"一.什么是所有权 Rust的核心特性是所有权 所有程序在运行是必须管理它们使用内存的方式 有些语言有垃圾收集机制，在运行是，会自动去寻找不再使用的内存 其他语言中，必须手动地分配和释放内存 Rust使用了第三种方式 内存通过一个所有权系统来管理，其中包含一组编译器在编译时检查的规则 所以当程序运行是，所有权特性不会拖慢程序的运行速度 Stack &amp; Heap 在Rust这样的系统级编程语言中，一个值是在stack还是再heap上对程序的行为和如何做决定有很大的影响 Stack stack 按值的接受顺序来存储,按相反的顺序移除(LIFO) push pop 所有存在stack上的数据必须有已知且固定的大小 编译时未知大小的数据或是运行时大小可能发生改变的数据必须存储在heap上 Heap 将数据存入 heap 时，会请求一定空间 系统在 heap 中找到一块足够大的空间时，将它标记为在用，并返回一个指针 存储数据 将值压入 stack 不叫分配 因为指针是已知固定大小，可以把指针放在 stack 上 想要实际数据可以使用指针来定位 将数据压入 stack 比从 heap 中分配要快得多： 因为系统无需寻找空间，只需要压入顶部 访问数据 访问 heap 要比访问 stack 慢得多，因为要通过指针才能找到 heap 中的数据 对于现代计算机，由于缓存的存在，指令在内存中跳转得越少，那么速度越快 函数的调用 调用函数时，值被传入到函数(包括指向 heap 的指针)。函数的变量压入 stack 中。函数结束后，这些值会被弹出 所有权存在的原因 所有权解决了什么？ 跟踪代码那些部分在使用 heap 的那些数据 最小化 heap 中的重复数据 清理 heap 上未使用的数据 所有权的规则 每个值都有一个变量，这个变量是该值的所有者 每个值同时只能有一个所有者 所有者超出作用域后，这个值会被删除 二.内存与分配 Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域的时候，内存自动还给操作系统 drop 函数 变量和数据交互的方式：Move 多个变量可以与同一个数据使用一种独特的方式来交互12let x = 5;let y = x; 整数是已知大小且固定大小的值，这两个5都被压入 stack 中 变量和数据交互的方式：Move(String) 一个 string 由三部分组成： 指针 长度 容量 123let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{}, world!&quot;, s1); 将 s1 赋给 s2 时，将数据复制了一份： 在 stack 上复制了一份（指针 长度 容量） 但是没有复制 heap 上的数据 离开作用域后，会调用drop函数，将heap中的内存释放 当 s1、s2 都离开时，它们会尝试去释放相同的内存： 二次释放(double free) 为了保证内存安全： Rust 没有选择复制被分配的内存 Rust 使 s1 失效 所以 s1 离开作用域的时候无需释放任何内存 如果尝试使用 s1 会有以下错误 浅拷贝(shallow copy) 深拷贝(deep copy) 由于 Rust 让 s1 失效，所以使用新的术语：移动(Move) 隐含的一个原则：Rust 不会自动创建数据的深拷贝 就运行性能而言，任何自动赋值的操作都是廉价的 克隆(clone)如果想要 s1，s2 均有效，可以使用 clone方法(深度拷贝) 123let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone();println!(&quot;{}, world!&quot;, s1); stack上：复制123let x = 5;let y = x;println!(&quot;x = {}, y = {}&quot;, x, y); Copy trait 可以用于想整数这样完全存放在 stack 上的类型 如果一个类型实现了 copy 这个 tarit ，那么旧的变量在赋值后仍然可用 如果一个类型或者该类型的一部分实现了 drop trait ，那么Rust不允许它再去实现 copy tarit 拥有 copy trait的类型 任何简单标量的组合类型都可copy 需要分配资源的不可copy 有 copy tarit 的类型 所有整数 bool char float Tuple(如果所有字段可copy) 三.涉及函数的所有权机制 对于变量而言函数的所有权问题显得非常奇怪 函数参数的所有权机制123456789101112131415161718192021222324252627fn main() { let s = String::from(&quot;hello&quot;); // s 被声明有效 takes_ownership(s); // s 的值被当作参数传入函数 // 所以可以当作 s 已经被移动，从这里开始已经无效 let x = 5; // x 被声明有效 makes_copy(x); // x 的值被当作参数传入函数 // 但 x 是基本类型，依然有效 // 在这里依然可以使用 x 却不能使用 s} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放fn takes_ownership(some_string: String) { // 一个 String 参数 some_string 传入，有效 println!(&quot;{}&quot;, some_string);} // 函数结束, 参数 some_string 在这里释放fn makes_copy(some_integer: i32) { // 一个 i32 参数 some_integer 传入，有效 println!(&quot;{}&quot;, some_integer);} // 函数结束, 参数 some_integer 是基本类型, 无需释放 如果将变量作为参数传入函数，那么它和移动的效果是一样的 函数返回值的所有权机制 被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。 123456789101112131415161718192021222324fn main() { let s1 = gives_ownership(); // gives_ownership 移动它的返回值到 s1 let s2 = String::from(&quot;hello&quot;); // s2 被声明有效 let s3 = takes_and_gives_back(s2); // s2 被当作参数移动, s3 获得返回值所有权} // s3 无效被释放, s2 被移动, s1 无效被释放.fn gives_ownership() -&gt; String { let some_string = String::from(&quot;hello&quot;); // some_string 被声明有效 return some_string; // some_string 被当作返回值移动出函数}fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 被声明有效 a_string // a_string 被当作返回值移出函数} 四.引用与租借引用与租借简单解释 引用（Reference）是 C++ 开发者较为熟悉的概念。如果你熟悉指针的概念，你可以把它看作一种指针。实质上”引用”是变量的间接访问方式。 例子： 12345fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; println!(&quot;s1 is {}, s2 is {}&quot;, s1, s2);} 运行结果: s1 is hello, s2 is hello &amp; 运算符可以取变量的”引用”。 当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值： 函数参数传递的道理相同: 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()} The length of ‘hello’ is 5. 参数类型是 &amp;String 而不是 String &amp; 符号表示引用：允许你引用某些值而不取得所有权 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权： 123456fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; let s3 = s1; // 此时hello已经属于s3，不再属于s1，此时s2无法使用 println!(&quot;{}&quot;, s2);} 这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借： 1234567fn main() { let s1 = String::from(&quot;hello&quot;); let mut s2 = &amp;s1; let s3 = s1; s2 = &amp;s3; // 重新从 s3 租借所有权 println!(&quot;{}&quot;, s2);} 这段程序是正确的。既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。如果尝试利用租借来的权利来修改数据会被阻止： 把引用作为参数的行为成为借用 无法修改借用的东西 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.push_str(&quot;, world!&quot;); // 错误，禁止修改租借的值 s.len()} 和变量一样，引用默认也是不可变的 这段程序中 s2 尝试修改 s1 的值被阻止，租借的所有权不能修改所有者的值。 当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的： 可变引用示例 12345678910111213fn main() { let mut s1 = String::from(&quot;hello&quot;); // s1可变 let len = calculate_length(&amp;mut s1); // 传入函数的是可变的引用 println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;mut String) -&gt; usize { s.push_str(&quot;, world!&quot;); s.len()} OUTPUT --&gt; The length of 'hello, world!' is 13. 这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。 可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以： 123456let mut s = String::from(&quot;hello&quot;);let r1 = &amp;mut s;let r2 = &amp;mut s;println!(&quot;{}, {}&quot;, r1, r2); 这段程序不正确，因为多重可变引用了 s。 Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。 由于发生数据竞争的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。 以下三种行为会发生数据竞争： 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有任何机制来同步数据的访问 所以可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用； 可以在编译时防止数据竞争 可以通过创建新的作用域来创建多个可变引用 1234567fn main() { let mut s = String::from(&quot;hello&quot;); { let r1 = &amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems let r2 = &amp;mut s;} 另一个限制 不可以同时拥有一个可变引用和一个不可变引用（因为有了一个不可变引用同时有一个可变说明不可变可变） 但是多个不可变引用是可以的 1234567fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; // no problem let r2 = &amp;s; // no problem let r3 = &amp;mut s; // BIG PROBLEM println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);} 悬空引用(Dangling Reference) 悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块地址可能已经被释放并分配给其他人使用 在 Rust 里，编译器会保证引用永远不会悬空： 如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域 12345678fn main() { let r = dangle();}fn dangle() -&gt; &amp;String { // dangle returns a reference to a String let s = String::from(&quot;hello&quot;); // s is a new String &amp;s // we return a reference to the String, s} // Here, s goes out of scope, and is dropped. Its memory goes away. Danger! 引用的规则 在任何给定的时刻，只能满足下列条件之一：. - 一个可变的引用 任意数量不可变的引用 引用必须一直有效","link":"/2022/12/04/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/"},{"title":"Rust-note-06结构","text":"一.结构 定义 struct 使用 struct 关键字，并命名 在{…}内，为所有字段(Field)定义名称和类型 例如： 123456struct User{ username: String, email: String, sign_in_count: u64, active: bool,} 实例化 stuct 要创建实例 (废话但是废话好有道理啊) 为字段指定值(要全部指定) 无需按顺序 例子 123456let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,}; 取 struct 中的值 使用点运算符： 1234567let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,};user1.email = String::from(&quot;what?what?&quot;); 一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的 struct 作为函数返回值 此时这个 user 作为此函数的返回值 12345678fn build_user(email: String, username: String) -&gt; User { User { username: username, email: email, sign_in_count: 1, active: true, }} 元组结构体有一种更简单的定义和使用结构体的方式：元组结构体。 元组结构体是一种形式是元组的结构体。 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据： 12345struct Color(u8, u8, u8);struct Point(f64, f64);let black = Color(0, 0, 0);let origin = Point(0.0, 0.0); 使用方式和元组一样，可以使用下标来访问： 12345678910fn main() { struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2); println!(&quot;origin = ({}, {})&quot;, origin.0, origin.1);} 结构体所有权结构体必须掌握字段值所有权，因为在结构体失效时会释放所有字段。 输出结构体可以加入 #[derive(Debug)]来输出整个结构体 123456789101112#[derive(Debug)]struct Rectangle { width: u32, height: u32,}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1 is {:?}&quot;, rect1); // 使用{:?}占位符来输出整个结构体} rect1 is Rectangle { width: 30, height: 50 } 使用{:?} rect1 is Rectangle { 使用{:#?} width: 30, height: 50} 结构体方法方法和函数是类似的，但是是通过结构体来实现。 Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象可以在 Rust 实现。 结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。 123456789101112131415struct Rectangle { width: u32, height: u32,} impl Rectangle { fn area(&amp;self) -&gt; u32 { self.width * self.height }}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1's area is {}&quot;, rect1.area());} rect1’s area is 1500 结构体关联函数有些函数不依靠实例，但是使用需要注明是来自哪个impl模块 12345678910111213141516#[derive(Debug)]struct Rectangle { width: u32, height: u32,}impl Rectangle { fn create(width: u32, height: u32) -&gt; Rectangle { Rectangle { width, height } }}fn main() { let rect = Rectangle::create(30, 50); println!(&quot;{:?}&quot;, rect);}","link":"/2022/12/05/07-RUST06%E7%BB%93%E6%9E%84/"},{"title":"Rust-note-05切片","text":"一.Rust Slice切片（Slice）是对数据值的部分引用。 字符串切片12345678fn main() { let s = String::from(&quot;broadcast&quot;); let part1 = &amp;s[0..5]; let part2 = &amp;s[5..9]; println!(&quot;{}={}+{}&quot;, s, part1, part2);} broadcast=broad+cast x..y == [x,y) ..y 等价于 0..yx.. 等价于位置 x 到数据结束.. 等价于位置 0 到结束 非字符串切片1234567fn main() { let arr = [1, 3, 5, 7, 9]; let part = &amp;arr[0..3]; for i in part.iter() { println!(&quot;{}&quot;, i); }} 1 2 3","link":"/2022/12/04/07-RUST05%E5%88%87%E7%89%87/"},{"title":"About JWT(JSON Web Token)","text":"JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。 这玩意是个啥 JSONweb token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 为什么要有JWT这需要提到基于token的身份认证和传统的session认证的区别 传统的session认证访问网站是使用的http协议本身是无状态的，这就意味着如果用户需要进行身份认证，那么在下一次请求就需要再一次提交认证请求，而服务器必须存储用户登录的信息 这就意味着用户数量过高会使服务器无法承受访问压力 问题 Session: 用户经过我们的应用认证之后，都要在服务端做一次记录，从而分辨用户，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于Token的鉴权虽然也是无状态的协议，但是不需要服务端去保留用户的认证信息，从而降低了服务器的压力同时提高了拓展能力 流程 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 关于JWT格式JWT是由三段信息通过.连接组成的字符串 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 如何构成第一段被称为头部(header)，第二段被称为载荷(payload)，第三段称为(signature) header这里承载了JWT的元数据，例如 1234{ 'typ': 'JWT', 'alg': 'HS256'} 再对此使用Base64URL进行加密成为以下的样子 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload顾名思义，它承载了有效信息，除一些私有字段外，JWT官方规定了7个字段可供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 不过JWT默认时没有加密的，所以别把密码什么的私密信息写进去(我干过) signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 其中的secret是只有服务端才知道，绝对不能泄露，然后使用header中指定的签名算法对其进行加密，以下以SHA256为例 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) Base64URLBase64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 如何使用一般是在请求头里加入Authorization，并同时加上Bearer标注(直接写query里也有)： 1234567fetch('~~~~', { headers: { 'Authorization': 'Bearer ' + token }}) 总结 由于JSON的通用性，所以JWT可以被很多语言通用 可以在payload中写入一些业务逻辑需要但非敏感的信息 利于传输 不需要在服务端保存信息，易于拓展","link":"/2023/01/27/08-About%20JSON%20Web%20Token/"},{"title":"SQL常用命令","text":"1. SQL常用命令SQL 不区分大小写，SELECT与select是相同的。 某些数据库系统要求在每条 SQL 语句的末端使用分号。使用分号作为结束可以在一个请求中对服务器进行一条以上的语句。 比较重要的命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECT 语句 SELECT 语句用于从数据库中选取数据。 12SELECT column_name,column_nameFROM table_name; 或者 1SELECT * FROM table_name; 演示 1SELECT * FORM users; 此语句从 users 表中选取所有列 1SELECT name,age FROM users; 此语句从 users 表中选取age和name两列 WHERE 语句 WHERE 子句用于提取那些满足指定条件的记录。 123SELECT column_name,column_nameFROM table_nameWHERE column_name operator value; 演示 1SELECT * FROM users WHERE name='u1'; 此语句从 user表中选取name列都是”u1”的记录 WHERE 字句中的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 AND &amp; OR 运算符 AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 演示 1234567891011SELECT * FROM WebsitesWHERE country='CN'AND alexa &gt; 50;SELECT * FROM WebsitesWHERE country='USA'OR country='CN';SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); INSERT INTO 语句 INSERT INTO 语句可以有两种编写形式。 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： 12INSERT INTO *table_name*VALUES (*value1*,*value2*,*value3*,...); 第二种形式需要指定列名及被插入的值： 12INSERT INTO *table_name* (*column1*,*column2*,*column3*,...)VALUES (*value1*,*value2*,*value3*,...); 演示 1INSERT INTO users (name,age) VALUES ('u3',10); UPDATE 语句 显而易见是用来更新表中已有的记录。 123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; 演示 1UPDATE users SET age=18 WHERE name='u3'; 警告 如果省略了 WHERE 字句 会将所有 age 改为18 1UPDATE users SET age=18; DELETE 语句 用于删除表中的一行记录。 12DELETE FROM table_nameWHERE some_column=some_value; 演示 1DELETE FROM users WHERE age = 18; 删除了 age = 18 的一条记录 警告 和 UPDATE 同理，漏掉 WHERE 会删除表中所有记录","link":"/2022/11/23/03SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"杂谈01","text":"来点闲话2022/11/23 记 到大学已经3个多月了，emmm其实和我想象中区别不大，没有那么不堪也没有所谓的如此美好，总结一下算是满意吧。 到现在已经结束了期中考，不是很理想也不是很糟糕(主要没像高中一样这么认真，现在真就是全依我性子学了)，还算是过了3个月算是充实的大学生活吧。 原以为我到大学会和以前一样不爱搭理人，不过在期间还是遇见了不少有趣的人们，而且被学长学姐视为“老油条”（笑死，喜欢钻学校空子罢了，不过确实一直挑战防疫底线，kkk)，还是想多认识认识志同道合有趣的灵魂们，大学不能把我自己烂在寝室里嘞。 我认为高中期间我是个容易陷入低沉的家伙，其实就是内耗吧，三年下来没少折磨过自己，多亏了高中同学们的包容，让我多次在焦虑与折磨中感受到他人的善意。高考结束后觉得以前许多事实在是没有意义，但是成长过程中或许这些法难以避免吧，到了现在算是有所改观。我之所以有现在的这样的态度离不开他人对我我关心与善意，在这里对我过去无意伤害过的亲友道个歉，暑假后我发现我从来不是一个人，不论在家还是学校都有人愿意向我伸出援手，所以希望发现身边的善意，并以善意对待他人，前一阵子看到一句话说:脾气好的原因:因为根本不care大部分和事。 可能说的也对吧，虽然有人说人是自私的，也没错，有可能这些乐于帮助他人的人最后没多少收获，但为了得到什么而去帮助他人是否有些太功利了？虽然人确实是复杂，但我相信从好的角度去看待他人与事情能改变自己的心境，高考前我对大多数人都抱有一丝怨气，当时看什么都难受，但是到大学呆了3个月，给足了自己空间，发觉把人想得更好自己才会更舒服。虽然说社会上也充斥着恶意，但我觉得以温和的方式去处置，没必要太有棱角，这样大家都能有自己的空间。有人说我过的太简单，以后会吃亏，但至少目前我觉得无所谓了，简单是我的方式吧。(不善言辞，兴起一写) 至于生活方面，因为高中养成的习惯，想在生活中掺入一些艺术气息，毕竟生活不能太无趣对吧(不喜勿喷，只是我自己喜欢而已)。 以上是浅薄之见，个人想法而已~ 说点倒霉的 多次睡觉发现晒被子没收(记性极差) 长达半个月丢了伞，而且懒得买，一直淋雨，前两天刚下决心重买(好心疼生活费) PS:今天又忘餐厅了。。。 谈谈期待 一直耽搁的阅读计划总算有点起色，不多看看书可不行嘞~ 再匀点时间到有趣的学业上 再瞎学点杂七杂八的技术实现需求(但是找不到需求)~ 想学乐器(天赋没有，也没学费，哇要哭了)~~ 已经实现的 买了马克西姆12月21号的音乐会的场次，还是比较期待的，毕竟可以见到本人诶！ 混进了杭助~~ 没有错过11月8号的月食，好开心嘞！ 晚点再加！出门了~","link":"/2022/11/23/05%E6%9D%82%E8%B0%88_01/"},{"title":"杂谈02","text":"一千零一面镜子我越是逃离却越是靠近你我越是背过脸却越是看见你 我是一座孤岛处在相思之水中四面八方隔绝我通向你 一千零一面镜子转映着你的容颜我从你开始我在你结束 林清玄：不要忘记飞翔的姿势在穿过林间的时候，我觉得麻雀的死亡给我一些启示，我们虽然在尘网中生活，但永远不要失去想飞的心，不要忘记飞翔的姿势。","link":"/2022/11/27/06%E6%9D%82%E8%B0%88_02/"},{"title":"写个TERTRIS","text":"用go写了个TETRIS突发奇想闲来无事情想用go写一个Tertris（俄罗斯方块）玩 上网小小检索了一下，确实有很多可以实现游戏ui的2D引擎，但比较懒，不是很像搞明白怎么去用，所以选择了直接在终端打印出来。 既然想做，那就想想应该如何设计 先看看正版到底长啥样 分析一下： 有个方方的游戏区域（显而易见） 方块会自然下落（这个嘛，没想好怎么处理就设计成直接放置的那种） 一行满了消去一行，然后下落 开始写吧先定义一个游戏结构 123456789101112type Game struct { Board [][]int // 游戏区域 Active [][]int // 还没用上，原来打算用来保存可掉落信息的 Score int Level int}const ( WIDTH = 15 // 区域大小啦 HEIGHT = 20) 第一步当然是初始化了 1234567func BoardInit(g *define.Game) { // 初始化游戏板 g.Board = make([][]int, define.HEIGHT) for i := range g.Board { g.Board[i] = make([]int, define.WIDTH) }} 然后就是打印出游戏区域 1234567891011121314151617181920212223// 打印游戏板func PrintBoard(g *define.Game) { // 这里是在每次出现变动时清除内容 cmd := exec.Command(&quot;cmd&quot;, &quot;/c&quot;, &quot;cls&quot;) cmd.Stdout = os.Stdout cmd.Run() // ... /// for i := range g.Board { fmt.Print(&quot;|&quot;) if i == 4 { fmt.Print(&quot;------------------------------|\\n|&quot;) } for j := range g.Board[i] { if g.Board[i][j] == 0 { // 有方块的话就打印一个矩形 fmt.Print(&quot; &quot;) } else { fmt.Print(&quot;■ &quot;) } } fmt.Printf(&quot;|\\n&quot;) } fmt.Print(&quot;|------------------------------|\\n&quot;)} 就可以看到像这样的输出 然后就应该在上方形成方块了 因为只有7种基本形状，于是为决定直接定义7个基本形状 至于为什么定义为4x4,是因为在游戏中这些方块是可以旋转的，为了简单起见，决定统一定义成4x4的结构，在旋转中只需修改它们的位置就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445var Tetrominoes = [][][]int{ { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 0, 0, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 0, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 1, 1, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {0, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, },} 每次获取的方块都是随机的于是 12345678910111213141516171819202122232425262728func RandomTetromino() [][]int { // 对随机数生成器进行种子随机化 rand.Seed(time.Now().UnixNano()) // 从Tetrominoes数组中随机选择一个形状 shape := define.Tetrominoes[rand.Intn(len(define.Tetrominoes))] // 复制所选形状的矩阵到游戏板里 tetromino := make([][]int, len(shape)) for i := range shape { tetromino[i] = make([]int, len(shape[i])) copy(tetromino[i], shape[i]) } return tetromino}func NewTetrominoIn(g *define.Game) { // 生成新的俄罗斯方块 nextTetromino := RandomTetromino() for i := range nextTetromino { for j := range nextTetromino[i] { if nextTetromino[i][j] == 1 { g.Board[i][j] = 1 } } }} 就可以打印出类似于这样的界面 至于移动或旋转就很简单了，只需找到生成的方块再作相应处理就好了，这里就不贴出代码了。 下面处理消去一行的操作 其实就是每次遍历一下 1234567891011121314151617181920212223func ClearFullRows(g *define.Game) { // ... // flag := true for y := define.HEIGHT - 1; y &gt;= 0; y-- { flag = true for x := 0; x &lt; define.WIDTH; x++ { if g.Board[y][x] == 0 { flag = false break } } if flag { // 去除被消去的行 for x := 0; x &lt; define.WIDTH; x++ { g.Board[y][x] = 0 } // ... // } }} 这时候就有了个问题 如何下落？ 首先，相互连接的方块是不可以掉到底部的 消去的不一定是下一行 所有相连的方块是一个整体 那这有有点头疼了，首先就是如何找到掉落方块整体，然后如何确定掉落高度 那就先处理如何找到掉落方块整体区间由于只需要确定最小下落值，所以只用确定方块的左右范围就好了，但如何区查找呢？ 因为整体说明这些方块左右上下想连，所以可以使用DFS算法去查找! 这里格外传入了i和j两个值代表开始检索的左下角，因为只有在清除行上的部分才会发生掉落，所以要传入坐标以确定起始位置 而传入的left和right就修改为得到的数值而继续使用 12345678910111213141516171819202122func Dfs(grid [][]int, i int, j int, visited [][]bool, left *int, right *int) { // 检查当前位置是否已经被访问过，或者是否为0 if i &lt; 0 || i &gt;= len(grid) || j &lt; 0 || j &gt;= len(grid[0]) || grid[i][j] == 0 || visited[i][j] { return } // 将当前位置标记为已访问 visited[i][j] = true // 更新左右边界 if *left &gt; j { *left = j } if *right &lt; j { *right = j } // 递归遍历相邻的位置 Dfs(grid, i-1, j, visited, left, right) // 上 Dfs(grid, i+1, j, visited, left, right) // 下 Dfs(grid, i, j-1, visited, left, right) // 左 Dfs(grid, i, j+1, visited, left, right) // 右} 关于掉落块的掉落高度emmm好像没啥好分析的，直接给出代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 从左往右查找，这个方法比较蠢// startLine 代表的是被消去的那一行// 详细代码在仓库里func Drop(g *define.Game, startLine int) { column := 0 for column &lt; define.WIDTH { // 左右开始是重合的 left, right := column, column for y := startLine; y &gt;= 5; y-- { // 找到第一个方块，然后进行搜索 if g.Board[y][column] == 1 { visited := make([][]bool, len(g.Board)) for i := range visited { visited[i] = make([]bool, len(g.Board[i])) } // 通过Dfs查找范围 utils.Dfs(g.Board, y, column, visited, &amp;left, &amp;right) break } } var dropHeight int = 999 top := startLine for i := left; i &lt;= right; i++ { for y := startLine; y &gt;= 0; y-- { if g.Board[y][i] == 1 { top = y break } } for y := top + 1; y &lt;= define.HEIGHT; y++ { if y == define.HEIGHT || g.Board[y][i] == 1 { if dropHeight &gt; y-top-1 { dropHeight = y - top - 1 } break } } } // 获取了掉落高度，将范围内的下移 for i := left; i &lt;= right; i++ { for y := top; y &gt;= 5; y-- { g.Board[y+dropHeight][i] = g.Board[y][i] g.Board[y][i] = 0 } } column = right + 1 }} 运行例子，可能一定还有一堆bug，不过能跑就好 这是我的代码仓库，还有许多不足，望日后逐步修正","link":"/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/"},{"title":"Docker Desktop","text":"Docker Desktop使用记录安装(Win)我用的是Windows下的Docker Desktop，众所周知，docker 只有 linux 的发行版本，作为 windows 用户想要使用 docker 的功能自然仅能通过加装虚拟机这一条途径。同样，号称支持 windows 系统的 docker desktop 也是基于同样原理 —— 默认使用 windows 自带的 Hyper-V 服务允许 docker。 所以想安装 docker desktop 就要确保您的 windows 系统支持 wsl(适用于 Linux 的 Windows 子系统) 功能。我们可以直接在 cmd 或 powershell 中输入wsl 来检查是否开启了wsl服务。 打开 控制面板-&gt;程序-&gt;启用或关闭Windows功能，假如有 Hyper-V 和 适用于 Linux 的 Windows 子系统这两个选项，那就愉快得开启，假如没有那你就得去安装一下了 Hyper-V 123456789pushd &quot;%~dp0&quot;dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL wsl 在管理员模式下打开 PowerShell 或 Windows 命令提示符，输入 wsl --install 命令，然后重启电脑。 安装 Docker Desktop 如果每次启动都闪退，可能是你开启了SMB 1.0/CIFS 文件共享支持,去windows功能里给它关了就行了 一些设置镜像站设置众所周知在天朝有些地方没法正常访问，所以为了加快拉取镜像的速度，需要设置一些镜像站。 来到这个页面更改里面的配置 以下是我的设置，当然你可以自己去找选择自己喜欢的。 12345678{ &quot;registry-mirrors&quot;: [ &quot;https://dockerproxy.com&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;https://mirror.baidubce.com&quot;, &quot;https://ccr.ccs.tencentyun.com&quot; ]} 使用获取镜像 在docker hub寻找需要下载的镜像（在cmd中执行docker search [镜像名]命令也可） 现在也可以直接在上面搜出来","link":"/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/"},{"title":"Linux 性能-00","text":"何为性能指标？性能是什么？大多数人的第一反应大多是速度快，而这正对应着两个指标吞吐和延时。然而这两个指标是从用户体验来看的，这两个指标可以从应用负载的角度来考察。与之相反的就是从系统资源的角度来看，比如资源使用率等。 众所周知，随着负载的增加，消耗的系统资源也会随之上升，而性能问题的本质是系统资源耗尽，无法处理足够的请求。 性能分析，其实就是找出应用或者系统的瓶颈，并设法去避免或者缓解，从而处理更多的请求，一般保研以下步骤： 选择指标评估应用程序和系统的性能； 为应用程序和系统设置性能目标； 进行性能基准测试； 性能分析定位瓶颈； 优化系统和应用程序； 性能监控和告警。 一些性能工具 你可以在这里找到它们","link":"/2023/04/11/11Linux%E6%80%A7%E8%83%BD-00/"},{"title":"Linux 性能-01","text":"平均负载（Load Average）是什么意思每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。 12$ uptime02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88 在load average中分别是过去 1 分钟、5 分钟、15 分钟的平均负载。 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数 所谓可运行的进程，指的是正在使用或者正在等待CPU的进程。而平均负载可以理解为单位时间内有几个活跃的进程(事实上要复杂得多,实际上是活跃进程数的指数衰减平均值数学差的我根本不想去理解)。 那么对一个系统而言，负载高了显然是一件糟糕的事情，假如负载小于CPU的核心个数那意味着还有一些空闲，假如负载高于CPU的核心数目那意味着有些进程没法得到处理that’s bad。 平均负载为多少时合理可以想到，假如负载刚好等于CPU个数既不会有资源的浪费也没有进程无法得到处理。 为了知道CPU的个数可以使用以下命令： 12$ grep 'model name' /proc/cpuinfo | wc -l4 打个比方，平均负载的值越高，表示系统中需要运行的进程越多，系统越繁忙。反之，如果平均负载较低，表示系统相对空闲。为了更好地理解这个概念，我们可以将平均负载与现实生活中的一个例子相类比：超市的排队人数。假设超市有 4 个收银台，如果排队的人数为 4，那么每个收银台都有一个顾客在结账，系统运行得比较顺畅。如果排队的人数超过 4，那么一些顾客需要等待，系统开始变得繁忙。如果排队的人数远远超过 4，那么等待时间会变得很长，系统会变得非常繁忙。 其实在先前的 uptime命令获取到的3个时间段的负载中可以分析出不少信息： 首先，假如三个时间段的数值差距不大，这说明系统负载平稳，没有什么突发的进程。 假如1分钟的数值远小于15分钟的值，这说明在15分钟内有很高的负载，但在最近一分钟开始降低负载。 相反，假如1分钟的数值远大于15分钟的值，那说明最近系统负载正在上升。 这时候我们也会疑惑，当平均负载高于多少时应该做出行动，网上的建议是平均负载超出CPU最大负载的70%的时候应该排查一下问题，因为此时就可能影响服务的正常运行。但更合适的做法是联系起系统的长期负载，进行更深层次的分析后再做出处理。 相关命令1234567891011cpu核数: lscpu、 grep 'model name' /proc/cpuinfo | wc -l显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势watch -d uptime: -d会高亮显示变化的区域strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--timeout 执行时间mpstat: 多核cpu性能分析工具，-P ALL监视所有cpupidstat: 进程性能分析工具，-u 显示cpu利用率 总结平均负载指的是：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。","link":"/2023/04/12/11Linux%E6%80%A7%E8%83%BD-01/"}],"tags":[{"name":"网盘挂载","slug":"网盘挂载","link":"/tags/%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"name":"随记","slug":"随记","link":"/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"鉴权","slug":"鉴权","link":"/tags/%E9%89%B4%E6%9D%83/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"性能调优","slug":"性能调优","link":"/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"}],"categories":[{"name":"电影","slug":"电影","link":"/categories/%E7%94%B5%E5%BD%B1/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"鉴权","slug":"鉴权","link":"/categories/%E9%89%B4%E6%9D%83/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"Container","slug":"Container","link":"/categories/Container/"},{"name":"Docker","slug":"Container/Docker","link":"/categories/Container/Docker/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"性能调优","slug":"Linux/性能调优","link":"/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"}],"pages":[{"title":"","text":"Helo！我是Golden Sheep(Github上是Gloden？对不起！其实是我打错了，更搞笑的是域名当时也记错了所以才有了这么一个乌龙，但是毕竟舍不得买域名的钱，那就将错就错吧 Gloden—&gt;辉光&lt;感觉也挺好听的嘛&gt; )！大学牲一只🎓~ 热爱料理与手冲咖啡，还会一丢丢烘焙，不过水平低下 喜欢旅行、影视 我的豆瓣 书影音已达750部 、钢笔收藏、单晶制作（退坑辣已经）、骑行、沙盒游戏单机3A 、番剧op、古典音乐~ 除了技术帖子还会带上一些私货 like music or movies~ 🐬","link":"/about/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/M2B/index.html"}]}