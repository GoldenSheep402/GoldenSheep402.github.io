{"posts":[{"title":"再观《放牛班的春天》","text":"小小的观后感有人说，这部电影让人明白了何为师德，何为园丁。 在这所叫做“池塘之底”的辅育院中，以为矮胖的老师和一群顽劣不堪的孩子们却碰撞出了动人的歌声。 在这歌声中隐藏这的是孩子们对世界的渴望。 这部电影，没有高饱和度，也没有宏大的场面，但它却像一部美丽的童话，满是对希望的赞颂。 它多面而又真实，没有一个孩子出生就是邪恶的，打骂和体罚只会令他们的肉体屈服。但在我看来，这些孩子们的调皮行为更像是为了引起他人的注意，而不是怀揣着恶意去伤害他人。 王尔德说，生活在阴沟里，依然有仰望星空的权利。是的，无论你是成年人还是孩童，无论现在是家财万贯还是一贫如洗，即使跌入“池塘之底”，也依然可以找寻自己内心的光明。不得不说，影片主题深刻，一帧帧画面和一句句台词都闪耀着人性的光芒。 希望我也能变得更加温暖，让自己让身边的人变得更好，让生活让世界变得更美。 纸飞机飞出窗口，蓝天下挥舞的小手，童年像一串串鸽子，拍打翅膀，一飞就永不回头","link":"/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/"},{"title":"使用Alist挂载OneDrive网盘","text":"首先白嫖OneDrive的5T云盘申请微软开发者账号申请地址：https://developer.microsoft.com/zh-cn/microsoft-365/dev-program 点击立即加入！ 注册开发者根据指引填写各类资料后注册。 公司的话随便写 设置E5订阅[] 至此，账户就已经拥有为期90天的E5订阅了，并一次性申请了25个用户许可证。 如果你只是自己用，现在已经可以使用”用户名@域.onmicrosoft.com” 和之前设置的密码登录你电脑上的Office了。 获取5T容量[] 保存后OneDrive容量即升级成5T! 续期E5开发者账户自行上网找办法~~ 为Alist先注册一个API[ Web的url是 https://tool.nn.ci/onedrive/callback 下文还会用到 [ 这个就是client secert的值，先保存下来 [ 给api获取读写权限 到这里OneDrive设置已经完成,下面去https://tool.nn.ci/onedrive/request 获取刷新令牌, 莱斯沟~ [ 生成refresh token client_id : 客户端ID client_secret : 客户端密钥 redirect_uri : 重定向URL refresh_token : 刷新令牌 Alist是什么Alist 是一款支持多种存储的目录文件列表程序，支持 web 浏览与 webdav，后端基于gin，前端使用react。 官网地址 官网文档 支持存储类型 本地存储 阿里云盘 OneDrive / Sharepoint 天翼云盘 GoogleDrive 123 云盘 蓝奏云 Alist FTP PikPak 闪电盘 S3 WebDav Teambition（中国，国际） 分秒帧 和彩云 (个人云, 家庭云) Yandex.Disk 百度网盘 夸克网盘 迅雷云盘 部署 安装 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install 更新 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update 卸载 curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall 自定义安装路径 123456 # 安装curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install /home/power # 更新curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update /home/power # 卸载curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall /home/power 访问服务脚本部署完成后，Alist默认分配5244端口，密码则会在安装后显示。 1http://YOUR_IP:5244/ 本地目录配置挂载路径：既网盘挂载后路径，可以随意。 地区：选网盘所在地。 客户端ID：client-id 客户端秘钥：client-secret 重定向URI:https://tool.nn.ci/onedrive/callback （不保证时效） 刷新令牌：refresh-token 将这些数据保存后就能看到主页的网盘目录了。 参考 OneDrive | Alist Document (nn.ci)","link":"/2022/11/05/00%E4%BD%BF%E7%94%A8Alist%E6%8C%82%E8%BD%BDOneDrive%E7%BD%91%E7%9B%98/"},{"title":"My-First-Blog","text":"My-First-Blog建一个属于自己的博客是我很早就有的想法，但是一直没能有机会与动力去实现。 真正开始行动是在2022/11/04的晚上，因为那天早上刚挂载了网盘，于是特别有兴致，打算一鼓作气。 然而，我几乎踩遍了所有的坑（或许这是我的天赋吧），最后在各位学长学姐的帮助下顺利上线了我的博客，在这里对那几位学长学姐的帮助表达我由衷的感谢！ 一.对目前生活的些许看法 到了大学怎么说，没有高中那些好朋友在身边玩耍，隐隐约约感到高中班主任所说的：“到大学是孤独的旅途”这句话的合理之处了，但生活还是很充实而美好的！ 搁置了很久的阅读还没开始（2022/11/05 还在读Loita），立个小flag——一个月一本！保证基本的阅读。 希望家里的妹妹有认真学习哈，（其实无所谓傲，毕竟我小学可不是个乖孩子） 又熬夜辣~~ 下次一定 二.小想法多花点时间学学曾经没能接触的知识，总算从高中学习中脱离出来了，高中也玩够了是时候achieve something辣！ 三.还有什么吗？？？？Who knows~","link":"/2022/11/04/04My%20First%20Blog/"},{"title":"About JWT(JSON Web Token)","text":"JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。 这玩意是个啥 JSONweb token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 为什么要有JWT这需要提到基于token的身份认证和传统的session认证的区别 传统的session认证访问网站是使用的http协议本身是无状态的，这就意味着如果用户需要进行身份认证，那么在下一次请求就需要再一次提交认证请求，而服务器必须存储用户登录的信息 这就意味着用户数量过高会使服务器无法承受访问压力 问题 Session: 用户经过我们的应用认证之后，都要在服务端做一次记录，从而分辨用户，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于Token的鉴权虽然也是无状态的协议，但是不需要服务端去保留用户的认证信息，从而降低了服务器的压力同时提高了拓展能力 流程 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 关于JWT格式JWT是由三段信息通过.连接组成的字符串 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 如何构成第一段被称为头部(header)，第二段被称为载荷(payload)，第三段称为(signature) header这里承载了JWT的元数据，例如 1234{ 'typ': 'JWT', 'alg': 'HS256'} 再对此使用Base64URL进行加密成为以下的样子 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload顾名思义，它承载了有效信息，除一些私有字段外，JWT官方规定了7个字段可供选用 iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 不过JWT默认时没有加密的，所以别把密码什么的私密信息写进去(我干过) signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 其中的secret是只有服务端才知道，绝对不能泄露，然后使用header中指定的签名算法对其进行加密，以下以SHA256为例 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) Base64URLBase64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 如何使用一般是在请求头里加入Authorization，并同时加上Bearer标注(直接写query里也有)： 1234567fetch('~~~~', { headers: { 'Authorization': 'Bearer ' + token }}) 总结 由于JSON的通用性，所以JWT可以被很多语言通用 可以在payload中写入一些业务逻辑需要但非敏感的信息 利于传输 不需要在服务端保存信息，易于拓展","link":"/2023/01/27/08-About%20JSON%20Web%20Token/"},{"title":"杂谈01","text":"来点闲话2022/11/23 记 到大学已经3个多月了，emmm其实和我想象中区别不大，没有那么不堪也没有所谓的如此美好，总结一下算是满意吧。 到现在已经结束了期中考，不是很理想也不是很糟糕(主要没像高中一样这么认真，现在真就是全依我性子学了)，还算是过了3个月算是充实的大学生活吧。 原以为我到大学会和以前一样不爱搭理人，不过在期间还是遇见了不少有趣的人们，而且被学长学姐视为“老油条”（笑死，喜欢钻学校空子罢了，不过确实一直挑战防疫底线，kkk)，还是想多认识认识志同道合有趣的灵魂们，大学不能把我自己烂在寝室里嘞。 我认为高中期间我是个容易陷入低沉的家伙，其实就是内耗吧，三年下来没少折磨过自己，多亏了高中同学们的包容，让我多次在焦虑与折磨中感受到他人的善意。高考结束后觉得以前许多事实在是没有意义，但是成长过程中或许这些法难以避免吧，到了现在算是有所改观。我之所以有现在的这样的态度离不开他人对我我关心与善意，在这里对我过去无意伤害过的亲友道个歉，暑假后我发现我从来不是一个人，不论在家还是学校都有人愿意向我伸出援手，所以希望发现身边的善意，并以善意对待他人，前一阵子看到一句话说:脾气好的原因:因为根本不care大部分和事。 可能说的也对吧，虽然有人说人是自私的，也没错，有可能这些乐于帮助他人的人最后没多少收获，但为了得到什么而去帮助他人是否有些太功利了？虽然人确实是复杂，但我相信从好的角度去看待他人与事情能改变自己的心境，高考前我对大多数人都抱有一丝怨气，当时看什么都难受，但是到大学呆了3个月，给足了自己空间，发觉把人想得更好自己才会更舒服。虽然说社会上也充斥着恶意，但我觉得以温和的方式去处置，没必要太有棱角，这样大家都能有自己的空间。有人说我过的太简单，以后会吃亏，但至少目前我觉得无所谓了，简单是我的方式吧。(不善言辞，兴起一写) 至于生活方面，因为高中养成的习惯，想在生活中掺入一些艺术气息，毕竟生活不能太无趣对吧(不喜勿喷，只是我自己喜欢而已)。 以上是浅薄之见，个人想法而已~ 说点倒霉的 多次睡觉发现晒被子没收(记性极差) 长达半个月丢了伞，而且懒得买，一直淋雨，前两天刚下决心重买(好心疼生活费) PS:今天又忘餐厅了。。。 谈谈期待 一直耽搁的阅读计划总算有点起色，不多看看书可不行嘞~ 再匀点时间到有趣的学业上 再瞎学点杂七杂八的技术实现需求(但是找不到需求)~ 想学乐器(天赋没有，也没学费，哇要哭了)~~ 已经实现的 买了马克西姆12月21号的音乐会的场次，还是比较期待的，毕竟可以见到本人诶！ 混进了杭助~~ 没有错过11月8号的月食，好开心嘞！ 晚点再加！出门了~","link":"/2022/11/23/05%E6%9D%82%E8%B0%88_01/"},{"title":"杂谈02","text":"一千零一面镜子我越是逃离却越是靠近你我越是背过脸却越是看见你 我是一座孤岛处在相思之水中四面八方隔绝我通向你 一千零一面镜子转映着你的容颜我从你开始我在你结束 林清玄：不要忘记飞翔的姿势在穿过林间的时候，我觉得麻雀的死亡给我一些启示，我们虽然在尘网中生活，但永远不要失去想飞的心，不要忘记飞翔的姿势。","link":"/2022/11/27/06%E6%9D%82%E8%B0%88_02/"},{"title":"写个TERTRIS","text":"用go写了个TETRIS突发奇想闲来无事情想用go写一个Tertris（俄罗斯方块）玩 上网小小检索了一下，确实有很多可以实现游戏ui的2D引擎，但比较懒，不是很像搞明白怎么去用，所以选择了直接在终端打印出来。 既然想做，那就想想应该如何设计 先看看正版到底长啥样 分析一下： 有个方方的游戏区域（显而易见） 方块会自然下落（这个嘛，没想好怎么处理就设计成直接放置的那种） 一行满了消去一行，然后下落 开始写吧先定义一个游戏结构 123456789101112type Game struct { Board [][]int // 游戏区域 Active [][]int // 还没用上，原来打算用来保存可掉落信息的 Score int Level int}const ( WIDTH = 15 // 区域大小啦 HEIGHT = 20) 第一步当然是初始化了 1234567func BoardInit(g *define.Game) { // 初始化游戏板 g.Board = make([][]int, define.HEIGHT) for i := range g.Board { g.Board[i] = make([]int, define.WIDTH) }} 然后就是打印出游戏区域 1234567891011121314151617181920212223// 打印游戏板func PrintBoard(g *define.Game) { // 这里是在每次出现变动时清除内容 cmd := exec.Command(&quot;cmd&quot;, &quot;/c&quot;, &quot;cls&quot;) cmd.Stdout = os.Stdout cmd.Run() // ... /// for i := range g.Board { fmt.Print(&quot;|&quot;) if i == 4 { fmt.Print(&quot;------------------------------|\\n|&quot;) } for j := range g.Board[i] { if g.Board[i][j] == 0 { // 有方块的话就打印一个矩形 fmt.Print(&quot; &quot;) } else { fmt.Print(&quot;■ &quot;) } } fmt.Printf(&quot;|\\n&quot;) } fmt.Print(&quot;|------------------------------|\\n&quot;)} 就可以看到像这样的输出 然后就应该在上方形成方块了 因为只有7种基本形状，于是为决定直接定义7个基本形状 至于为什么定义为4x4,是因为在游戏中这些方块是可以旋转的，为了简单起见，决定统一定义成4x4的结构，在旋转中只需修改它们的位置就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445var Tetrominoes = [][][]int{ { {0, 0, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 0, 0, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 0, 1, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {0, 1, 1, 0}, {1, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, }, { {1, 1, 0, 0}, {0, 1, 1, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, },} 每次获取的方块都是随机的于是 12345678910111213141516171819202122232425262728func RandomTetromino() [][]int { // 对随机数生成器进行种子随机化 rand.Seed(time.Now().UnixNano()) // 从Tetrominoes数组中随机选择一个形状 shape := define.Tetrominoes[rand.Intn(len(define.Tetrominoes))] // 复制所选形状的矩阵到游戏板里 tetromino := make([][]int, len(shape)) for i := range shape { tetromino[i] = make([]int, len(shape[i])) copy(tetromino[i], shape[i]) } return tetromino}func NewTetrominoIn(g *define.Game) { // 生成新的俄罗斯方块 nextTetromino := RandomTetromino() for i := range nextTetromino { for j := range nextTetromino[i] { if nextTetromino[i][j] == 1 { g.Board[i][j] = 1 } } }} 就可以打印出类似于这样的界面 至于移动或旋转就很简单了，只需找到生成的方块再作相应处理就好了，这里就不贴出代码了。 下面处理消去一行的操作 其实就是每次遍历一下 1234567891011121314151617181920212223func ClearFullRows(g *define.Game) { // ... // flag := true for y := define.HEIGHT - 1; y &gt;= 0; y-- { flag = true for x := 0; x &lt; define.WIDTH; x++ { if g.Board[y][x] == 0 { flag = false break } } if flag { // 去除被消去的行 for x := 0; x &lt; define.WIDTH; x++ { g.Board[y][x] = 0 } // ... // } }} 这时候就有了个问题 如何下落？ 首先，相互连接的方块是不可以掉到底部的 消去的不一定是下一行 所有相连的方块是一个整体 那这有有点头疼了，首先就是如何找到掉落方块整体，然后如何确定掉落高度 那就先处理如何找到掉落方块整体区间由于只需要确定最小下落值，所以只用确定方块的左右范围就好了，但如何区查找呢？ 因为整体说明这些方块左右上下想连，所以可以使用DFS算法去查找! 这里格外传入了i和j两个值代表开始检索的左下角，因为只有在清除行上的部分才会发生掉落，所以要传入坐标以确定起始位置 而传入的left和right就修改为得到的数值而继续使用 12345678910111213141516171819202122func Dfs(grid [][]int, i int, j int, visited [][]bool, left *int, right *int) { // 检查当前位置是否已经被访问过，或者是否为0 if i &lt; 0 || i &gt;= len(grid) || j &lt; 0 || j &gt;= len(grid[0]) || grid[i][j] == 0 || visited[i][j] { return } // 将当前位置标记为已访问 visited[i][j] = true // 更新左右边界 if *left &gt; j { *left = j } if *right &lt; j { *right = j } // 递归遍历相邻的位置 Dfs(grid, i-1, j, visited, left, right) // 上 Dfs(grid, i+1, j, visited, left, right) // 下 Dfs(grid, i, j-1, visited, left, right) // 左 Dfs(grid, i, j+1, visited, left, right) // 右} 关于掉落块的掉落高度emmm好像没啥好分析的，直接给出代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 从左往右查找，这个方法比较蠢// startLine 代表的是被消去的那一行// 详细代码在仓库里func Drop(g *define.Game, startLine int) { column := 0 for column &lt; define.WIDTH { // 左右开始是重合的 left, right := column, column for y := startLine; y &gt;= 5; y-- { // 找到第一个方块，然后进行搜索 if g.Board[y][column] == 1 { visited := make([][]bool, len(g.Board)) for i := range visited { visited[i] = make([]bool, len(g.Board[i])) } // 通过Dfs查找范围 utils.Dfs(g.Board, y, column, visited, &amp;left, &amp;right) break } } var dropHeight int = 999 top := startLine for i := left; i &lt;= right; i++ { for y := startLine; y &gt;= 0; y-- { if g.Board[y][i] == 1 { top = y break } } for y := top + 1; y &lt;= define.HEIGHT; y++ { if y == define.HEIGHT || g.Board[y][i] == 1 { if dropHeight &gt; y-top-1 { dropHeight = y - top - 1 } break } } } // 获取了掉落高度，将范围内的下移 for i := left; i &lt;= right; i++ { for y := top; y &gt;= 5; y-- { g.Board[y+dropHeight][i] = g.Board[y][i] g.Board[y][i] = 0 } } column = right + 1 }} 运行例子，可能一定还有一堆bug，不过能跑就好 这是我的代码仓库，还有许多不足，望日后逐步修正","link":"/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/"},{"title":"使用Github Action实现Hexo博客自动部署","text":"缘由一天在课上当我准备上传我的Hexo静态博客，但意外的报了个莫名其妙的错，表示无法连接到服务器。当时问了问群u，等我解决后，发现一位群u提到了可以用Github Action触发服务器自动拉取，我也意识到每次都全部上传一遍确实有点烦人，于是我有打算来试试水。 什么是Github Action GitHub Actions 是一种持续集成和持续交付 (CI/CD) 平台，可用于自动执行生成、测试和部署管道。 您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。(这么长看都懒得看) 简单地说，Github Action 提供了 Linux、Windows 和 macOS 虚拟机，用户可以自定义脚本，当检测到特定事件发生是就会执行相应的脚本。 下回有时间写一篇博客详细说说吧。 思路我的想法是当我在本地生成页面后，将页面push到Github的仓库中，同时触发Action，让服务器端自动pull页面，实现博客的部署。 服务器端的配置既然我需要服务器端自动pull我的页面，那么服务器必须安装git，这个应该不用多说。 1234$ apt-git install git$ // 生成你的key，再去github填上$ cd /path$ git clone yourUrl 不过因为我的博客之前是部署在/var/www/html下的，然后我也懒得改，于是在clone后就把文件夹直接改了个名。 Github Action回顾一下想法，首先是在push的时候触发，然后服务器自动pull页面。 创建一个Action点击仓库中的Actions 选择创建一个新的workflow 直接自己创建一个 然后就可以看到一个编辑脚本的界面，我把它重命名为了deply.yml，接下去稍稍解释一下。 这里是定义变量的地方： 12345678910111213141516171819name: deplyon: push: // 发生push操作时候执行 branches: - master // 在哪个分支上jobs: deply: name: auto delpy runs-on: ubuntu-latest steps: - name: clone pages uses: appleboy/ssh-action@master with: // 这几个变量可以在action中自己设置 host: ${{ secrets.HOST }} // 服务器地址 username: ${{ secrets.USER }} // 用户名 password: ${{ secrets.PASSWD }} // 密码 script: cd /var/www/html &amp;&amp; git pull // 在服务器端的执行的脚本 这里的意思是当我push到master分支后，会通过github在HOST上执行脚本，从而实现自动clone的操作。 接下去每当你push一次你的界面，过一会会你就会发现你的博客页面已经更新了。","link":"/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"title":"Rust-note-01变量与可变性","text":"变量与可变性 声明变量用let关键字 默认下是不可变（Immutable） 可以加入mut，使变量可变 变量与常量 常量（constant）,常量在绑定值后也是不可变，但是有许多不同： 不可使用mut，常量永远不可变 声明常量使用const关键字，且类型必须被标注 常量可以在任何作用域中被声明 Shadowing 可以使用相同的名字声明新的变量，新的变量会被shadow之前声明的同名变量 在后续代码中，这个名字代表的就是新的变量","link":"/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"},{"title":"Rust-note-02数据类型","text":"数据类型 标量和复合类型 Rust是静态编译语言，在编译的同时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出它的具体类型 但如果可能的类型太多（例如将string转换为整数的parse方法），就必须添加类型的标注 标量类型 一个标量代表一个单一的值 Rust有四个主要的标量类型： 整数类型 浮点类型 布尔类型 字符类型 整数类型 就是个整数 例如u32是一个无符号整数类型，占据32位空间 无符号用u开头 浮点类型 Rust有两种基础的浮点类型 f32 f64 Rust的浮点类型使用了IEEE-754标注来表述 f64是默认类型，因为在现代CPU上f64和f32速度差不多，且精度更高 布尔类型 true 和 false 两个值 一个字节 符号是bool 字符类型 Rust中的char类型用来表示最基础的单个字符 字符类型的字面值使用单引号 占用4个字节 使用Unicode编码 复合类型 Tuple 可以使用模式匹配来解构一个Tuple来获取值 12345fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); let (x, y, z) = tup; println!(&quot;{}, {}, {}&quot;, x, y, z);} 访问Tuple的元素 在Tuple变量使用点标记，后接元素索引 1234fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); println!(&quot;{}, {}, {}&quot;, tup.0, tup.1, tup.2);} 数组 声明方法：在一个中括号中，各值用逗号分隔 数组的用处 如果想让数据存放在stack中而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处 数组没有Vector灵活 Vector和数组类似，它由标准库提供 Vector的长度可以改变 数组的类型 数组的类型可以以这种形式表示：[类型; 长度]- let a[i32;5] = [1,2,3,4,5]; 另一种声明数组的方法 如果数组的每个元素值都相同，那么可以在： 在中括号中指定初始值 然后是一个 ; 最后是数组长度 let a[3;5]; 等价于 let a = [3,3,3,3,3]; 访问数组的元素 数组是Stack上分配的单个块的内存 可以使用索引 123456789101112131415161718fn main() { let months = [ &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; ]; let first = months[0]; let second = months[1];} 如果访问的索引超出了数组的范围，那么： 编译会通过 运行保存（runtime时panic） Rust不会允许其访问相应地址的内存","link":"/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Rust-note-03函数","text":"Rust 函数基本形式 fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt; 函数参数12345678fn main(){ another_function(5, 6);}fn another_function(x: i32, y: i32) { println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 6 函数体的语句与表达式Rust 的函数体由以表达式(expression)结尾的语句(statement)组成 123456789101112fn main() { let x = 5; let y = { let x = 3; x + 1 // 这是一个表达式，它的值是整个函数的的结果值 // 被叫做函数体表达式(后面不能有;有的话就是一条statement) }; println!(&quot;x 的值为 : {}&quot;, x); println!(&quot;y 的值为 : {}&quot;, y);} x 的值为 : 5y 的值为 : 4 函数的返回值 在-&gt;符号后面声明函数的返回值类型，但不可为返回值命名 在Rust中，返回值是函数体中最后一个表达式的值 若需要提前返回，使用return关键字，并指定一个值 大部分函数都是默认使用最后一个表达式作为返回的值 123fn five() -&gt; i32 { 5 //返回值就是5}","link":"/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/"},{"title":"Rust-note-05切片","text":"一.Rust Slice切片（Slice）是对数据值的部分引用。 字符串切片12345678fn main() { let s = String::from(&quot;broadcast&quot;); let part1 = &amp;s[0..5]; let part2 = &amp;s[5..9]; println!(&quot;{}={}+{}&quot;, s, part1, part2);} broadcast=broad+cast x..y == [x,y) ..y 等价于 0..yx.. 等价于位置 x 到数据结束.. 等价于位置 0 到结束 非字符串切片1234567fn main() { let arr = [1, 3, 5, 7, 9]; let part = &amp;arr[0..3]; for i in part.iter() { println!(&quot;{}&quot;, i); }} 1 2 3","link":"/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/"},{"title":"Rust-note-04所有权","text":"一.什么是所有权 Rust的核心特性是所有权 所有程序在运行是必须管理它们使用内存的方式 有些语言有垃圾收集机制，在运行是，会自动去寻找不再使用的内存 其他语言中，必须手动地分配和释放内存 Rust使用了第三种方式 内存通过一个所有权系统来管理，其中包含一组编译器在编译时检查的规则 所以当程序运行是，所有权特性不会拖慢程序的运行速度 Stack &amp; Heap 在Rust这样的系统级编程语言中，一个值是在stack还是再heap上对程序的行为和如何做决定有很大的影响 Stack stack 按值的接受顺序来存储,按相反的顺序移除(LIFO) push pop 所有存在stack上的数据必须有已知且固定的大小 编译时未知大小的数据或是运行时大小可能发生改变的数据必须存储在heap上 Heap 将数据存入 heap 时，会请求一定空间 系统在 heap 中找到一块足够大的空间时，将它标记为在用，并返回一个指针 存储数据 将值压入 stack 不叫分配 因为指针是已知固定大小，可以把指针放在 stack 上 想要实际数据可以使用指针来定位 将数据压入 stack 比从 heap 中分配要快得多： 因为系统无需寻找空间，只需要压入顶部 访问数据 访问 heap 要比访问 stack 慢得多，因为要通过指针才能找到 heap 中的数据 对于现代计算机，由于缓存的存在，指令在内存中跳转得越少，那么速度越快 函数的调用 调用函数时，值被传入到函数(包括指向 heap 的指针)。函数的变量压入 stack 中。函数结束后，这些值会被弹出 所有权存在的原因 所有权解决了什么？ 跟踪代码那些部分在使用 heap 的那些数据 最小化 heap 中的重复数据 清理 heap 上未使用的数据 所有权的规则 每个值都有一个变量，这个变量是该值的所有者 每个值同时只能有一个所有者 所有者超出作用域后，这个值会被删除 二.内存与分配 Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域的时候，内存自动还给操作系统 drop 函数 变量和数据交互的方式：Move 多个变量可以与同一个数据使用一种独特的方式来交互12let x = 5;let y = x; 整数是已知大小且固定大小的值，这两个5都被压入 stack 中 变量和数据交互的方式：Move(String) 一个 string 由三部分组成： 指针 长度 容量 123let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;{}, world!&quot;, s1); 将 s1 赋给 s2 时，将数据复制了一份： 在 stack 上复制了一份（指针 长度 容量） 但是没有复制 heap 上的数据 离开作用域后，会调用drop函数，将heap中的内存释放 当 s1、s2 都离开时，它们会尝试去释放相同的内存： 二次释放(double free) 为了保证内存安全： Rust 没有选择复制被分配的内存 Rust 使 s1 失效 所以 s1 离开作用域的时候无需释放任何内存 如果尝试使用 s1 会有以下错误 浅拷贝(shallow copy) 深拷贝(deep copy) 由于 Rust 让 s1 失效，所以使用新的术语：移动(Move) 隐含的一个原则：Rust 不会自动创建数据的深拷贝 就运行性能而言，任何自动赋值的操作都是廉价的 克隆(clone)如果想要 s1，s2 均有效，可以使用 clone方法(深度拷贝) 123let s1 = String::from(&quot;hello&quot;);let s2 = s1.clone();println!(&quot;{}, world!&quot;, s1); stack上：复制123let x = 5;let y = x;println!(&quot;x = {}, y = {}&quot;, x, y); Copy trait 可以用于想整数这样完全存放在 stack 上的类型 如果一个类型实现了 copy 这个 tarit ，那么旧的变量在赋值后仍然可用 如果一个类型或者该类型的一部分实现了 drop trait ，那么Rust不允许它再去实现 copy tarit 拥有 copy trait的类型 任何简单标量的组合类型都可copy 需要分配资源的不可copy 有 copy tarit 的类型 所有整数 bool char float Tuple(如果所有字段可copy) 三.涉及函数的所有权机制 对于变量而言函数的所有权问题显得非常奇怪 函数参数的所有权机制123456789101112131415161718192021222324252627fn main() { let s = String::from(&quot;hello&quot;); // s 被声明有效 takes_ownership(s); // s 的值被当作参数传入函数 // 所以可以当作 s 已经被移动，从这里开始已经无效 let x = 5; // x 被声明有效 makes_copy(x); // x 的值被当作参数传入函数 // 但 x 是基本类型，依然有效 // 在这里依然可以使用 x 却不能使用 s} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放fn takes_ownership(some_string: String) { // 一个 String 参数 some_string 传入，有效 println!(&quot;{}&quot;, some_string);} // 函数结束, 参数 some_string 在这里释放fn makes_copy(some_integer: i32) { // 一个 i32 参数 some_integer 传入，有效 println!(&quot;{}&quot;, some_integer);} // 函数结束, 参数 some_integer 是基本类型, 无需释放 如果将变量作为参数传入函数，那么它和移动的效果是一样的 函数返回值的所有权机制 被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。 123456789101112131415161718192021222324fn main() { let s1 = gives_ownership(); // gives_ownership 移动它的返回值到 s1 let s2 = String::from(&quot;hello&quot;); // s2 被声明有效 let s3 = takes_and_gives_back(s2); // s2 被当作参数移动, s3 获得返回值所有权} // s3 无效被释放, s2 被移动, s1 无效被释放.fn gives_ownership() -&gt; String { let some_string = String::from(&quot;hello&quot;); // some_string 被声明有效 return some_string; // some_string 被当作返回值移动出函数}fn takes_and_gives_back(a_string: String) -&gt; String { // a_string 被声明有效 a_string // a_string 被当作返回值移出函数} 四.引用与租借引用与租借简单解释 引用（Reference）是 C++ 开发者较为熟悉的概念。如果你熟悉指针的概念，你可以把它看作一种指针。实质上”引用”是变量的间接访问方式。 例子： 12345fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; println!(&quot;s1 is {}, s2 is {}&quot;, s1, s2);} 运行结果: s1 is hello, s2 is hello &amp; 运算符可以取变量的”引用”。 当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值： 函数参数传递的道理相同: 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.len()} The length of ‘hello’ is 5. 参数类型是 &amp;String 而不是 String &amp; 符号表示引用：允许你引用某些值而不取得所有权 引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权： 123456fn main() { let s1 = String::from(&quot;hello&quot;); let s2 = &amp;s1; let s3 = s1; // 此时hello已经属于s3，不再属于s1，此时s2无法使用 println!(&quot;{}&quot;, s2);} 这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借： 1234567fn main() { let s1 = String::from(&quot;hello&quot;); let mut s2 = &amp;s1; let s3 = s1; s2 = &amp;s3; // 重新从 s3 租借所有权 println!(&quot;{}&quot;, s2);} 这段程序是正确的。既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。如果尝试利用租借来的权利来修改数据会被阻止： 把引用作为参数的行为成为借用 无法修改借用的东西 123456789fn main() { let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;String) -&gt; usize { s.push_str(&quot;, world!&quot;); // 错误，禁止修改租借的值 s.len()} 和变量一样，引用默认也是不可变的 这段程序中 s2 尝试修改 s1 的值被阻止，租借的所有权不能修改所有者的值。 当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的： 可变引用示例 12345678910111213fn main() { let mut s1 = String::from(&quot;hello&quot;); // s1可变 let len = calculate_length(&amp;mut s1); // 传入函数的是可变的引用 println!(&quot;The length of '{}' is {}.&quot;, s1, len);}fn calculate_length(s: &amp;mut String) -&gt; usize { s.push_str(&quot;, world!&quot;); s.len()} OUTPUT --&gt; The length of 'hello, world!' is 13. 这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。 可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以： 123456let mut s = String::from(&quot;hello&quot;);let r1 = &amp;mut s;let r2 = &amp;mut s;println!(&quot;{}, {}&quot;, r1, r2); 这段程序不正确，因为多重可变引用了 s。 Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。 由于发生数据竞争的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。 以下三种行为会发生数据竞争： 两个或多个指针同时访问同一个数据 至少有一个指针用于写入数据 没有任何机制来同步数据的访问 所以可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用； 可以在编译时防止数据竞争 可以通过创建新的作用域来创建多个可变引用 1234567fn main() { let mut s = String::from(&quot;hello&quot;); { let r1 = &amp;mut s; } // r1 goes out of scope here, so we can make a new reference with no problems let r2 = &amp;mut s;} 另一个限制 不可以同时拥有一个可变引用和一个不可变引用（因为有了一个不可变引用同时有一个可变说明不可变可变） 但是多个不可变引用是可以的 1234567fn main() { let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; // no problem let r2 = &amp;s; // no problem let r3 = &amp;mut s; // BIG PROBLEM println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);} 悬空引用(Dangling Reference) 悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块地址可能已经被释放并分配给其他人使用 在 Rust 里，编译器会保证引用永远不会悬空： 如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域 12345678fn main() { let r = dangle();}fn dangle() -&gt; &amp;String { // dangle returns a reference to a String let s = String::from(&quot;hello&quot;); // s is a new String &amp;s // we return a reference to the String, s} // Here, s goes out of scope, and is dropped. Its memory goes away. Danger! 引用的规则 在任何给定的时刻，只能满足下列条件之一：. - 一个可变的引用 任意数量不可变的引用 引用必须一直有效","link":"/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/"},{"title":"Rust-note-06结构","text":"一.结构 定义 struct 使用 struct 关键字，并命名 在{…}内，为所有字段(Field)定义名称和类型 例如： 123456struct User{ username: String, email: String, sign_in_count: u64, active: bool,} 实例化 stuct 要创建实例 (废话但是废话好有道理啊) 为字段指定值(要全部指定) 无需按顺序 例子 123456let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,}; 取 struct 中的值 使用点运算符： 1234567let user1 = User { username: String::from(&quot;somename&quot;), email: String::from(&quot;someone@what.com&quot;), sign_in_count: 1, active: true,};user1.email = String::from(&quot;what?what?&quot;); 一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的 struct 作为函数返回值 此时这个 user 作为此函数的返回值 12345678fn build_user(email: String, username: String) -&gt; User { User { username: username, email: email, sign_in_count: 1, active: true, }} 元组结构体有一种更简单的定义和使用结构体的方式：元组结构体。 元组结构体是一种形式是元组的结构体。 与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据： 12345struct Color(u8, u8, u8);struct Point(f64, f64);let black = Color(0, 0, 0);let origin = Point(0.0, 0.0); 使用方式和元组一样，可以使用下标来访问： 12345678910fn main() { struct Color(u8, u8, u8); struct Point(f64, f64); let black = Color(0, 0, 0); let origin = Point(0.0, 0.0); println!(&quot;black = ({}, {}, {})&quot;, black.0, black.1, black.2); println!(&quot;origin = ({}, {})&quot;, origin.0, origin.1);} 结构体所有权结构体必须掌握字段值所有权，因为在结构体失效时会释放所有字段。 输出结构体可以加入 #[derive(Debug)]来输出整个结构体 123456789101112#[derive(Debug)]struct Rectangle { width: u32, height: u32,}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1 is {:?}&quot;, rect1); // 使用{:?}占位符来输出整个结构体} rect1 is Rectangle { width: 30, height: 50 } 使用{:?} rect1 is Rectangle { 使用{:#?} width: 30, height: 50} 结构体方法方法和函数是类似的，但是是通过结构体来实现。 Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象可以在 Rust 实现。 结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。 123456789101112131415struct Rectangle { width: u32, height: u32,} impl Rectangle { fn area(&amp;self) -&gt; u32 { self.width * self.height }}fn main() { let rect1 = Rectangle { width: 30, height: 50 }; println!(&quot;rect1's area is {}&quot;, rect1.area());} rect1’s area is 1500 结构体关联函数有些函数不依靠实例，但是使用需要注明是来自哪个impl模块 12345678910111213141516#[derive(Debug)]struct Rectangle { width: u32, height: u32,}impl Rectangle { fn create(width: u32, height: u32) -&gt; Rectangle { Rectangle { width, height } }}fn main() { let rect = Rectangle::create(30, 50); println!(&quot;{:?}&quot;, rect);}","link":"/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/"},{"title":"Docker Desktop","text":"Docker Desktop使用记录安装(Win)我用的是Windows下的Docker Desktop，众所周知，docker 只有 linux 的发行版本，作为 windows 用户想要使用 docker 的功能自然仅能通过加装虚拟机这一条途径。同样，号称支持 windows 系统的 docker desktop 也是基于同样原理 —— 默认使用 windows 自带的 Hyper-V 服务允许 docker。 所以想安装 docker desktop 就要确保您的 windows 系统支持 wsl(适用于 Linux 的 Windows 子系统) 功能。我们可以直接在 cmd 或 powershell 中输入wsl 来检查是否开启了wsl服务。 打开 控制面板-&gt;程序-&gt;启用或关闭Windows功能，假如有 Hyper-V 和 适用于 Linux 的 Windows 子系统这两个选项，那就愉快得开启，假如没有那你就得去安装一下了 Hyper-V 123456789pushd &quot;%~dp0&quot;dir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txtfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:&quot;%SystemRoot%\\servicing\\Packages\\%%i&quot;del hyper-v.txtDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL wsl 在管理员模式下打开 PowerShell 或 Windows 命令提示符，输入 wsl --install 命令，然后重启电脑。 安装 Docker Desktop 如果每次启动都闪退，可能是你开启了SMB 1.0/CIFS 文件共享支持,去windows功能里给它关了就行了 一些设置镜像站设置众所周知在天朝有些地方没法正常访问，所以为了加快拉取镜像的速度，需要设置一些镜像站。 来到这个页面更改里面的配置 以下是我的设置，当然你可以自己去找选择自己喜欢的。 12345678{ &quot;registry-mirrors&quot;: [ &quot;https://dockerproxy.com&quot;, &quot;https://hub-mirror.c.163.com&quot;, &quot;https://mirror.baidubce.com&quot;, &quot;https://ccr.ccs.tencentyun.com&quot; ]} 使用获取镜像 在docker hub寻找需要下载的镜像（在cmd中执行docker search [镜像名]命令也可） 现在也可以直接在上面搜出来","link":"/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/"},{"title":"Linux 性能-00","text":"何为性能指标？性能是什么？大多数人的第一反应大多是速度快，而这正对应着两个指标吞吐和延时。然而这两个指标是从用户体验来看的，这两个指标可以从应用负载的角度来考察。与之相反的就是从系统资源的角度来看，比如资源使用率等。 众所周知，随着负载的增加，消耗的系统资源也会随之上升，而性能问题的本质是系统资源耗尽，无法处理足够的请求。 性能分析，其实就是找出应用或者系统的瓶颈，并设法去避免或者缓解，从而处理更多的请求，一般保研以下步骤： 选择指标评估应用程序和系统的性能； 为应用程序和系统设置性能目标； 进行性能基准测试； 性能分析定位瓶颈； 优化系统和应用程序； 性能监控和告警。 一些性能工具 你可以在这里找到它们","link":"/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/"},{"title":"Linux 性能-01","text":"平均负载（Load Average）是什么意思每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。 12$ uptime02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88 在load average中分别是过去 1 分钟、5 分钟、15 分钟的平均负载。 平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数 所谓可运行的进程，指的是正在使用或者正在等待CPU的进程。而平均负载可以理解为单位时间内有几个活跃的进程(事实上要复杂得多,实际上是活跃进程数的指数衰减平均值数学差的我根本不想去理解)。 那么对一个系统而言，负载高了显然是一件糟糕的事情，假如负载小于CPU的核心个数那意味着还有一些空闲，假如负载高于CPU的核心数目那意味着有些进程没法得到处理that’s bad。 平均负载为多少时合理可以想到，假如负载刚好等于CPU个数既不会有资源的浪费也没有进程无法得到处理。 为了知道CPU的个数可以使用以下命令： 12$ grep 'model name' /proc/cpuinfo | wc -l4 打个比方，平均负载的值越高，表示系统中需要运行的进程越多，系统越繁忙。反之，如果平均负载较低，表示系统相对空闲。为了更好地理解这个概念，我们可以将平均负载与现实生活中的一个例子相类比：超市的排队人数。假设超市有 4 个收银台，如果排队的人数为 4，那么每个收银台都有一个顾客在结账，系统运行得比较顺畅。如果排队的人数超过 4，那么一些顾客需要等待，系统开始变得繁忙。如果排队的人数远远超过 4，那么等待时间会变得很长，系统会变得非常繁忙。 其实在先前的 uptime命令获取到的3个时间段的负载中可以分析出不少信息： 首先，假如三个时间段的数值差距不大，这说明系统负载平稳，没有什么突发的进程。 假如1分钟的数值远小于15分钟的值，这说明在15分钟内有很高的负载，但在最近一分钟开始降低负载。 相反，假如1分钟的数值远大于15分钟的值，那说明最近系统负载正在上升。 这时候我们也会疑惑，当平均负载高于多少时应该做出行动，网上的建议是平均负载超出CPU最大负载的70%的时候应该排查一下问题，因为此时就可能影响服务的正常运行。但更合适的做法是联系起系统的长期负载，进行更深层次的分析后再做出处理。 相关命令1234567891011cpu核数: lscpu、 grep 'model name' /proc/cpuinfo | wc -l显示平均负载：uptime、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势watch -d uptime: -d会高亮显示变化的区域strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--timeout 执行时间mpstat: 多核cpu性能分析工具，-P ALL监视所有cpupidstat: 进程性能分析工具，-u 显示cpu利用率 总结平均负载指的是：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。","link":"/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/"},{"title":"SQL概述","text":"1.SQL概述1.1 SQL背景知识 在1974年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。 SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道 ，由IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ，SQL-92 ，SQL-99 等标准。 不同的数据库生产厂商都支持SQL语句，但都有特有内容。 1.2 SQL分类 DDL（Data Definition Languages 数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。 DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。 DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。 2.1 SQL语法的规则与规范 SQL 可以写为一行或者是多行。为了提高可读性，可将字句分行。 每条命令以；or \\g or \\G 结束。(部分数据库要求) 2.2 SQL大小写规范 MySQL 在 Windows下对大写不敏感。 MySQL 在Linux下对大小写敏感。 数据库名、表名、表的别名、变量名严格区分大小写。 关键字、函数名、字段名、字段别名是忽略大小写的。 推荐的书写规范： 数据库名、表名、表别名、字段名、字段别名使用小写。 SQL关键字、函数名、绑定变量使用大写。 2.3 命名规则 数据库、表名不得超过30个字符，变量名限制为29个。 只能包含 A–Z, a–z, 0–9, _共63个字符。 数据库名、表名、字段名等对象名中间不要包含空格。 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来。 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了。 例： 1234567#以下两句是一样的，不区分大小写show databases;SHOW DATABASES;#创建表格#create table student info(...); #表名错误，因为表名有空格create table student_info(...);","link":"/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/"},{"title":"SQL常用命令","text":"1. SQL常用命令SQL 不区分大小写，SELECT与select是相同的。 某些数据库系统要求在每条 SQL 语句的末端使用分号。使用分号作为结束可以在一个请求中对服务器进行一条以上的语句。 比较重要的命令 SELECT - 从数据库中提取数据 UPDATE - 更新数据库中的数据 DELETE - 从数据库中删除数据 INSERT INTO - 向数据库中插入新数据 CREATE DATABASE - 创建新数据库 ALTER DATABASE - 修改数据库 CREATE TABLE - 创建新表 ALTER TABLE - 变更（改变）数据库表 DROP TABLE - 删除表 CREATE INDEX - 创建索引（搜索键） DROP INDEX - 删除索引 SELECT 语句 SELECT 语句用于从数据库中选取数据。 12SELECT column_name,column_nameFROM table_name; 或者 1SELECT * FROM table_name; 演示 1SELECT * FORM users; 此语句从 users 表中选取所有列 1SELECT name,age FROM users; 此语句从 users 表中选取age和name两列 WHERE 语句 WHERE 子句用于提取那些满足指定条件的记录。 123SELECT column_name,column_nameFROM table_nameWHERE column_name operator value; 演示 1SELECT * FROM users WHERE name='u1'; 此语句从 user表中选取name列都是”u1”的记录 WHERE 字句中的运算符 运算符 描述 = 等于 &lt;&gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 AND &amp; OR 运算符 AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。 演示 1234567891011SELECT * FROM WebsitesWHERE country='CN'AND alexa &gt; 50;SELECT * FROM WebsitesWHERE country='USA'OR country='CN';SELECT * FROM WebsitesWHERE alexa &gt; 15AND (country='CN' OR country='USA'); INSERT INTO 语句 INSERT INTO 语句可以有两种编写形式。 第一种形式无需指定要插入数据的列名，只需提供被插入的值即可： 12INSERT INTO *table_name*VALUES (*value1*,*value2*,*value3*,...); 第二种形式需要指定列名及被插入的值： 12INSERT INTO *table_name* (*column1*,*column2*,*column3*,...)VALUES (*value1*,*value2*,*value3*,...); 演示 1INSERT INTO users (name,age) VALUES ('u3',10); UPDATE 语句 显而易见是用来更新表中已有的记录。 123UPDATE table_nameSET column1=value1,column2=value2,...WHERE some_column=some_value; 演示 1UPDATE users SET age=18 WHERE name='u3'; 警告 如果省略了 WHERE 字句 会将所有 age 改为18 1UPDATE users SET age=18; DELETE 语句 用于删除表中的一行记录。 12DELETE FROM table_nameWHERE some_column=some_value; 演示 1DELETE FROM users WHERE age = 18; 删除了 age = 18 的一条记录 警告 和 UPDATE 同理，漏掉 WHERE 会删除表中所有记录","link":"/2022/11/23/02-SQL/03SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"MATLAB function初步","text":"MATLAB 中的函数在MATLAB中也有函数的概念，（没有的话不就是个垃圾平台了X，对吧） 函数文件与函数调用 M文件根据调用方式的不同可以分为两类 Script：脚本/命令文件 可以直接输入文件名运行 Function： 函数文件，由function引导，通常带输入和输出参数 函数文件12345678function [paras...]=func_name() end% 第一行是引导行，说明这个文件是个函数文件。% 函数名必须以字母开头% 输出参数大于一个时，用[]包裹% 函数文件名必须与函数名一致！ 支持递归 Matlab会传递两个永久变量nargin(number of arguments in)和 nargout记录输入和输出实参个数。 这个还是相当有用的。 函数文件中的多个函数在名为 stat2.m 的文件中定义两个函数，其中第一个函数调用第二个函数。 123456789function [m,s] = stat2(x) n = length(x); m = avg(x,n); s = sqrt(sum((x-m).^2/n));end function m = avg(x,n) m = sum(x)/n;end 我的理解是，一个函数文件可以写多个函数，而与文件名相同的那个函数则是对外暴露的函数，这样对数据操作的安全性也有所保障。 全局与局部变量在MATLAB中，变量可以被定义为全局变量或局部变量，具体含义如下： 局部变量：局部变量指的是在函数内部定义的变量，只在函数内部可见。局部变量的作用域仅限于函数内部，函数外部无法访问这些变量。 全局变量：全局变量指的是在函数外部定义的变量，可以被整个MATLAB程序中的任何函数访问。全局变量的作用域超出了函数内部，因此需要谨慎使用全局变量。 在函数中，可以通过以下方式定义和使用局部变量： 123456function result = myFunction(input) % 定义局部变量 localVariable = 0; % 使用局部变量进行计算 result = input + localVariable;end 在这个示例函数中，变量localVariable是一个局部变量，仅在myFunction函数内部可见。变量input是函数的输入参数，也是一个局部变量。 如果需要在函数中使用全局变量，可以使用global关键字进行声明。例如： 123456function result = myFunction(input) % 声明全局变量 global globalVariable; % 使用全局变量进行计算 result = input + globalVariable;end 在这个示例函数中，变量globalVariable是一个全局变量，使用global关键字进行声明。在函数内部，可以像使用局部变量一样使用全局变量。 需要注意的是，全局变量的使用会增加程序的复杂度和可维护性，因此应该尽量避免滥用全局变量。 我的理解是将一些数据定义为全局变量可以方便用户计算时候更简单的使用一些常量，而不用在函数列表中传入过多无意义的参数。 个人更倾向于把全局变量作为常量，因为对其的修改可能会导致一些意外的影响。（如有错误请指正X） 应用示例12345678910111213141516171819global numCalls; % 声明全局变量% 初始化全局变量numCalls = 0;% 定义一个函数，用于计算两个数的和function result = addNumbers(a, b) global numCalls; % 声明全局变量 numCalls = numCalls + 1; result = a + b;end% 调用函数，并多次计算两个数的和addNumbers(1, 2);addNumbers(3, 4);addNumbers(5, 6);% 输出全局变量的值，即函数被调用的次数disp(numCalls); output: 3","link":"/2023/04/13/12-Matlab/function/"},{"title":"MATLAB Debug","text":"Matlab 的 Debug作为一个数据处理平台，假如没有调试这个基本的功能是多么可怕X，当然Matlab为我们提供了调试的功能。 本文大概分为三个段落 代码内调试 断点调试方法 指令调试 代码内调试","link":"/2023/04/13/12-Matlab/debug/"},{"title":"MATLAB Data&amp;IO初步","text":"MATLAB 中数据操作 数据IO 文件IO Excel IO 数据的IO键盘接受数据1234x = input('message for user');x1 = input('message for user','s'); % 第二个参数是说明强制将输入解释为字符串% 这个参数还能是以下值% double single int8 int16 int32 int64 数据的显示在MATLAB中，disp()函数是一种常用的输出函数，用于在命令窗口中显示一个或多个值、表达式或者字符串。它的语法如下： 1disp(expression); 其中，expression是一个MATLAB表达式，可以是一个数值、矩阵、字符向量、单元数组、结构体等。 示例： 1234567891011121314151617181920% 显示一个字符串disp('Hello, world!');% 显示一个数值x = 3.14;disp(x);% 显示一个矩阵A = [1 2 3; 4 5 6; 7 8 9];disp(A);% 显示一个单元数组str = {'apple', 'banana', 'cherry'};disp(str);% 显示一个结构体s.name = 'John';s.age = 25;s.gender = 'Male';disp(s); 输出如下： 1234567891011 Hello, world! 3.1400 1 2 3 4 5 6 7 8 9 'apple' 'banana' 'cherry'struct with fields: name: 'John' age: 25 gender: 'Male' 需要注意的是，disp()函数在输出一个值或者表达式时，会自动添加一些格式化和分隔符，如空格、制表符等。如果需要对输出的格式进行更精确的控制，可以使用其他的输出函数，如fprintf()、sprintf()等。 格式化IO在MATLAB中，sprintf()函数是一种常用的输出函数，用于将格式化的数据转换成字符串。它的语法如下： 1str = sprintf(format, arg1, arg2, ...) 和常见格式化输出没啥区别，毕竟语言是互通的 例子： 123x = 3.1415926;str = sprintf('pi = %.2f', x);disp(str); 在上述代码中，sprintf()函数将数值x转换成一个带有两位小数的字符串，并将其赋值给变量str。然后，disp()函数将输出这个字符串，结果为： 1pi = 3.14 需要注意的是，sprintf()函数中的格式化字符串可以包含占位符和修饰符，用于控制输出的格式。常用的占位符包括%d（整数）、%f（浮点数）、%s（字符串）等，常用的修饰符包括精度控制符、宽度控制符、对齐控制符等。例如： 1234567891011121314str = sprintf('The answer is %d.', 42);disp(str); % 输出 &quot;The answer is 42.&quot;str = sprintf('x = %f', 3.1415926);disp(str); % 输出 &quot;x = 3.141593&quot;str = sprintf('%.2f', 3.1415926);disp(str); % 输出 &quot;3.14&quot;str = sprintf('%10s', 'Hello');disp(str); % 输出 &quot; Hello&quot;str = sprintf('%-10s', 'Hello');disp(str); % 输出 &quot;Hello &quot; 具体还是得去看文档，文档才是最好的教程~~~ 文件操作save在 MATLAB 中，save() 函数用于将变量保存到文件中，以便在以后的 MATLAB 会话中使用。它的基本语法如下： 123save(filename)save(filename, variables)save(filename, variables, '-option') 其中，filename 是字符串类型的参数，指定要保存的文件名及其路径；variables 是一个变量名列表，指定要保存的变量。第三个可选参数 -option 可以用来指定保存选项，如格式、版本等。 示例： 1234567891011% 保存单个变量到文件中x = rand(5);save('data.mat', 'x');% 保存多个变量到文件中y = 1:10;z = 'hello';save('data.mat', 'x', 'y', 'z');% 保存指定格式的文件save('data.txt', 'x', '-ascii'); open 函数 load在 MATLAB 中，load() 函数用于从文件中加载变量到 MATLAB 工作空间中。它的基本语法如下： 12load filenameload(filename, variables) 其中filename是文件的路径，variables是变量名列表，指定要从文件中加载的变量。 需要注意的是，使用 load() 函数加载 MAT 文件时，MATLAB 会将文件中的所有变量全部加载到内存中，这可能会导致内存溢出的问题。为了避免这种情况，可以使用 load() 函数的 -mat 选项，它只会加载指定的变量。此外，还可以使用其他选项，如 -ascii、-double、-float 等，用来加载文本文件或者二进制文件。看看文档喽 load 函数 fopen在 MATLAB 中，fopen() 函数用于打开文件，并返回一个文件标识符（file identifier），用于后续文件操作。它的基本语法如下： 1fid = fopen(filename, mode) 其中，filename 是要打开的文件名，可以包括文件路径；mode 是打开文件的模式，如读取模式 ‘r’、写入模式 ‘w’、追加模式 ‘a’ 等。打开文件后，fopen() 函数会返回一个文件标识符 fid，它可以用于后续文件操作。 下面是一些示例： 1234567891011% 打开文本文件以读取数据fid = fopen('data.txt', 'r');% 打开文本文件以写入数据fid = fopen('output.txt', 'w');% 打开二进制文件以读取数据fid = fopen('data.bin', 'rb');% 打开二进制文件以写入数据fid = fopen('output.bin', 'wb'); 在上述示例中，第一个示例中打开了一个文本文件 data.txt，并指定打开模式为 ‘r’，表示以只读模式打开文件。第二个示例中打开了一个文本文件 output.txt，并指定打开模式为 ‘w’，表示以写入模式打开文件。第三个示例中打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。第四个示例中打开了一个二进制文件 output.bin，并指定打开模式为 ‘wb’，表示以二进制写入模式打开文件。 需要注意的是，在打开文件时，需要指定正确的文件名和路径，并根据文件类型和需要的操作，选择合适的打开模式。如果打开文件失败，fopen() 函数会返回 -1，表示打开失败。 fopen 函数 fclose在 MATLAB 中，fclose() 函数用于关闭之前打开的文件，释放文件资源并关闭文件连接。它的基本语法如下： 1fclose(fid) 其中，fid 是之前打开文件所得到的文件标识符。关闭文件后，该文件标识符将不再可用。 下面是一个示例： 123456789% 打开文件fid = fopen('data.txt', 'r');% 读取数据data = fscanf(fid, '%f');% 关闭文件fclose(fid);% fclose 其实会返回一个状态，-1代表fall，0代表success 在上述示例中，fopen() 函数打开文件 data.txt，并指定打开模式为 'r'。接下来，使用 fscanf() 函数从文件中读取数据，并存储到变量 data 中。最后，使用 fclose() 函数关闭文件。 需要注意的是，在读取或写入文件完成后，必须使用 fclose() 函数关闭文件，否则会导致文件资源泄漏，影响系统性能。 fclose 函数 fread在 MATLAB 中，fread() 函数用于从打开的文件中读取二进制数据。它的基本语法如下： 12A = fread(fid, size, precision, skip, machinefmt)A = fread(fid, [M, N], precision, skip, machinefmt) 其中，各参数的含义如下： fid：文件标识符，之前使用 fopen() 函数打开文件时返回的值。 size：要读取的数据大小，可以是一个数字，表示读取 size 个字节的数据，也可以是一个向量，表示读取一个 size 元素的向量。在读取数据之前，必须知道数据大小。 precision：数据类型，即数据的编码格式。 skip：跳过的字节数，用于指定要从文件中跳过多少字节后开始读取数据。如果不指定，则默认从文件的开头读取数据。 machinefmt：机器格式，即字节顺序。可以是以下类型之一： ‘n’：本机格式（默认） ‘l’：小端格式 ‘b’：大端格式 [M, N]：矩阵的行数和列数，用于指定要读取的数据是一个 M 行 N 列的矩阵。 下面是一个示例： 12345678% 打开二进制文件fid = fopen('data.bin', 'rb');% 读取 5 个双精度浮点数A = fread(fid, 5, 'double');% 关闭文件fclose(fid); 在上述示例中，fopen() 函数打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。接下来，使用 fread() 函数从文件中读取 5 个双精度浮点数，并存储到变量 A 中。最后，使用 fclose() 函数关闭文件。 Excel文件IO读取在 MATLAB 中，可以使用 xlsread() 函数读取 Excel 文件中的数据。它的基本语法如下： 1[num, txt, raw] = xlsread(filename, sheet, range) 其中，filename 是 Excel 文件名，可以包括文件路径；sheet 是要读取的工作表名或索引；range是要读取的单元格范围。num 是一个数值矩阵，包含了读取的数值数据；txt 是一个文本矩阵，包含了读取的文本数据；raw 是一个单元格数组，包含了所有读取的数据，包括数值和文本。如果 Excel 文件中没有文本数据，则 txt 返回一个空矩阵。 下面是一个示例： 12% 读取 Excel 文件[num, txt, raw] = xlsread('data.xlsx', 'Sheet1', 'A1:C3'); 在上述示例中，xlsread() 函数读取了 Excel 文件 data.xlsx 中第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’，并将数值、文本和原始数据分别存储到 num、txt 和 raw 中。 需要注意的是，xlsread() 函数只能读取 Excel 文件中的数值和文本数据，不能读取图表、公式等其他类型的数据。此外，如果要读取的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的读取函数，如 csvread() 函数、textscan() 函数等。 写入在 MATLAB 中，可以使用 xlswrite() 函数将数据写入 Excel 文件。它的基本语法如下： 1xlswrite(filename, data, sheet, range) 其中，filename 是 Excel 文件名，可以包括文件路径；data 是要写入 Excel 文件的数据，可以是数值、文本或逻辑值；sheet 是要写入的工作表名或索引；range 是要写入的单元格范围。如果省略 sheet 参数，则默认写入第一个工作表；如果省略 range 参数，则默认写入整个工作表。 下面是一个示例： 123% 写入 Excel 文件data = [1 2 3; 4 5 6; 7 8 9];xlswrite('data.xlsx', data, 'Sheet1', 'A1:C3'); 在上述示例中，xlswrite() 函数将一个 3x3 的矩阵数据写入 Excel 文件 data.xlsx 的第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’。 需要注意的是，xlswrite() 函数只能写入数值、文本和逻辑值数据，不能写入图表、公式等其他类型的数据。此外，如果要写入的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的写入函数，如 csvwrite() 函数、fprintf() 函数等。","link":"/2023/04/13/12-Matlab/file/"},{"title":"MATLAB 绘图","text":"MATLAB 绘图这篇博文就来浅浅得说说MATLAB中的图像绘制，众所周知数据可视化是科学计算以及数据统计计算非常重要的部分，谁都不喜欢对着一大堆数字分析，看到一幅干干净净的图总能令人赏心悦目(但是作为使用者，真的不太喜欢，问就是懒) 这篇文章会提到以下内容： 图形窗口控制 二维图像绘制 三维图像绘制 三维曲线图(curve plot) 三维曲面/网格图( surface/grid plot) 图像窗口绘制创建图形窗口：figurefigure是MATLAB中中用来创建新的图形窗口的函数。每个图形窗口可以包含一个或多个图形对象（如曲线、散点图、直方图等）以及与其相关的文本、标签等。 语法如下： 123figurefigure(h) % h为窗口号figure('PropertyName', PropertyValue, ...) 清除图形界面：clfclf 是 “clear current figure” 的缩写，用于清除当前图形窗口中的内容，使得该窗口可以绘制新的图形。 关闭图形窗口： close在MATLAB中，close函数用于关闭一个图形窗口，释放与之相关联的内存和系统资源。 语法如下： 1234close allclose figure_handleclose('all')close('figure', figure_handle) close: 关闭当前活动的图形窗口。 close all: 关闭所有的图形窗口。 close figure_handle: 关闭指定图形句柄对应的图形窗口。 close('all'): 关闭所有的图形窗口。 close('figure', figure_handle): 关闭指定图形句柄对应的图形窗口。 其中，figure_handle 是一个整数或整数向量，表示图形句柄或多个图形句柄。如果要关闭多个图形窗口，可以使用整数向量指定多个图形句柄，例如 close([1, 2, 3])。 保持图形窗口：hold在 MATLAB 绘图中，hold 函数用于控制图形窗口是否保持当前绘图而不清空。当使用 hold on 后，新的绘图会添加到当前的图形中，而不会清空前面的绘图。当使用 hold off 后，新的绘图会覆盖之前的绘图。可以使用 hold 语句来打开或关闭保持模式。 语法如下： 1hold on/off 演示： 1234567x = linspace(-pi, pi, 100);y1 = sin(x);y2 = cos(x);plot(x, y1);hold on;plot(x, y2);hold off; 在这个例子中，先使用 plot 函数绘制了 y1 的曲线，然后开启保持模式，并用 plot 函数绘制 y2 的曲线，最后关闭保持模式，这样 y1 和 y2 的曲线就会在同一个图形窗口中显示出来。 二维图形绘制绘制二维图形命令： plotplot 是 MATLAB 中用于绘制二维图形的函数，它可以绘制折线图、散点图等多种类型的图形。 语法如下： 12345plot(Y) % 绘制 Y 的线图plot(X, Y) % 绘制 X, Y 的线图plot(X1, Y1, ..., Xn, Yn) % 绘制多个数据的线图plot(___, LineSpec) % 绘制指定类型的线图plot(___, Name, Value) % 使用属性值对自定义绘图 plot函数的常用参数 x：表示要绘制的数据点的 x 坐标，可以是向量或矩阵。 y：表示要绘制的数据点的 y 坐标，可以是向量或矩阵。 ‘LineStyle’：表示线的样式，常用的有‘-’（实线），‘–’（虚线），‘:’（点线）等。 ‘LineWidth’：表示线的宽度，可以是任何正数值。 ‘Marker’：表示数据点的标记，常用的有‘o’（圆圈），‘x’（叉号），‘+’（加号），‘*’（星号）等。 ‘MarkerSize’：表示数据点的大小，可以是任何正数值。 ‘Color’：表示线的颜色，可以是预定义颜色名称（如’red’，’blue’等）或RGB三元组（如[0.5 0.5 0.5]表示灰色）。 ‘DisplayName’：表示线的显示名称，在legend函数中使用。 除了上述常用参数，plot函数还有其他参数，如’MarkerEdgeColor’（数据点的边框色），’MarkerFaceColor’（数据点的填充颜色），’MarkerIndices’（指定要绘制的数据点的索引），’LineStyleOrder’（指定多条线的样式序列），’MarkerOrder’（指定多个数据点标记的序列），’ColorOrder’（指定多条线的颜色序列）等。 例子： 123x = [1, 2, 3, 4];y = [2, 4, 6, 8];plot(x, y); 这段代码将绘制一个简单的折线图，x 轴的值为 1、2、3 和 4，y 轴的值为 2、4、6 和 8。 **plot 函数还支持传递额外的参数来控制绘图样式，例如：** 123x = linspace(0, 2*pi, 100);y = sin(x);plot(x, y, 'r--', 'LineWidth', 2); 这段代码将绘制一个正弦曲线，线条颜色为红色，线条样式为虚线，线条宽度为 2。除了颜色、样式和宽度，plot 函数还支持传递其他参数，例如设置坐标轴标签、标题等。 例子： 12345678910111213141516171819202122232425x = linspace(0, 2*pi, 100);y1 = sin(x);y2 = cos(x);% 画出两条曲线plot(x, y1, 'r', x, y2, 'b--');% 添加标题title('Sin and Cos Waves');% 添加x轴和y轴标签xlabel('x');ylabel('y');% 设置x轴和y轴的范围xlim([0, 2*pi]);ylim([-1.5, 1.5]);% 设置x轴和y轴的刻度xticks([0, pi/2, pi, 3*pi/2, 2*pi]);xticklabels({'0', '\\pi/2', '\\pi', '3\\pi/2', '2\\pi'});yticks([-1, 0, 1]);% 添加网格线grid on; 绘制二维图形的子图： subplotsubplot 是一个用于将 MATLAB 图形窗口划分为小块的函数，以便在同一个窗口中显示多幅图像。 语法如下： 1subplot(m, n, p) 其中，m 和 n 是将窗口划分成 m 行和 n 列，p 指当前要绘制的子图在整个窗口中的位置。 如果将窗口分成 m 行和 n 列，则总共会有 m*n 个小块，它们从左到右、从上到下编号，编号方式如下所示： 12341 2 3 ... nn+1 n+2 ... 2*n...(m-1)*n+1 ... m*n 例子： 1234567891011121314x = 0:0.1:10;y1 = sin(x);y2 = cos(x.^2);figuresubplot(2,1,1) % 2行1列，当前绘制第1幅图plot(x,y1)hold onscatter(x,y1,'filled')subplot(2,1,2) % 2行1列，当前绘制第2幅图plot(x,y2)hold onscatter(x,y2,'filled') 关于二维图形一些杂项设置X 一张让人一目了然，赏心悦目的图能给人带来舒适感，这时候就需要给图加上各种各种各样的标注来美化以及显得自己很专业bushi xlabel ylabel zlabel用于给坐标轴轴添加标签。 语法： 123xlabel('text')% that's easyxlabel('Time (s)', 'FontName', 'Times New Roman', 'FontSize', 12, 'Color', 'r'); xlabel(‘text’)：添加文本标签； xlabel(‘text’, ‘Name’, Value, …)：添加文本标签并设置属性值，如颜色、字体、字号等，常用属性值如下： ‘FontAngle’：字体倾斜度，可选值为’normal’(默认),’italic’或’oblique’； ‘FontName’：字体名称，可选值为’Helvetica’(默认),’Arial’,’FixedWidth’,’等宽字体’,’Times’等； ‘FontSize’：字体大小，可选值为任意正整数； ‘FontWeight’：字体粗细，可选值为’normal’(默认),’bold’,’light’,’demi’或任意正整数； ‘Color’：文本颜色，可选值为RGB三元组或MATLAB预设的颜色名称。 文字注释（Text）用于在图形中添加文字注释。 语法： 123text(x, y, str)text(x, y, z, str)% 其中，x、y、z 分别为要添加文字的位置，可以是一个标量、向量或矩阵，分别表示 x、y、z 坐标轴上的位置。str 是要添加的文字内容。 例子： 12345678x = -pi:0.1:pi;y = sin(x);plot(x, y)xlabel('x')ylabel('sin(x)')title('A Simple Sin Curve')text(0, 0, 'Origin') % 在坐标轴中心添加文字注释 坐标轴（Axis）axis 函数是用于设置坐标轴范围的 MATLAB 函数。它可以用来调整 x 和 y 轴的上下限。 语法： 1axis([xmin xmax ymin ymax zmin zmax]) 其中zmin 和 zmax 分别是 z 轴的最小值和最大值。如果只需要设置 x 和 y 轴的范围，可以将 zmin 和 zmax 设置为 auto 或者忽略它们。 除了可以传入数值来设置坐标轴范围外，还可以使用 axis equal 和 axis tight 来设置坐标轴范围。axis equal 会将 x 和 y 轴的范围设置成相等的，并且保证图形在显示时宽高比例相等。axis tight 会将坐标轴范围设置为图形数据的最小包围盒。 例如，下面的代码可以绘制出一个正弦曲线，并且设置 x 轴范围为 0 到 2π，y 轴范围为 -1 到 1： 1234x = linspace(0, 2*pi, 100);y = sin(x);plot(x, y);axis([0, 2*pi, -1, 1]); 注释（Annotation）：用 annotation 函数可以在画布上添加文本、箭头、线段等注释元素。 语法： 1annotation('Type', 'text', 'String', 'text_string', 'Property', 'Value', ...) 图例（Legend）：用 legend 函数可以在图像上添加图例，显示出各个线条或者曲面的含义。 语法： 1legend('label1', 'label2', ...) 例子： 123legend('y1=sin(x)', 'y2=cos(x)', 'y3=tan(x)', 'Location', 'northwest', 'FontSize', 12)% 其中 'Location', 'northwest' 选项表示将标注放在左上角。还可以使用 'FontSize' 选项指定标注的字体大小。% 这语法真的晕了，太灵活反而反人类了 标题（Title）用 title 函数可以在图像上添加标题。 语法： 1title('Title text', 'Property', 'Value', ...) 网格线（Grid Lines）用 grid 函数可以在坐标系上添加网格线。 语法： 1grid on 刻度（Ticks）用 xticks 和 yticks 函数可以设置坐标轴上的刻度。 语法： 12xticks([x1 x2 ...])yticks([y1 y2 ...]) 坐标框（Box）用 box 函数可以在坐标系周围添加一个矩形边框。 语法： 1box on 设置 （set）set 函数用于设置图形对象（例如图形窗口、坐标轴、线条、文本等）的属性，包括颜色、线型、线宽、字体大小等等。它的语法为： 1set(handle, 'PropertyName', propertyvalue, ...) 其中 handle 为需要设置属性的对象句柄，PropertyName 和 propertyvalue 分别为属性名和属性值，可以设置多个属性。例如： 12h = plot(x, y);set(h, 'LineWidth', 2, 'Color', 'r'); 上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用 set 函数设置该曲线的线宽为 2，颜色为红色。 除了设置单个对象的属性，也可以用 set 函数一次性设置多个对象的相同属性。例如： 123h1 = plot(x1, y1);h2 = plot(x2, y2);set([h1, h2], 'LineStyle', '--', 'LineWidth', 2); 上述代码创建了两条曲线并将其句柄存储在变量 h1 和 h2 中，然后使用 set 函数设置这两条曲线的线型为虚线，线宽为 2。 此外，还可以使用结构体的方式传递属性值。例如： 1234h = plot(x, y);myprop.LineWidth = 2;myprop.Color = 'r';set(h, myprop); 上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用结构体 myprop 设置该曲线的线宽为 2，颜色为红色。 三维图形绘制三维图形绘制命令 ： plot3plot3是MATLAB中用于绘制三维曲线图的函数。它的语法如下： 123plot3(X, Y, Z);plot3(X, Y, Z, LineSpec);plot3(..., Name, Value); 其中，X、Y和Z是表示数据点坐标的向量或矩阵，LineSpec是可选的参数，用于指定线条的样式和颜色，Name -Value是可选的名称-值对参数，用于指定其他属性。 plot3函数将三维数据点绘制在三维坐标系中，每个点的位置由其在X、Y和Z向量或矩阵中的坐标决定。如果X、Y和Z都是向量，则绘制一条折线，如果它们都是矩阵，则绘制多条折线。 LineSpec参数是一个字符串，用于指定线条的样式和颜色，例如’r–’表示红色虚线。可以使用多个属性，用逗号分隔，例如’ro–’表示红色圆形点和虚线。 Name-Value参数是一组可选的名称-值对，用于指定其他属性，例如线条宽度、标记大小等。常见的属性名称包括： LineWidth：线条宽度 Marker：标记类型 MarkerEdgeColor：标记边框颜色 MarkerFaceColor：标记填充颜色 MarkerSize：标记大小 Color：线条颜色 例如，plot3(X, Y, Z, 'LineWidth', 2, 'Marker', 'o', 'MarkerSize', 10)将绘制线条宽度为2、标记类型为圆形、标记大小为10的三维曲线图。 例子： 123456789101112131415161718192021222324% 生成数据t = linspace(0, 4*pi, 100);x = sin(t);y = cos(t);z = t;% 绘制图像plot3(x, y, z);% 添加坐标轴标签xlabel('x');ylabel('y');zlabel('z');% 添加标题title('三维线条图');% 添加网格线grid on;% 调整坐标轴范围xlim([-1.5, 1.5]);ylim([-1.5, 1.5]);zlim([0, 13]); 三维曲面/网线网线（not wire line）： meshmesh函数是MATLAB中用于绘制三维曲面图的函数。该函数将一个矩阵作为参数，并绘制该矩阵的3D图像。在绘制3D曲面时，可以使用mesh函数创建网格。例如，可以使用mesh函数来绘制z = sin(x) * cos(y)的曲面： 123[x, y] = meshgrid(-2*pi:0.1:2*pi);z = sin(x).*cos(y);mesh(x, y, z); 这段代码首先使用meshgrid函数创建一个坐标网格。然后使用这个网格和一个由sin和cos计算出的z矩阵来调用mesh函数绘制3D曲面。 mesh函数可以使用的参数很多，包括以下几个常用的参数： x,y,z：表示曲面上的点坐标矩阵，其中x和y用于生成网格，z用于计算曲面高度。c：表示曲面颜色或高度值的矩阵。 ‘EdgeColor’：表示曲面边缘颜色。 ‘FaceColor’：表示曲面颜色。 ‘FaceAlpha’：表示曲面透明度。 以下是一个绘制网格线的示例： 123456789101112% 定义函数[X,Y] = meshgrid(-2:0.2:2);Z = X.*exp(-X.^2 - Y.^2);% 绘制网格图mesh(X,Y,Z);% 添加坐标轴标签和标题xlabel('X');ylabel('Y');zlabel('Z');title('3D Mesh Plot Example'); 曲面： surfsurf函数用于绘制三维曲面图，它可以根据给定的数据绘制三维曲面。 语法： 12345surf(Z)surf(X,Y,Z)surf(...,C)surf(...,'PropertyName',PropertyValue,...)h = surf(...) 其中，Z 是矩阵，表示要绘制的数据，X 和 Y 分别是与 Z 大小相同的矩阵，表示 Z 中数据点的 x 和 y 坐标。C 是与 Z 大小相同的矩阵，表示要绘制的曲面颜色。 PropertyName 和 PropertyValue 是一些可选属性和值对，用于控制曲面的绘制方式，例如： ‘EdgeColor’：曲面边缘颜色； ‘FaceColor’：曲面颜色； ‘FaceAlpha’：曲面的透明度； ‘LineStyle’：曲面线条样式； ‘LineWidth’：曲面线条宽度； ‘Marker’：曲面标记类型。 h 是曲面对象的句柄。 例如，以下代码绘制了一个简单的三维曲面图： 123456789[x,y] = meshgrid(-2:0.2:2,-2:0.2:2);% 生成了两个矩阵x和y,x 矩阵中的元素由 -2 到 2，每隔 0.2 个单位，增加一列，y 矩阵同理。% 在三维绘图中，x 矩阵和 y 矩阵可以作为横纵坐标轴的坐标值，从而形成一个平面。z = x.*exp(-x.^2-y.^2);surf(x,y,z);xlabel('X');ylabel('Y');zlabel('Z');title('3D Surface'); 区别 mesh 函数绘制的是曲面的线框图，即只有网格线的外形，不包含填充面，也就是所谓的“线框图”或“骨架图”。 surf 函数则绘制了带有填充面的曲面，也就是可以看到立体的表面图。","link":"/2023/04/13/12-Matlab/draw/"}],"tags":[{"name":"网盘挂载","slug":"网盘挂载","link":"/tags/%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/"},{"name":"随记","slug":"随记","link":"/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"鉴权","slug":"鉴权","link":"/tags/%E9%89%B4%E6%9D%83/"},{"name":"game","slug":"game","link":"/tags/game/"},{"name":"go","slug":"go","link":"/tags/go/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Container","slug":"Container","link":"/tags/Container/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"性能调优","slug":"性能调优","link":"/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"自动部署","slug":"自动部署","link":"/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"MATLAB","slug":"MATLAB","link":"/tags/MATLAB/"}],"categories":[{"name":"电影","slug":"电影","link":"/categories/%E7%94%B5%E5%BD%B1/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"Life","slug":"Life","link":"/categories/Life/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"鉴权","slug":"鉴权","link":"/categories/%E9%89%B4%E6%9D%83/"},{"name":"go","slug":"go","link":"/categories/go/"},{"name":"Container","slug":"Container","link":"/categories/Container/"},{"name":"Docker","slug":"Container/Docker","link":"/categories/Container/Docker/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"性能调优","slug":"Linux/性能调优","link":"/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"},{"name":"Github","slug":"Github","link":"/categories/Github/"},{"name":"Github Action","slug":"Github/Github-Action","link":"/categories/Github/Github-Action/"},{"name":"MATLAB","slug":"MATLAB","link":"/categories/MATLAB/"},{"name":"Debug","slug":"MATLAB/Debug","link":"/categories/MATLAB/Debug/"},{"name":"File","slug":"MATLAB/File","link":"/categories/MATLAB/File/"},{"name":"Function","slug":"MATLAB/Function","link":"/categories/MATLAB/Function/"},{"name":"Draw","slug":"MATLAB/Draw","link":"/categories/MATLAB/Draw/"}],"pages":[{"title":"","text":"Helo！我是Golden Sheep(Github上是Gloden？对不起！其实是我打错了，更搞笑的是域名当时也记错了所以才有了这么一个乌龙，但是毕竟舍不得买域名的钱，那就将错就错吧 Gloden—&gt;辉光&lt;感觉也挺好听的嘛&gt; )！大学牲一只🎓~ 热爱料理与手冲咖啡，还会一丢丢烘焙，不过水平低下 喜欢旅行、影视 我的豆瓣 书影音已达750部 、钢笔收藏、单晶制作（退坑辣已经）、骑行、沙盒游戏单机3A 、番剧op、古典音乐~ 除了技术帖子还会带上一些私货 like music or movies~ 🐬","link":"/about/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/links/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"","text":"加载中，稍等几秒...","link":"/M2B/index.html"}]}