<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金羊的部落阁</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-13T03:03:43.525Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Golden Sheep</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Matlab Debug</title>
    <link href="http://example.com/2023/04/13/12-Matlab/debug/"/>
    <id>http://example.com/2023/04/13/12-Matlab/debug/</id>
    <published>2023-04-13T02:55:54.000Z</published>
    <updated>2023-04-13T03:03:43.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab-的-Debug"><a href="#Matlab-的-Debug" class="headerlink" title=" Matlab 的 Debug"></a><span id="more"></span> Matlab 的 Debug</h1><p>作为一个数据处理平台，假如没有调试这个基本的功能是多么可怕X，当然Matlab为我们提供了调试的功能。</p><p>本文大概分为三个段落</p><blockquote><ol><li>代码内调试</li><li>断点调试方法</li><li>指令调试</li></ol></blockquote><h2 id="代码内调试"><a href="#代码内调试" class="headerlink" title="代码内调试"></a>代码内调试</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Matlab-的-Debug&quot;&gt;&lt;a href=&quot;#Matlab-的-Debug&quot; class=&quot;headerlink&quot; title=&quot; Matlab 的 Debug&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Matlab" scheme="http://example.com/categories/Matlab/"/>
    
    <category term="Debug" scheme="http://example.com/categories/Matlab/Debug/"/>
    
    
    <category term="Matlab" scheme="http://example.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>Matlab function初步</title>
    <link href="http://example.com/2023/04/13/12-Matlab/function/"/>
    <id>http://example.com/2023/04/13/12-Matlab/function/</id>
    <published>2023-04-13T02:50:54.000Z</published>
    <updated>2023-04-13T03:08:00.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab-中的函数"><a href="#Matlab-中的函数" class="headerlink" title=" Matlab 中的函数"></a><span id="more"></span> Matlab 中的函数</h1><p>在Matlab中也有函数的概念，（没有的话不就是个垃圾平台了X，对吧）</p><h2 id="函数文件与函数调用"><a href="#函数文件与函数调用" class="headerlink" title="函数文件与函数调用"></a>函数文件与函数调用</h2><blockquote><p>M文件根据调用方式的不同可以分为两类</p><ul><li>Script：脚本&#x2F;命令文件    可以直接输入文件名运行</li><li>Function： 函数文件，由function引导，通常带输入和输出参数</li></ul></blockquote><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[paras...]</span>=<span class="title">func_name</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 第一行是引导行，说明这个文件是个函数文件。</span></span><br><span class="line"><span class="comment">% 函数名必须以字母开头</span></span><br><span class="line"><span class="comment">% 输出参数大于一个时，用[]包裹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 函数文件名必须与函数名一致！</span></span><br></pre></td></tr></table></figure><p>支持递归</p><p>Matlab会传递两个永久变量<code>nargin</code>(number of arguments in)和<code> nargout</code>记录输入和输出实参个数。</p><p>这个还是相当有用的。</p><h3 id="函数文件中的多个函数"><a href="#函数文件中的多个函数" class="headerlink" title="函数文件中的多个函数"></a>函数文件中的多个函数</h3><p>在名为 stat2.m 的文件中定义两个函数，其中第一个函数调用第二个函数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m,s]</span> = <span class="title">stat2</span><span class="params">(x)</span></span></span><br><span class="line">    n = <span class="built_in">length</span>(x);</span><br><span class="line">    m = avg(x,n);</span><br><span class="line">    s = <span class="built_in">sqrt</span>(sum((x-m).^<span class="number">2</span>/n));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span> = <span class="title">avg</span><span class="params">(x,n)</span></span></span><br><span class="line">    m = sum(x)/n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>我的理解是，一个函数文件可以写多个函数，而与文件名相同的那个函数则是对外暴露的函数，这样对数据操作的安全性也有所保障。</p></blockquote><h3 id="全局与局部变量"><a href="#全局与局部变量" class="headerlink" title="全局与局部变量"></a>全局与局部变量</h3><p>在MATLAB中，变量可以被定义为全局变量或局部变量，具体含义如下：</p><p><strong>局部变量</strong>：局部变量指的是在函数内部定义的变量，只在函数内部可见。局部变量的作用域仅限于函数内部，函数外部无法访问这些变量。</p><p><strong>全局变量</strong>：全局变量指的是在函数外部定义的变量，可以被整个MATLAB程序中的任何函数访问。全局变量的作用域超出了函数内部，因此需要谨慎使用全局变量。</p><p>在函数中，可以通过以下方式定义和使用局部变量：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">myFunction</span><span class="params">(input)</span></span></span><br><span class="line">    <span class="comment">% 定义局部变量</span></span><br><span class="line">    localVariable = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">% 使用局部变量进行计算</span></span><br><span class="line">    result = input + localVariable;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个示例函数中，变量<code>localVariable</code>是一个局部变量，仅在<code>myFunction</code>函数内部可见。变量input是函数的输入参数，也是一个局部变量。</p><p>如果需要在函数中使用全局变量，可以使用global关键字进行声明。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">myFunction</span><span class="params">(input)</span></span></span><br><span class="line">    <span class="comment">% 声明全局变量</span></span><br><span class="line">    <span class="keyword">global</span> globalVariable;</span><br><span class="line">    <span class="comment">% 使用全局变量进行计算</span></span><br><span class="line">    result = input + globalVariable;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个示例函数中，变量<code>globalVariable</code>是一个全局变量，使用global关键字进行声明。在函数内部，可以像使用局部变量一样使用全局变量。</p><p>需要注意的是，全局变量的使用会增加程序的复杂度和可维护性，因此应该尽量避免滥用全局变量。</p><blockquote><p>我的理解是将一些数据定义为全局变量可以方便用户计算时候更简单的使用一些常量，而不用在函数列表中传入过多无意义的参数。</p><p>个人更倾向于把全局变量作为常量，因为对其的修改可能会导致一些意外的影响。（如有错误请指正X）</p></blockquote><h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> numCalls; <span class="comment">% 声明全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化全局变量</span></span><br><span class="line">numCalls = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义一个函数，用于计算两个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">addNumbers</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">global</span> numCalls; <span class="comment">% 声明全局变量</span></span><br><span class="line">    numCalls = numCalls + <span class="number">1</span>;</span><br><span class="line">    result = a + b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用函数，并多次计算两个数的和</span></span><br><span class="line">addNumbers(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addNumbers(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">addNumbers(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出全局变量的值，即函数被调用的次数</span></span><br><span class="line"><span class="built_in">disp</span>(numCalls);</span><br></pre></td></tr></table></figure><blockquote><p>output: 3</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Matlab-中的函数&quot;&gt;&lt;a href=&quot;#Matlab-中的函数&quot; class=&quot;headerlink&quot; title=&quot; Matlab 中的函数&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Matlab" scheme="http://example.com/categories/Matlab/"/>
    
    <category term="function" scheme="http://example.com/categories/Matlab/function/"/>
    
    
    <category term="Matlab" scheme="http://example.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Action实现Hexo博客自动部署</title>
    <link href="http://example.com/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2023-04-12T12:55:54.000Z</published>
    <updated>2023-04-12T08:13:22.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a><span id="more"></span>缘由</h1><p>一天在课上当我准备上传我的Hexo静态博客，但意外的报了个莫名其妙的错，表示无法连接到服务器。当时问了问群u，等我解决后，发现一位群u提到了可以用Github Action触发服务器自动拉取，我也意识到每次都全部上传一遍确实有点烦人，于是我有打算来试试水。</p><h2 id="什么是Github-Action"><a href="#什么是Github-Action" class="headerlink" title="什么是Github Action"></a>什么是Github Action</h2><blockquote><p>GitHub Actions 是一种持续集成和持续交付 (CI&#x2F;CD) 平台，可用于自动执行生成、测试和部署管道。  您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。(这么长看都懒得看)</p></blockquote><p>简单地说，Github Action 提供了 Linux、Windows 和 macOS 虚拟机，用户可以自定义脚本，当检测到特定事件发生是就会执行相应的脚本。</p><p>下回有时间写一篇博客详细说说吧。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的想法是当我在本地生成页面后，将页面push到Github的仓库中，同时触发Action，让服务器端自动pull页面，实现博客的部署。</p><h2 id="服务器端的配置"><a href="#服务器端的配置" class="headerlink" title="服务器端的配置"></a>服务器端的配置</h2><p>既然我需要服务器端自动pull我的页面，那么服务器必须安装git，这个应该不用多说。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-git install git</span><br><span class="line">$ // 生成你的key，再去github填上</span><br><span class="line">$ <span class="built_in">cd</span> /path</span><br><span class="line">$ git <span class="built_in">clone</span> yourUrl</span><br></pre></td></tr></table></figure><p>不过因为我的博客之前是部署在<code>/var/www/html</code>下的，然后我也懒得改，于是在clone后就把文件夹直接改了个名。</p><h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p>回顾一下想法，首先是在push的时候触发，然后服务器自动pull页面。</p><h3 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h3><p>点击仓库中的Actions</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/00-action.png" alt="Action"></p><p>选择创建一个新的workflow</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/01-action.png" alt="workflow"></p><p>直接自己创建一个</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/02-action.png" alt="my workflow"></p><p>然后就可以看到一个编辑脚本的界面，我把它重命名为了<code>deply.yml</code>，接下去稍稍解释一下。</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/03-action.png" alt="deply"></p><p>这里是定义变量的地方：</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/04-secret.png" alt="vars"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deply</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">    <span class="attr">push:</span>  <span class="string">//</span> <span class="string">发生push操作时候执行</span></span><br><span class="line">        <span class="attr">branches:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">master</span>  <span class="string">//</span> <span class="string">在哪个分支上</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="attr">deply:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">auto</span> <span class="string">delpy</span></span><br><span class="line">        <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clone</span> <span class="string">pages</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">              <span class="attr">with:</span>   <span class="string">//</span> <span class="string">这几个变量可以在action中自己设置</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span>       <span class="string">//</span> <span class="string">服务器地址</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USER</span> <span class="string">&#125;&#125;</span>   <span class="string">//</span> <span class="string">用户名</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PASSWD</span> <span class="string">&#125;&#125;</span>  <span class="string">//</span> <span class="string">密码</span></span><br><span class="line">                  <span class="attr">script:</span> <span class="string">cd</span> <span class="string">/var/www/html</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">pull</span> </span><br><span class="line">                  <span class="string">//</span> <span class="string">在服务器端的执行的脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里的意思是当我push到master分支后，会通过github在<code>HOST</code>上执行脚本，从而实现自动clone的操作。</p><p>接下去每当你push一次你的界面，过一会会你就会发现你的博客页面已经更新了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Github" scheme="http://example.com/categories/Github/"/>
    
    <category term="Github Action" scheme="http://example.com/categories/Github/Github-Action/"/>
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
    <category term="自动部署" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
    <category term="博客" scheme="http://example.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能-01</title>
    <link href="http://example.com/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/"/>
    <id>http://example.com/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/</id>
    <published>2023-04-12T12:50:54.000Z</published>
    <updated>2023-04-12T08:08:23.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平均负载（Load-Average）是什么意思"><a href="#平均负载（Load-Average）是什么意思" class="headerlink" title=" 平均负载（Load Average）是什么意思"></a><span id="more"></span> 平均负载（Load Average）是什么意思</h1><p>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uptime</span></span><br><span class="line">02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88 </span><br></pre></td></tr></table></figure><p>在load average中分别是过去 1 分钟、5 分钟、15 分钟的平均负载。</p><blockquote><p>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数</p></blockquote><p>所谓可运行的进程，指的是正在使用或者正在等待CPU的进程。而平均负载可以理解为单位时间内有几个<code>活跃</code>的进程(事实上要复杂得多,实际上是活跃进程数的指数衰减平均值<del>数学差的我根本不想去理解</del>)。</p><p>那么对一个系统而言，负载高了显然是一件糟糕的事情，假如负载小于CPU的核心个数那意味着还有一些空闲，假如负载高于CPU的核心数目那意味着有些进程没法得到处理<del>that’s bad</del>。</p><h2 id="平均负载为多少时合理"><a href="#平均负载为多少时合理" class="headerlink" title="平均负载为多少时合理"></a>平均负载为多少时合理</h2><p>可以想到，假如负载刚好等于CPU个数既不会有资源的浪费也没有进程无法得到处理。</p><p>为了知道CPU的个数可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>打个比方，平均负载的值越高，表示系统中需要运行的进程越多，系统越繁忙。反之，如果平均负载较低，表示系统相对空闲。为了更好地理解这个概念，我们可以将平均负载与现实生活中的一个例子相类比：超市的排队人数。假设超市有 4 个收银台，如果排队的人数为 4，那么每个收银台都有一个顾客在结账，系统运行得比较顺畅。如果排队的人数超过 4，那么一些顾客需要等待，系统开始变得繁忙。如果排队的人数远远超过 4，那么等待时间会变得很长，系统会变得非常繁忙。</p><p>其实在先前的<code> uptime</code>命令获取到的3个时间段的负载中可以分析出不少信息：</p><ul><li>首先，假如三个时间段的数值差距不大，这说明系统负载平稳，没有什么突发的进程。</li><li>假如1分钟的数值远小于15分钟的值，这说明在15分钟内有很高的负载，但在最近一分钟开始降低负载。</li><li>相反，假如1分钟的数值远大于15分钟的值，那说明最近系统负载正在上升。</li></ul><p>这时候我们也会疑惑，当平均负载高于多少时应该做出行动，网上的建议是平均负载超出CPU最大负载的70%的时候应该排查一下问题，因为此时就可能影响服务的正常运行。但更合适的做法是联系起系统的长期负载，进行更深层次的分析后再做出处理。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpu核数: lscpu、 grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line">显示平均负载：<span class="built_in">uptime</span>、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势</span><br><span class="line"></span><br><span class="line">watch -d <span class="built_in">uptime</span>: -d会高亮显示变化的区域</span><br><span class="line"></span><br><span class="line">strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--<span class="built_in">timeout</span> 执行时间</span><br><span class="line"></span><br><span class="line">mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu</span><br><span class="line"></span><br><span class="line">pidstat:  进程性能分析工具，-u 显示cpu利用率</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>平均负载指的是：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;平均负载（Load-Average）是什么意思&quot;&gt;&lt;a href=&quot;#平均负载（Load-Average）是什么意思&quot; class=&quot;headerlink&quot; title=&quot; 平均负载（Load Average）是什么意思&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能-00</title>
    <link href="http://example.com/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/"/>
    <id>http://example.com/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/</id>
    <published>2023-04-11T12:50:54.000Z</published>
    <updated>2023-04-11T14:15:12.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为性能指标？"><a href="#何为性能指标？" class="headerlink" title=" 何为性能指标？"></a><span id="more"></span> 何为性能指标？</h1><p>性能是什么？大多数人的第一反应大多是速度快，而这正对应着两个指标<code>吞吐</code>和<code>延时</code>。然而这两个指标是从用户体验来看的，这两个指标可以从应用负载的角度来考察。与之相反的就是从系统资源的角度来看，比如资源使用率等。</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/10-Linux%E6%80%A7%E8%83%BD/00%E8%A7%86%E8%A7%92.6l2ogn7t5vr4.png" alt="视角"></p><p>众所周知，随着负载的增加，消耗的系统资源也会随之上升，而性能问题的本质是系统资源耗尽，无法处理足够的请求。</p><p>性能分析，其实就是找出应用或者系统的瓶颈，并设法去避免或者缓解，从而处理更多的请求，一般保研以下步骤：</p><ul><li><p>选择指标评估应用程序和系统的性能；</p></li><li><p>为应用程序和系统设置性能目标；</p></li><li><p>进行性能基准测试；</p></li><li><p>性能分析定位瓶颈；</p></li><li><p>优化系统和应用程序；</p></li><li><p>性能监控和告警。</p></li></ul><h2 id="一些性能工具"><a href="#一些性能工具" class="headerlink" title="一些性能工具"></a>一些性能工具</h2><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/10-Linux%E6%80%A7%E8%83%BD/perf-tool.3xixrmqdanuo.webp" alt="perf-tool"></p><p>你可以在<a href="https://github.com/brendangregg/perf-tools">这里</a>找到它们</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;何为性能指标？&quot;&gt;&lt;a href=&quot;#何为性能指标？&quot; class=&quot;headerlink&quot; title=&quot; 何为性能指标？&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop</title>
    <link href="http://example.com/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-08T12:50:54.000Z</published>
    <updated>2023-04-08T16:38:02.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Desktop使用记录"><a href="#Docker-Desktop使用记录" class="headerlink" title=" Docker Desktop使用记录"></a><span id="more"></span> Docker Desktop使用记录</h1><h2 id="安装-Win"><a href="#安装-Win" class="headerlink" title="安装(Win)"></a>安装(Win)</h2><p>我用的是Windows下的Docker Desktop，众所周知，docker 只有 linux 的发行版本，作为 windows 用户想要使用 docker 的功能自然仅能通过加装虚拟机这一条途径。同样，号称支持 windows 系统的 docker desktop 也是基于同样原理 —— 默认使用 windows 自带的 Hyper-V 服务允许 docker。</p><p>所以想安装 docker desktop 就要确保您的 windows 系统支持 wsl(适用于 Linux 的 Windows 子系统) 功能。我们可以直接在 cmd 或 powershell 中输入<code>wsl </code>来检查是否开启了wsl服务。</p><ul><li><p>打开 控制面板-&gt;程序-&gt;启用或关闭Windows功能，假如有 <code>Hyper-V</code> 和 适用于 <code>Linux 的 Windows 子系统</code>这两个选项，那就愉快得开启，假如没有那你就得去安装一下了</p></li><li><p>Hyper-V </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure></li><li><p>wsl</p></li></ul><p>在管理员模式下打开 PowerShell 或 Windows 命令提示符，输入 <code>wsl --install</code> 命令，然后重启电脑。</p><p>安装 <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></p><blockquote><p>如果每次启动都闪退，可能是你开启了<code>SMB 1.0/CIFS 文件共享支持</code>,去windows功能里给它关了就行了</p></blockquote><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="镜像站设置"><a href="#镜像站设置" class="headerlink" title="镜像站设置"></a>镜像站设置</h3><p>众所周知在天朝有些地方没法正常访问，所以为了加快拉取镜像的速度，需要设置一些镜像站。</p><p>来到这个页面更改里面的配置</p><p>以下是我的设置，当然你可以自己去找选择自己喜欢的。</p><p><img src="/%5Cimg%5C2023-4%5CDocker%5C01.png" alt="mirror"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://ccr.ccs.tencentyun.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><ol><li><p>在docker hub寻找需要下载的镜像（在cmd中执行docker search [镜像名]命令也可）</p></li><li><p>现在也可以直接在上面搜出来<br><img src="/%5Cimg%5C2023-4%5CDocker%5C02.png" alt="mirror"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-Desktop使用记录&quot;&gt;&lt;a href=&quot;#Docker-Desktop使用记录&quot; class=&quot;headerlink&quot; title=&quot; Docker Desktop使用记录&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Container" scheme="http://example.com/categories/Container/"/>
    
    <category term="Docker" scheme="http://example.com/categories/Container/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Container" scheme="http://example.com/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>写个TERTRIS</title>
    <link href="http://example.com/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/"/>
    <id>http://example.com/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/</id>
    <published>2023-03-16T12:50:54.000Z</published>
    <updated>2023-03-16T05:42:33.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用go写了个TETRIS"><a href="#用go写了个TETRIS" class="headerlink" title=" 用go写了个TETRIS"></a><span id="more"></span> 用go写了个TETRIS</h1><p>突发奇想<del>闲来无事情</del>想用go写一个Tertris（俄罗斯方块）玩</p><p>上网小小检索了一下，确实有很多可以实现游戏ui的2D引擎，但比较懒，不是很像搞明白怎么去用，所以选择了直接在终端打印出来。</p><p>既然想做，那就想想应该如何设计</p><blockquote><p>先看看正版到底长啥样</p></blockquote><p><img src="/img/2023-3/Tetris/Typical_Tetris_Game.svg.png" alt="Typical_Tetris_Game.svg"></p><p>分析一下：</p><ol><li>有个方方的游戏区域（显而易见）</li><li>方块会自然下落（这个嘛，没想好怎么处理就设计成直接放置的那种）</li><li>一行满了消去一行，然后下落</li></ol><h2 id="开始写吧"><a href="#开始写吧" class="headerlink" title="开始写吧"></a>开始写吧</h2><p>先定义一个游戏结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;</span><br><span class="line">Board  [][]<span class="type">int</span> <span class="comment">// 游戏区域</span></span><br><span class="line">Active [][]<span class="type">int</span> <span class="comment">// 还没用上，原来打算用来保存可掉落信息的</span></span><br><span class="line">Score  <span class="type">int</span></span><br><span class="line">Level  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WIDTH  = <span class="number">15</span>    <span class="comment">// 区域大小啦</span></span><br><span class="line">HEIGHT = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一步当然是初始化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BoardInit</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化游戏板</span></span><br><span class="line">g.Board = <span class="built_in">make</span>([][]<span class="type">int</span>, define.HEIGHT)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Board &#123;</span><br><span class="line">g.Board[i] = <span class="built_in">make</span>([]<span class="type">int</span>, define.WIDTH)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是打印出游戏区域</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印游戏板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintBoard</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是在每次出现变动时清除内容</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;cls&quot;</span>)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Run()</span><br><span class="line"><span class="comment">// ... ///</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Board &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">4</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;------------------------------|\n|&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> g.Board[i] &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[i][j] == <span class="number">0</span> &#123;    <span class="comment">// 有方块的话就打印一个矩形</span></span><br><span class="line">fmt.Print(<span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;■ &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;|\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot;|------------------------------|\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以看到像这样的输出</p><p><img src="/img/2023-3/Tetris/%E7%89%88%E9%9D%A2.png" alt="版面"></p><p>然后就应该在上方形成方块了</p><p>因为只有7种基本形状，于是为决定直接定义7个基本形状</p><p>至于为什么定义为4x4,是因为在游戏中这些方块是可以旋转的，为了简单起见，决定统一定义成4x4的结构，在旋转中只需修改它们的位置就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tetrominoes = [][][]<span class="type">int</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次获取的方块都是随机的于是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomTetromino</span><span class="params">()</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 对随机数生成器进行种子随机化</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="comment">// 从Tetrominoes数组中随机选择一个形状</span></span><br><span class="line">shape := define.Tetrominoes[rand.Intn(<span class="built_in">len</span>(define.Tetrominoes))]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制所选形状的矩阵到游戏板里</span></span><br><span class="line">tetromino := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(shape))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> shape &#123;</span><br><span class="line">tetromino[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(shape[i]))</span><br><span class="line"><span class="built_in">copy</span>(tetromino[i], shape[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tetromino</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTetrominoIn</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// 生成新的俄罗斯方块</span></span><br><span class="line">nextTetromino := RandomTetromino()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> nextTetromino &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> nextTetromino[i] &#123;</span><br><span class="line"><span class="keyword">if</span> nextTetromino[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">g.Board[i][j] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以打印出类似于这样的界面</p><p><img src="/img/2023-3/Tetris/%E5%A4%B4%E9%83%A8.png" alt="例子"></p><p>至于移动或旋转就很简单了，只需找到生成的方块再作相应处理就好了，这里就不贴出代码了。</p><p>下面处理消去一行的操作</p><p>其实就是每次遍历一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClearFullRows</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y := define.HEIGHT - <span class="number">1</span>; y &gt;= <span class="number">0</span>; y-- &#123;</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; define.WIDTH; x++ &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[y][x] == <span class="number">0</span> &#123;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除被消去的行</span></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; define.WIDTH; x++ &#123;</span><br><span class="line">g.Board[y][x] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有了个问题</p><p>如何下落？</p><ul><li>首先，相互连接的方块是不可以掉到底部的</li><li>消去的不一定是下一行</li><li>所有相连的方块是一个整体</li></ul><p>那这有有点头疼了，首先就是如何找到掉落方块整体，然后如何确定掉落高度</p><h3 id="那就先处理如何找到掉落方块整体区间"><a href="#那就先处理如何找到掉落方块整体区间" class="headerlink" title="那就先处理如何找到掉落方块整体区间"></a><strong>那就先处理如何找到掉落方块整体区间</strong></h3><p>由于只需要确定最小下落值，所以只用确定方块的左右范围就好了，但如何区查找呢？</p><p>因为整体说明这些方块左右上下想连，所以可以使用DFS算法去查找!</p><p>这里格外传入了<code>i</code>和<code>j</code>两个值代表开始检索的左下角，因为只有在清除行上的部分才会发生掉落，所以要传入坐标以确定起始位置</p><p>而传入的<code>left</code>和<code>right</code>就修改为得到的数值而继续使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dfs</span><span class="params">(grid [][]<span class="type">int</span>, i <span class="type">int</span>, j <span class="type">int</span>, visited [][]<span class="type">bool</span>, left *<span class="type">int</span>, right *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 检查当前位置是否已经被访问过，或者是否为0</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(grid) ||</span><br><span class="line">j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) ||</span><br><span class="line">grid[i][j] == <span class="number">0</span> || visited[i][j] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将当前位置标记为已访问</span></span><br><span class="line">visited[i][j] = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 更新左右边界</span></span><br><span class="line"><span class="keyword">if</span> *left &gt; j &#123;</span><br><span class="line">*left = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *right &lt; j &#123;</span><br><span class="line">*right = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历相邻的位置</span></span><br><span class="line">Dfs(grid, i<span class="number">-1</span>, j, visited, left, right) <span class="comment">// 上</span></span><br><span class="line">Dfs(grid, i+<span class="number">1</span>, j, visited, left, right) <span class="comment">// 下</span></span><br><span class="line">Dfs(grid, i, j<span class="number">-1</span>, visited, left, right) <span class="comment">// 左</span></span><br><span class="line">Dfs(grid, i, j+<span class="number">1</span>, visited, left, right) <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于掉落块的掉落高度"><a href="#关于掉落块的掉落高度" class="headerlink" title="关于掉落块的掉落高度"></a><strong>关于掉落块的掉落高度</strong></h3><p>emmm好像没啥好分析的，直接给出代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左往右查找，这个方法比较蠢</span></span><br><span class="line"><span class="comment">// startLine 代表的是被消去的那一行</span></span><br><span class="line"><span class="comment">// 详细代码在仓库里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Drop</span><span class="params">(g *define.Game, startLine <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">column := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> column &lt; define.WIDTH &#123;</span><br><span class="line">        <span class="comment">// 左右开始是重合的</span></span><br><span class="line">left, right := column, column</span><br><span class="line"><span class="keyword">for</span> y := startLine; y &gt;= <span class="number">5</span>; y-- &#123;</span><br><span class="line">            <span class="comment">// 找到第一个方块，然后进行搜索</span></span><br><span class="line"><span class="keyword">if</span> g.Board[y][column] == <span class="number">1</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(g.Board))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(g.Board[i]))</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 通过Dfs查找范围</span></span><br><span class="line">utils.Dfs(g.Board, y, column, visited, &amp;left, &amp;right)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dropHeight <span class="type">int</span> = <span class="number">999</span></span><br><span class="line">top := startLine</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := startLine; y &gt;= <span class="number">0</span>; y-- &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[y][i] == <span class="number">1</span> &#123;</span><br><span class="line">top = y</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y := top + <span class="number">1</span>; y &lt;= define.HEIGHT; y++ &#123;</span><br><span class="line"><span class="keyword">if</span> y == define.HEIGHT || g.Board[y][i] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> dropHeight &gt; y-top<span class="number">-1</span> &#123;</span><br><span class="line">dropHeight = y - top - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取了掉落高度，将范围内的下移</span></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := top; y &gt;= <span class="number">5</span>; y-- &#123;</span><br><span class="line">g.Board[y+dropHeight][i] = g.Board[y][i]</span><br><span class="line">g.Board[y][i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">column = right + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行例子，可能<del>一定还有一堆bug，不过能跑就好</del></p><p>这是我的<a href="https://github.com/GoldenSheep402/Tetris">代码仓库</a>，还有许多不足，望日后逐步修正</p><p><img src="/img/2023-3/Tetris/%E6%BC%94%E7%A4%BA.png" alt="演示"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用go写了个TETRIS&quot;&gt;&lt;a href=&quot;#用go写了个TETRIS&quot; class=&quot;headerlink&quot; title=&quot; 用go写了个TETRIS&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="game" scheme="http://example.com/tags/game/"/>
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>About JWT(JSON Web Token)</title>
    <link href="http://example.com/2023/01/27/08-About%20JSON%20Web%20Token/"/>
    <id>http://example.com/2023/01/27/08-About%20JSON%20Web%20Token/</id>
    <published>2023-01-27T12:50:54.000Z</published>
    <updated>2023-02-03T15:46:42.543Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。</p><h1 id="这玩意是个啥"><a href="#这玩意是个啥" class="headerlink" title=" 这玩意是个啥"></a><span id="more"></span> 这玩意是个啥</h1><blockquote><p>JSONweb token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></blockquote><h2 id="为什么要有JWT"><a href="#为什么要有JWT" class="headerlink" title="为什么要有JWT"></a>为什么要有JWT</h2><p>这需要提到基于token的身份认证和传统的session认证的区别</p><h3 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h3><p>访问网站是使用的http协议本身是无状态的，这就意味着如果用户需要进行身份认证，那么在下一次请求就需要再一次提交认证请求，而服务器必须存储用户登录的信息</p><p>这就意味着用户数量过高会使服务器无法承受访问压力</p><p><strong>问题</strong></p><ul><li><strong>Session</strong>: 用户经过我们的应用认证之后，都要在服务端做一次记录，从而分辨用户，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</li><li><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li><li><strong>CSRF</strong>: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li></ul><h3 id="基于Token的鉴权"><a href="#基于Token的鉴权" class="headerlink" title="基于Token的鉴权"></a>基于Token的鉴权</h3><p>虽然也是无状态的协议，但是不需要服务端去保留用户的认证信息，从而降低了服务器的压力同时提高了拓展能力</p><p><strong>流程</strong></p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><h1 id="关于JWT"><a href="#关于JWT" class="headerlink" title="关于JWT"></a>关于JWT</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JWT是由三段信息通过<code>.</code>连接组成的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure><h3 id="如何构成"><a href="#如何构成" class="headerlink" title="如何构成"></a>如何构成</h3><p>第一段被称为头部(header)，第二段被称为载荷(payload)，第三段称为(signature)</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>这里承载了JWT的元数据，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;typ&#x27;<span class="punctuation">:</span> &#x27;JWT&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;alg&#x27;<span class="punctuation">:</span> &#x27;HS256&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再对此使用Base64URL进行加密成为以下的样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>顾名思义，它承载了有效信息，除一些私有字段外，JWT官方规定了7个字段可供选用</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><blockquote><p>不过JWT默认时没有加密的，所以别把密码什么的私密信息写进去(<del>我干过</del>)</p></blockquote><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>其中的secret是只有服务端才知道，绝对不能泄露，然后使用header中指定的签名算法对其进行加密，以下以SHA256为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>一般是在请求头里加入<code>Authorization</code>，并同时加上<code>Bearer</code>标注(直接写query里也有)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;~~~~&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/2023-1/Jwt/how_it_works.png" alt="how_it_works"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由于JSON的通用性，所以JWT可以被很多语言通用</li><li>可以在payload中写入一些业务逻辑需要但非敏感的信息</li><li>利于传输</li><li>不需要在服务端保存信息，易于拓展</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。&lt;/p&gt;
&lt;h1 id=&quot;这玩意是个啥&quot;&gt;&lt;a href=&quot;#这玩意是个啥&quot; class=&quot;headerlink&quot; title=&quot; 这玩意是个啥&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="鉴权" scheme="http://example.com/categories/%E9%89%B4%E6%9D%83/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="鉴权" scheme="http://example.com/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-06结构</title>
    <link href="http://example.com/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/</id>
    <published>2022-12-05T12:50:00.000Z</published>
    <updated>2023-01-30T08:53:23.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-结构"><a href="#一-结构" class="headerlink" title=" 一.结构"></a><span id="more"></span> 一.结构</h1><blockquote><h2 id="定义-struct"><a href="#定义-struct" class="headerlink" title="定义 struct"></a>定义 struct</h2></blockquote><ul><li>使用 struct 关键字，并命名</li><li>在{…}内，为所有字段(Field)定义名称和类型</li><li>例如：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="实例化-stuct"><a href="#实例化-stuct" class="headerlink" title="实例化 stuct"></a>实例化 stuct</h2></blockquote><ul><li>要创建实例 (废话<del>但是废话好有道理啊</del>)<ul><li>为字段指定值(要全部指定)</li><li>无需按顺序</li></ul></li><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;somename&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@what.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h2 id="取-struct-中的值"><a href="#取-struct-中的值" class="headerlink" title="取 struct 中的值"></a>取 struct 中的值</h2><p> 使用点运算符：</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;somename&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@what.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;what?what?&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</p></blockquote><blockquote><h2 id="struct-作为函数返回值"><a href="#struct-作为函数返回值" class="headerlink" title="struct 作为函数返回值"></a>struct 作为函数返回值</h2></blockquote><p>此时这个 user 作为此函数的返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h2><p>有一种更简单的定义和使用结构体的方式：元组结构体。</p></blockquote><p>元组结构体是一种形式是元组的结构体。</p><p>与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">f64</span>, <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>使用方式和元组一样，可以使用下标来访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">f64</span>, <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;black = (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, black.<span class="number">0</span>, black.<span class="number">1</span>, black.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;origin = (&#123;&#125;, &#123;&#125;)&quot;</span>, origin.<span class="number">0</span>, origin.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体所有权"><a href="#结构体所有权" class="headerlink" title="结构体所有权"></a>结构体所有权</h1><p>结构体必须掌握字段值所有权，因为在结构体失效时会释放所有字段。</p><h2 id="输出结构体"><a href="#输出结构体" class="headerlink" title="输出结构体"></a>输出结构体</h2><p>可以加入 <code>#[derive(Debug)]</code>来输出整个结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="comment">// 使用&#123;:?&#125;占位符来输出整个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rect1 is Rectangle { width: 30, height: 50 }   使用{:?}</p><p>rect1 is Rectangle {                           使用{:#?}<br>   width: 30,<br>   height: 50<br>}</p></blockquote><h2 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h2><p>方法和函数是类似的，但是是通过结构体来实现。</p><p>Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象可以在 Rust 实现。</p><p>结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1&#x27;s area is &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rect1’s area is 1500</p></blockquote><h2 id="结构体关联函数"><a href="#结构体关联函数" class="headerlink" title="结构体关联函数"></a>结构体关联函数</h2><p>有些函数不依靠实例，但是使用需要注明是来自哪个impl模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">create</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-结构&quot;&gt;&lt;a href=&quot;#一-结构&quot; class=&quot;headerlink&quot; title=&quot; 一.结构&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-05切片</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/</id>
    <published>2022-12-04T12:50:54.000Z</published>
    <updated>2023-01-30T08:53:26.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Rust-Slice"><a href="#一-Rust-Slice" class="headerlink" title="一.Rust Slice"></a><span id="more"></span>一.Rust Slice</h1><p>切片（Slice）是对数据值的部分引用。</p><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part1</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part2</span> = &amp;s[<span class="number">5</span>..<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;=&#123;&#125;+&#123;&#125;&quot;</span>, s, part1, part2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>broadcast&#x3D;broad+cast</p></blockquote><p><img src="/img/2022-12/07-RUST/slice/rust-slice1.png" alt="slice"></p><p>x..y &#x3D;&#x3D; [x,y)</p><blockquote><p>..y 等价于 0..y<br>x.. 等价于位置 x 到数据结束<br>.. 等价于位置 0 到结束</p></blockquote><h2 id="非字符串切片"><a href="#非字符串切片" class="headerlink" title="非字符串切片"></a>非字符串切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = &amp;arr[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> part.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1</p><p>2</p><p>3</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-Rust-Slice&quot;&gt;&lt;a href=&quot;#一-Rust-Slice&quot; class=&quot;headerlink&quot; title=&quot;一.Rust Slice&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-04所有权</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/</id>
    <published>2022-12-04T04:50:03.000Z</published>
    <updated>2023-02-08T07:49:57.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-什么是所有权"><a href="#一-什么是所有权" class="headerlink" title="一.什么是所有权"></a><span id="more"></span>一.什么是所有权</h1><ul><li>Rust的核心特性是所有权</li><li>所有程序在运行是必须管理它们使用内存的方式<ul><li>有些语言有垃圾收集机制，在运行是，会自动去寻找不再使用的内存</li><li>其他语言中，必须手动地分配和释放内存</li></ul></li><li>Rust使用了第三种方式<ul><li>内存通过一个所有权系统来管理，其中包含一组编译器在编译时检查的规则</li><li>所以当程序运行是，所有权特性不会拖慢程序的运行速度</li></ul></li></ul><h2 id="Stack-amp-Heap"><a href="#Stack-amp-Heap" class="headerlink" title="Stack &amp; Heap"></a>Stack &amp; Heap</h2><ul><li>在Rust这样的系统级编程语言中，一个值是在stack还是再heap上对程序的行为和如何做决定有很大的影响</li></ul><blockquote><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3></blockquote><ul><li>stack 按值的接受顺序来存储,按相反的顺序移除(LIFO)<ul><li>push</li><li>pop</li></ul></li><li>所有存在stack上的数据必须有已知且固定的大小<ul><li>编译时未知大小的数据或是运行时大小可能发生改变的数据必须存储在heap上</li></ul></li></ul><blockquote><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3></blockquote><ul><li>将数据存入 heap 时，会请求一定空间</li><li>系统在 heap 中找到一块足够大的空间时，将它标记为在用，并返回一个指针</li></ul><h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><ul><li>将值压入 stack 不叫分配</li><li>因为指针是已知固定大小，可以把指针放在 stack 上<ul><li>想要实际数据可以使用指针来定位</li></ul></li><li>将数据压入 stack 比从 heap 中分配要快得多：<ul><li>因为系统无需寻找空间，只需要压入顶部</li></ul></li></ul><h3 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h3><ul><li>访问 heap 要比访问 stack 慢得多，因为要通过指针才能找到 heap 中的数据<ul><li>对于现代计算机，由于缓存的存在，指令在内存中跳转得越少，那么速度越快</li></ul></li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ul><li>调用函数时，值被传入到函数(包括指向 heap 的指针)。函数的变量压入 stack 中。函数结束后，这些值会被弹出</li></ul><h2 id="所有权存在的原因"><a href="#所有权存在的原因" class="headerlink" title="所有权存在的原因"></a>所有权存在的原因</h2><blockquote><p>所有权解决了什么？</p></blockquote><ul><li>跟踪代码那些部分在使用 heap 的那些数据</li><li>最小化 heap 中的重复数据</li><li>清理 heap 上未使用的数据</li></ul><h2 id="所有权的规则"><a href="#所有权的规则" class="headerlink" title="所有权的规则"></a>所有权的规则</h2><ul><li>每个值都有一个变量，这个变量是该值的所有者</li><li>每个值同时只能有一个所有者</li><li>所有者超出作用域后，这个值会被删除</li></ul><h1 id="二-内存与分配"><a href="#二-内存与分配" class="headerlink" title="二.内存与分配"></a>二.内存与分配</h1><ul><li>Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域的时候，内存自动还给操作系统</li><li>drop 函数</li></ul><h2 id="变量和数据交互的方式：Move"><a href="#变量和数据交互的方式：Move" class="headerlink" title="变量和数据交互的方式：Move"></a>变量和数据交互的方式：Move</h2><ul><li>多个变量可以与同一个数据使用一种独特的方式来交互<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure></li><li>整数是已知大小且固定大小的值，这两个5都被压入 stack 中</li></ul><h2 id="变量和数据交互的方式：Move-String"><a href="#变量和数据交互的方式：Move-String" class="headerlink" title="变量和数据交互的方式：Move(String)"></a>变量和数据交互的方式：Move(String)</h2><ul><li>一个 string 由三部分组成：<ul><li>指针 长度 容量</li></ul></li></ul><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/string%E7%BB%84%E6%88%90.png" alt="string"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><ul><li>将 s1 赋给 s2 时，将数据复制了一份：<ul><li>在 stack 上复制了一份（指针 长度 容量）</li><li>但是没有复制 heap 上的数据</li></ul></li><li>离开作用域后，会调用drop函数，将heap中的内存释放</li><li>当 s1、s2 都离开时，它们会尝试去释放相同的内存：<ul><li>二次释放(double free)</li></ul></li><li>为了保证内存安全：<ul><li>Rust 没有选择复制被分配的内存</li><li>Rust 使 s1 失效<ul><li>所以 s1 离开作用域的时候无需释放任何内存</li></ul></li></ul></li></ul><p>如果尝试使用 s1 会有以下错误<br><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/build-error.png" alt="error"></p><ul><li>浅拷贝(shallow copy)</li><li>深拷贝(deep copy)</li><li>由于 Rust 让 s1 失效，所以使用新的术语：移动(Move)</li><li>隐含的一个原则：Rust 不会自动创建数据的深拷贝<ul><li>就运行性能而言，任何自动赋值的操作都是廉价的</li></ul></li></ul><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/move.png" alt="move"></p><h2 id="克隆-clone"><a href="#克隆-clone" class="headerlink" title="克隆(clone)"></a>克隆(clone)</h2><p>如果想要 s1，s2 均有效，可以使用 clone方法(深度拷贝)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/clone.png" alt="move"></p><h2 id="stack上：复制"><a href="#stack上：复制" class="headerlink" title="stack上：复制"></a>stack上：复制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><ul><li>Copy trait 可以用于想整数这样完全存放在 stack 上的类型</li><li>如果一个类型实现了 copy 这个 tarit ，那么旧的变量在赋值后仍然可用</li><li>如果一个类型或者该类型的一部分实现了 drop trait ，那么Rust不允许它再去实现 copy tarit</li></ul><h3 id="拥有-copy-trait的类型"><a href="#拥有-copy-trait的类型" class="headerlink" title="拥有 copy trait的类型"></a>拥有 copy trait的类型</h3><ul><li>任何简单标量的组合类型都可copy</li><li>需要分配资源的不可copy</li><li>有 copy tarit 的类型<ul><li>所有整数</li><li>bool</li><li>char</li><li>float</li><li>Tuple(如果所有字段可copy)</li></ul></li></ul><h1 id="三-涉及函数的所有权机制"><a href="#三-涉及函数的所有权机制" class="headerlink" title="三.涉及函数的所有权机制"></a>三.涉及函数的所有权机制</h1><ul><li>对于变量而言函数的所有权问题显得非常奇怪</li></ul><h2 id="函数参数的所有权机制"><a href="#函数参数的所有权机制" class="headerlink" title="函数参数的所有权机制"></a>函数参数的所有权机制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);</span><br><span class="line">    <span class="comment">// s 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);</span><br><span class="line">    <span class="comment">// x 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 但 x 是基本类型，依然有效</span></span><br><span class="line">    <span class="comment">// 在这里依然可以使用 x 却不能使用 s</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// 一个 String 参数 some_string 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 函数结束, 参数 some_string 在这里释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 一个 i32 参数 some_integer 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span></span><br></pre></td></tr></table></figure><p>如果将变量作为参数传入函数，那么它和移动的效果是一样的</p><h2 id="函数返回值的所有权机制"><a href="#函数返回值的所有权机制" class="headerlink" title="函数返回值的所有权机制"></a>函数返回值的所有权机制</h2><blockquote><p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line">    <span class="comment">// gives_ownership 移动它的返回值到 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s2 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被当作参数移动, s3 获得返回值所有权</span></span><br><span class="line">&#125; <span class="comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// some_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> some_string;</span><br><span class="line">    <span class="comment">// some_string 被当作返回值移动出函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">    <span class="comment">// a_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string 被当作返回值移出函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-引用与租借"><a href="#四-引用与租借" class="headerlink" title="四.引用与租借"></a>四.引用与租借</h1><h2 id="引用与租借简单解释"><a href="#引用与租借简单解释" class="headerlink" title="引用与租借简单解释"></a>引用与租借简单解释</h2><blockquote><p>引用（Reference）是 C++ 开发者较为熟悉的概念。<br>如果你熟悉指针的概念，你可以把它看作一种指针。<br>实质上”引用”是变量的间接访问方式。</p></blockquote><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 is &#123;&#125;, s2 is &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><blockquote><p>s1 is hello, s2 is hello</p></blockquote><p><strong>&amp;</strong> 运算符可以取变量的”引用”。</p><p>当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值：</p><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/reference.png" alt="reference"></p><p>函数参数传递的道理相同:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The length of   ‘hello’  is 5.</p></blockquote><ul><li>参数类型是 &amp;String 而不是 String</li><li>&amp; 符号表示引用：允许你引用某些值而不取得所有权</li><li>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;<span class="comment">// 此时hello已经属于s3，不再属于s1，此时s2无法使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借：</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line">    s2 = &amp;s3; <span class="comment">// 重新从 s3 租借所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段程序是正确的。既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。如果尝试利用租借来的权利来修改数据会被阻止：</p></blockquote><ul><li>把引用作为参数的行为成为借用</li><li>无法修改借用的东西</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// 错误，禁止修改租借的值</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/change-borrow.png" alt="错误信息"></p><p>和变量一样，引用默认也是不可变的</p><p>这段程序中 s2 尝试修改 s1 的值被阻止，租借的所有权不能修改所有者的值。</p><p>当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的：</p><blockquote><p>可变引用示例</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s1可变</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">    <span class="comment">// 传入函数的是可变的引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  OUTPUT -<span class="punctuation">-&gt;</span> The length of <span class="symbol">&#x27;hello</span>, world!&#x27; is <span class="number">13</span>.</span><br></pre></td></tr></table></figure><p>这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。</p><p>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure><p>这段程序不正确，因为多重可变引用了 s。</p><blockquote><p>Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。</p><p>由于发生<strong>数据竞争</strong>的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</p><p>以下三种行为会发生数据竞争：</p><ol><li><strong>两个或多个</strong>指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有任何机制来同步数据的访问</li></ol></blockquote><ul><li><p>所以可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用；</p><ul><li>可以在编译时防止数据竞争</li></ul></li><li><p>可以通过创建新的作用域来创建多个可变引用</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125; <span class="comment">// r1 goes out of scope here, so we can make a new reference with no problems </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另一个限制</p></blockquote><ul><li>不可以同时拥有一个可变引用和一个不可变引用（因为有了一个不可变引用同时有一个可变说明不可变可变）</li><li>但是多个不可变引用是可以的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8.png" alt="多个引用"></p><h2 id="悬空引用-Dangling-Reference"><a href="#悬空引用-Dangling-Reference" class="headerlink" title="悬空引用(Dangling Reference)"></a>悬空引用(Dangling Reference)</h2><blockquote><p>悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块地址可能已经被释放并分配给其他人使用</p></blockquote><ul><li>在 Rust 里，编译器会保证引用永远不会悬空：<ul><li>如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle returns a reference to a String</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is a new String</span></span><br><span class="line">    &amp;s <span class="comment">// we return a reference to the String, s</span></span><br><span class="line">&#125; <span class="comment">// Here, s goes out of scope, and is dropped. Its memory goes away. Danger!</span></span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/dangle.png" alt="dangle"></p><blockquote><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任何给定的时刻，只能满足下列条件之一：<br>.  - 一个可变的引用</li><li>任意数量不可变的引用</li><li>引用必须一直有效</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-什么是所有权&quot;&gt;&lt;a href=&quot;#一-什么是所有权&quot; class=&quot;headerlink&quot; title=&quot;一.什么是所有权&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-03函数</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/</id>
    <published>2022-12-04T04:50:02.000Z</published>
    <updated>2023-01-30T08:54:46.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-函数"><a href="#Rust-函数" class="headerlink" title="Rust 函数"></a><span id="more"></span>Rust 函数</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><blockquote><p>fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</p></blockquote><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>x 的值为 : 5<br>y 的值为 : 6</p></blockquote><h2 id="函数体的语句与表达式"><a href="#函数体的语句与表达式" class="headerlink" title="函数体的语句与表达式"></a>函数体的语句与表达式</h2><p>Rust 的函数体由以表达式(expression)结尾的语句(statement)组成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span>     <span class="comment">// 这是一个表达式，它的值是整个函数的的结果值</span></span><br><span class="line">                  <span class="comment">// 被叫做函数体表达式(后面不能有;有的话就是一条statement)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>x 的值为 : 5<br>y 的值为 : 4</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>在-&gt;符号后面声明函数的返回值类型，但不可为返回值命名</li><li>在Rust中，返回值是函数体中最后一个表达式的值</li><li>若需要提前返回，使用return关键字，并指定一个值<ul><li>大部分函数都是默认使用最后一个表达式作为返回的值</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span> <span class="comment">//返回值就是5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust-函数&quot;&gt;&lt;a href=&quot;#Rust-函数&quot; class=&quot;headerlink&quot; title=&quot;Rust 函数&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-02数据类型</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-12-04T04:50:01.000Z</published>
    <updated>2023-01-30T08:54:44.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><span id="more"></span>数据类型</h1><ul><li>标量和复合类型</li><li>Rust是静态编译语言，在编译的同时必须知道所有变量的类型<ul><li>基于使用的值，编译器通常能够推断出它的具体类型</li><li>但如果可能的类型太多（例如将string转换为整数的parse方法），就必须添加类型的标注</li></ul></li></ul><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><ul><li>一个标量代表一个单一的值</li><li>Rust有四个主要的标量类型：<ul><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ul></li></ul><blockquote><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3></blockquote><ul><li>就是个整数</li><li>例如u32是一个无符号整数类型，占据32位空间</li><li>无符号用u开头</li></ul><p><img src="/img/2022-12/07-RUST/02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/type-pic.png" alt="type-pic"></p><blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3></blockquote><ul><li>Rust有两种基础的浮点类型<ul><li>f32</li><li>f64</li></ul></li><li>Rust的浮点类型使用了IEEE-754标注来表述</li><li>f64是默认类型，因为在现代CPU上f64和f32速度差不多，且精度更高</li></ul><blockquote><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3></blockquote><ul><li>true 和 false 两个值</li><li>一个字节</li><li>符号是bool</li></ul><blockquote><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3></blockquote><ul><li>Rust中的char类型用来表示最基础的单个字符</li><li>字符类型的字面值使用单引号</li><li>占用4个字节</li><li>使用Unicode编码</li></ul><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><blockquote><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3></blockquote><ul><li>可以使用模式匹配来解构一个Tuple来获取值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问Tuple的元素</p><ul><li>在Tuple变量使用点标记，后接元素索引</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></blockquote><ul><li>声明方法：在一个中括号中，各值用逗号分隔</li></ul><h4 id="数组的用处"><a href="#数组的用处" class="headerlink" title="数组的用处"></a>数组的用处</h4><ul><li>如果想让数据存放在stack中而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处</li><li>数组没有Vector灵活<ul><li>Vector和数组类似，它由标准库提供</li><li>Vector的长度可以改变</li></ul></li></ul><h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><ul><li><h2 id="数组的类型可以以这种形式表示：-类型-长度-let-a-i32-5-x3D-1-2-3-4-5"><a href="#数组的类型可以以这种形式表示：-类型-长度-let-a-i32-5-x3D-1-2-3-4-5" class="headerlink" title="数组的类型可以以这种形式表示：[类型; 长度]- let a[i32;5] &#x3D; [1,2,3,4,5];"></a>数组的类型可以以这种形式表示：[类型; 长度]<br>- let a[i32;5] &#x3D; [1,2,3,4,5];</h2></li></ul><h4 id="另一种声明数组的方法"><a href="#另一种声明数组的方法" class="headerlink" title="另一种声明数组的方法"></a>另一种声明数组的方法</h4><ul><li>如果数组的每个元素值都相同，那么可以在：<ul><li>在中括号中指定初始值</li><li>然后是一个 ;</li><li>最后是数组长度</li></ul></li><li>let a[3;5]; 等价于 let a &#x3D; [3,3,3,3,3];</li><li></li></ul><h4 id="访问数组的元素"><a href="#访问数组的元素" class="headerlink" title="访问数组的元素"></a>访问数组的元素</h4><ul><li>数组是Stack上分配的单个块的内存</li><li>可以使用索引</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">months</span> = [</span><br><span class="line">        <span class="string">&quot;Jan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Feb&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Mar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Apr&quot;</span>,</span><br><span class="line">        <span class="string">&quot;May&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Jun&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Jul&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Aug&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Sep&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Oct&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Nov&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Dec&quot;</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = months[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = months[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果访问的索引超出了数组的范围，那么：</p><ul><li>编译会通过</li><li>运行保存（runtime时panic）</li><li>Rust不会允许其访问相应地址的内存</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-01变量与可变性</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/</id>
    <published>2022-12-04T04:50:00.000Z</published>
    <updated>2023-02-03T12:50:08.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title=" 变量与可变性"></a><span id="more"></span> 变量与可变性</h1><ul><li>声明变量用let关键字</li><li>默认下是不可变（Immutable）</li><li>可以加入mut，使变量可变</li></ul><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul><li>常量（constant）,常量在绑定值后也是不可变，但是有许多不同：<ul><li>不可使用mut，常量永远不可变</li><li>声明常量使用const关键字，且类型必须被标注</li><li>常量可以在任何作用域中被声明</li></ul></li></ul><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><ul><li>可以使用相同的名字声明新的变量，新的变量会被shadow之前声明的同名变量</li><li>在后续代码中，这个名字代表的就是新的变量</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;变量与可变性&quot;&gt;&lt;a href=&quot;#变量与可变性&quot; class=&quot;headerlink&quot; title=&quot; 变量与可变性&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>再观《放牛班的春天》</title>
    <link href="http://example.com/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <id>http://example.com/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/</id>
    <published>2022-12-02T14:58:54.000Z</published>
    <updated>2023-01-30T08:53:56.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小小的观后感"><a href="#小小的观后感" class="headerlink" title="小小的观后感"></a><span id="more"></span>小小的观后感</h2><p><img src="/img/2022-12/%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/1.jpg" alt="1"><br>有人说，这部电影让人明白了何为师德，何为园丁。</p><p>在这所叫做“池塘之底”的辅育院中，以为矮胖的老师和一群顽劣不堪的孩子们却碰撞出了动人的歌声。</p><p><strong>在这歌声中隐藏这的是孩子们对世界的渴望。</strong></p><p>这部电影，没有高饱和度，也没有宏大的场面，但它却像一部美丽的童话，满是对希望的赞颂。</p><p>它多面而又真实，没有一个孩子出生就是邪恶的，打骂和体罚只会令他们的肉体屈服。但在我看来，这些孩子们的调皮行为更像是为了引起他人的注意，而不是怀揣着恶意去伤害他人。</p><p>王尔德说，生活在阴沟里，依然有仰望星空的权利。是的，无论你是成年人还是孩童，无论现在是家财万贯还是一贫如洗，即使跌入“池塘之底”，也依然可以找寻自己内心的光明。不得不说，影片主题深刻，一帧帧画面和一句句台词都闪耀着人性的光芒。</p><p><strong>希望我也能变得更加温暖，让自己让身边的人变得更好，让生活让世界变得更美。</strong></p><p><strong>纸飞机飞出窗口，蓝天下挥舞的小手，童年像一串串鸽子，拍打翅膀，一飞就永不回头</strong></p><p><img src="/img/2022-12/%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/3.jpg" alt="3"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;小小的观后感&quot;&gt;&lt;a href=&quot;#小小的观后感&quot; class=&quot;headerlink&quot; title=&quot;小小的观后感&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="电影" scheme="http://example.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://example.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>杂谈02</title>
    <link href="http://example.com/2022/11/27/06%E6%9D%82%E8%B0%88_02/"/>
    <id>http://example.com/2022/11/27/06%E6%9D%82%E8%B0%88_02/</id>
    <published>2022-11-27T15:57:54.000Z</published>
    <updated>2023-02-03T15:41:41.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一千零一面镜子"><a href="#一千零一面镜子" class="headerlink" title="一千零一面镜子"></a><span id="more"></span>一千零一面镜子</h1><p>我越是逃离<br>却越是靠近你<br>我越是背过脸<br>却越是看见你</p><p>我是一座孤岛<br>处在相思之水中<br>四面八方<br>隔绝我通向你</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>我在你结束</p><h1 id="林清玄：不要忘记飞翔的姿势"><a href="#林清玄：不要忘记飞翔的姿势" class="headerlink" title="林清玄：不要忘记飞翔的姿势"></a>林清玄：不要忘记飞翔的姿势</h1><p>在穿过林间的时候，<br>我觉得麻雀的死亡给我一些启示，<br>我们虽然在尘网中生活，<br>但永远不要失去想飞的心，不要忘记飞翔的姿势。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一千零一面镜子&quot;&gt;&lt;a href=&quot;#一千零一面镜子&quot; class=&quot;headerlink&quot; title=&quot;一千零一面镜子&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Life" scheme="http://example.com/categories/Life/"/>
    
    
    <category term="随记" scheme="http://example.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL概述</title>
    <link href="http://example.com/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/</id>
    <published>2022-11-26T04:50:54.000Z</published>
    <updated>2023-02-03T15:42:30.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1.SQL概述"></a><span id="more"></span>1.SQL概述</h2><h3 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1.1 SQL背景知识"></a>1.1 SQL背景知识</h3><ul><li>在1974年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。</li><li>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道 ，由IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ，SQL-92 ，SQL-99 等标准。</li><li>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</li></ul><p><img src="/img/2022-12/SQL%E6%A6%82%E8%BF%B0/1.png" alt="1"></p><h3 id="1-2-SQL分类"><a href="#1-2-SQL分类" class="headerlink" title="1.2 SQL分类"></a>1.2 SQL分类</h3><ul><li>DDL（Data Definition Languages 数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</li><li>DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。</li><li>DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。</li></ul><h2 id="2-1-SQL语法的规则与规范"><a href="#2-1-SQL语法的规则与规范" class="headerlink" title="2.1 SQL语法的规则与规范"></a>2.1 SQL语法的规则与规范</h2><ul><li>SQL 可以写为一行或者是多行。为了提高可读性，可将字句分行。</li><li>每条命令以；or  \g  or  \G 结束。(部分数据库要求)</li></ul><h3 id="2-2-SQL大小写规范"><a href="#2-2-SQL大小写规范" class="headerlink" title="2.2 SQL大小写规范"></a>2.2 SQL大小写规范</h3><ul><li><p>MySQL 在 Windows下对大写不敏感。</p></li><li><p>MySQL 在Linux下对大小写敏感。</p><ul><li>数据库名、表名、表的别名、变量名严格区分大小写。</li><li>关键字、函数名、字段名、字段别名是忽略大小写的。</li></ul></li><li><p>推荐的书写规范：</p><ul><li>数据库名、表名、表别名、字段名、字段别名使用小写。</li><li>SQL关键字、函数名、绑定变量使用大写。</li></ul></li></ul><h3 id="2-3-命名规则"><a href="#2-3-命名规则" class="headerlink" title="2.3 命名规则"></a>2.3 命名规则</h3><ul><li>数据库、表名不得超过30个字符，变量名限制为29个。</li><li>只能包含 A–Z, a–z, 0–9, _共63个字符。</li><li>数据库名、表名、字段名等对象名中间不要包含空格。</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用&#96;（着重号）引起来。</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了。</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#以下两句是一样的，不区分大小写</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line">#创建表格</span><br><span class="line">#<span class="keyword">create</span> <span class="keyword">table</span> student info(...); #表名错误，因为表名有空格</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_info(...);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-SQL概述&quot;&gt;&lt;a href=&quot;#1-SQL概述&quot; class=&quot;headerlink&quot; title=&quot;1.SQL概述&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://example.com/categories/SQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>杂谈01</title>
    <link href="http://example.com/2022/11/23/05%E6%9D%82%E8%B0%88_01/"/>
    <id>http://example.com/2022/11/23/05%E6%9D%82%E8%B0%88_01/</id>
    <published>2022-11-23T08:50:17.000Z</published>
    <updated>2023-02-03T15:40:48.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来点闲话"><a href="#来点闲话" class="headerlink" title="来点闲话"></a><span id="more"></span>来点闲话</h2><p>2022/11/23 记</p><p>到大学已经3个多月了，emmm其实和我想象中区别不大，没有那么不堪也没有所谓的如此美好，总结一下算是满意吧。</p><p>到现在已经结束了期中考，不是很理想也不是很糟糕(主要没像高中一样这么认真，现在真就是全依我性子学了)，还算是过了3个月算是充实的大学生活吧。</p><p>原以为我到大学会和以前一样不爱搭理人，不过在期间还是遇见了不少有趣的人们，而且被学长学姐视为“老油条”（笑死，喜欢钻学校空子罢了，不过确实一直挑战防疫底线，kkk)，还是想多认识认识志同道合有趣的灵魂们，大学不能把我自己烂在寝室里嘞。</p><p>我认为高中期间我是个容易陷入低沉的家伙，其实就是内耗吧，三年下来没少折磨过自己，多亏了高中同学们的包容，让我多次在焦虑与折磨中感受到他人的善意。高考结束后觉得以前许多事实在是没有意义，但是成长过程中或许这些法难以避免吧，到了现在算是有所改观。我之所以有现在的这样的态度离不开他人对我我关心与善意，在这里对我过去无意伤害过的亲友道个歉，暑假后我发现我从来不是一个人，不论在家还是学校都有人愿意向我伸出援手，所以希望发现身边的善意，并以善意对待他人，前一阵子看到一句话说:脾气好的原因:因为根本不care大部分和事。 可能说的也对吧，虽然有人说人是自私的，也没错，有可能这些乐于帮助他人的人最后没多少收获，但为了得到什么而去帮助他人是否有些太功利了？虽然人确实是复杂，但我相信从好的角度去看待他人与事情能改变自己的心境，高考前我对大多数人都抱有一丝怨气，当时看什么都难受，但是到大学呆了3个月，给足了自己空间，发觉把人想得更好自己才会更舒服。虽然说社会上也充斥着恶意，但我觉得以温和的方式去处置，没必要太有棱角，这样大家都能有自己的空间。有人说我过的太简单，以后会吃亏，但至少目前我觉得无所谓了，简单是我的方式吧。(不善言辞，兴起一写)</p><p>至于生活方面，因为高中养成的习惯，想在生活中掺入一些艺术气息，毕竟生活不能太无趣对吧(<del>不喜勿喷，只是我自己喜欢而已</del>)。</p><p>以上是浅薄之见，个人想法而已~</p><h3 id="说点倒霉的"><a href="#说点倒霉的" class="headerlink" title="说点倒霉的"></a>说点倒霉的</h3><ul><li>多次睡觉发现晒被子没收(记性极差)</li><li>长达半个月丢了伞，而且懒得买，一直淋雨，前两天刚下决心重买(好心疼生活费) PS:今天又忘餐厅了。。。</li></ul><h3 id="谈谈期待"><a href="#谈谈期待" class="headerlink" title="谈谈期待"></a>谈谈期待</h3><ul><li>一直耽搁的阅读计划总算有点起色，不多看看书可不行嘞~</li><li>再匀点时间到<del>有趣的</del>学业上</li><li>再瞎学点杂七杂八的技术实现需求(但是找不到需求)~</li><li>想学乐器(天赋没有，也没学费，哇要哭了)~~</li></ul><h3 id="已经实现的"><a href="#已经实现的" class="headerlink" title="已经实现的"></a>已经实现的</h3><ul><li><p>买了马克西姆12月21号的音乐会的场次，还是比较期待的，毕竟可以见到本人诶！</p></li><li><p>混进了杭助~~</p></li><li><p>没有错过11月8号的月食，好开心嘞！</p><p>晚点再加！出门了~</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;来点闲话&quot;&gt;&lt;a href=&quot;#来点闲话&quot; class=&quot;headerlink&quot; title=&quot;来点闲话&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Life" scheme="http://example.com/categories/Life/"/>
    
    
    <category term="随记" scheme="http://example.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL常用命令</title>
    <link href="http://example.com/2022/11/23/02-SQL/03SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/11/23/02-SQL/03SQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-11-23T06:50:54.000Z</published>
    <updated>2023-02-03T15:44:01.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL常用命令"><a href="#1-SQL常用命令" class="headerlink" title="1. SQL常用命令"></a><span id="more"></span>1. SQL常用命令</h2><p>SQL 不区分大小写，SELECT与select是相同的。</p><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。使用分号作为结束可以在一个请求中对服务器进行一条以上的语句。</p><h3 id="比较重要的命令"><a href="#比较重要的命令" class="headerlink" title="比较重要的命令"></a>比较重要的命令</h3><ul><li><strong>SELECT</strong> - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 变更（改变）数据库表</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引（搜索键）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul><blockquote><h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3></blockquote><p>SELECT 语句用于从数据库中选取数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> FORM users;</span><br></pre></td></tr></table></figure><p>此语句从 users 表中选取所有列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,age <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><p>此语句从 users 表中选取age和name两列</p><p><img src="/img/2022-12/SQL/SELECT_show.png" alt="SELECT_show"></p><blockquote><h3 id="WHERE-语句"><a href="#WHERE-语句" class="headerlink" title="WHERE 语句"></a>WHERE 语句</h3></blockquote><p>WHERE 子句用于提取那些满足指定条件的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name,column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name operator <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;u1&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此语句从 user表中选取name列都是”u1”的记录</p><p><img src="/img/2022-12/SQL/WHERE_show.png" alt="WHERE_show"></p><h4 id="WHERE-字句中的运算符"><a href="#WHERE-字句中的运算符" class="headerlink" title="WHERE 字句中的运算符"></a>WHERE 字句中的运算符</h4><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于。<strong>注释：</strong>在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr><tr><td align="left">IN</td><td align="left">指定针对某个列的多个可能值</td></tr></tbody></table><blockquote><h3 id="AND-amp-OR-运算符"><a href="#AND-amp-OR-运算符" class="headerlink" title="AND &amp; OR 运算符"></a>AND &amp; OR 运算符</h3></blockquote><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> alexa <span class="operator">&gt;</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> alexa <span class="operator">&gt;</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">AND</span> (country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span> <span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><h3 id="INSERT-INTO-语句"><a href="#INSERT-INTO-语句" class="headerlink" title="INSERT INTO 语句"></a>INSERT INTO 语句</h3></blockquote><p>INSERT INTO 语句可以有两种编写形式。</p><p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">*</span>table_name<span class="operator">*</span></span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">*</span>value1<span class="operator">*</span>,<span class="operator">*</span>value2<span class="operator">*</span>,<span class="operator">*</span>value3<span class="operator">*</span>,...);</span><br></pre></td></tr></table></figure><p>第二种形式需要指定列名及被插入的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">*</span>table_name<span class="operator">*</span> (<span class="operator">*</span>column1<span class="operator">*</span>,<span class="operator">*</span>column2<span class="operator">*</span>,<span class="operator">*</span>column3<span class="operator">*</span>,...)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">*</span>value1<span class="operator">*</span>,<span class="operator">*</span>value2<span class="operator">*</span>,<span class="operator">*</span>value3<span class="operator">*</span>,...);</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (name,age) <span class="keyword">VALUES</span> (<span class="string">&#x27;u3&#x27;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/SQL/INSERT_INTO_SHOW.png" alt="INSERT_INTO SHOW"></p><blockquote><h3 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h3></blockquote><p>显而易见是用来更新表中已有的记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2,...</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">18</span> <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;u3&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/SQL/UPDATE_show.png" alt="UPDATE show"></p><p><strong>警告</strong></p><p>如果省略了 WHERE 字句 </p><p>会将所有 age 改为18</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure><blockquote><h3 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h3></blockquote><p>用于删除表中的一行记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column<span class="operator">=</span>some_value;</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>删除了 age &#x3D; 18 的一条记录</p><p><img src="/img/2022-12/SQL/DELETE_show.png" alt="DELETE show"></p><p><strong>警告</strong></p><p>和 UPDATE 同理，漏掉 WHERE 会删除表中所有记录</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-SQL常用命令&quot;&gt;&lt;a href=&quot;#1-SQL常用命令&quot; class=&quot;headerlink&quot; title=&quot;1. SQL常用命令&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://example.com/categories/SQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用Alist挂载OneDrive网盘</title>
    <link href="http://example.com/2022/11/05/00%E4%BD%BF%E7%94%A8Alist%E6%8C%82%E8%BD%BDOneDrive%E7%BD%91%E7%9B%98/"/>
    <id>http://example.com/2022/11/05/00%E4%BD%BF%E7%94%A8Alist%E6%8C%82%E8%BD%BDOneDrive%E7%BD%91%E7%9B%98/</id>
    <published>2022-11-05T03:39:54.000Z</published>
    <updated>2023-02-03T15:38:02.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="首先白嫖OneDrive的5T云盘"><a href="#首先白嫖OneDrive的5T云盘" class="headerlink" title="首先白嫖OneDrive的5T云盘"></a><span id="more"></span>首先白嫖OneDrive的5T云盘</h1><h3 id="申请微软开发者账号"><a href="#申请微软开发者账号" class="headerlink" title="申请微软开发者账号"></a>申请微软开发者账号</h3><p>申请地址：<a href="https://www.mspace.cc/?golink=aHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS96aC1jbi9taWNyb3NvZnQtMzY1L2Rldi1wcm9ncmFt">https://developer.microsoft.com/zh-cn/microsoft-365/dev-program</a><br><a href="http://47.98.175.122/img/2022-11-05/1.png"><img src="/img/2022-11-05/1.png" alt="1"></a></p><p>点击立即加入！</p><h2 id="注册开发者"><a href="#注册开发者" class="headerlink" title="注册开发者"></a>注册开发者</h2><p>根据指引填写各类资料后注册。</p><p>公司的话随便写</p><h2 id="设置E5订阅"><a href="#设置E5订阅" class="headerlink" title="设置E5订阅"></a>设置E5订阅</h2><p>[<img src="/img/2022-11-05/2.png" alt="2">]</p><p>至此，账户就已经拥有为期90天的E5订阅了，并一次性申请了25个用户许可证。 如果你只是自己用，现在已经可以使用”用户名@域.onmicrosoft.com” 和之前设置的密码登录你电脑上的Office了。</p><h3 id="获取5T容量"><a href="#获取5T容量" class="headerlink" title="获取5T容量"></a>获取5T容量</h3><p>[<img src="/img/2022-11-05/3.png" alt="3">]</p><p><strong>保存后OneDrive容量即升级成5T!</strong></p><h3 id="续期E5开发者账户"><a href="#续期E5开发者账户" class="headerlink" title="续期E5开发者账户"></a>续期E5开发者账户</h3><p>自行上网找办法~~</p><h2 id="为Alist先注册一个API"><a href="#为Alist先注册一个API" class="headerlink" title="为Alist先注册一个API"></a>为Alist先注册一个API</h2><p>[<img src="/img/2022-11-05/AlistOneDrive-01.png" alt="AlistOneDrive-01"></p><ul><li>Web的url是 <a href="https://tool.nn.ci/onedrive/callback">https://tool.nn.ci/onedrive/callback</a> 下文还会用到</li></ul><p>[<img src="/img/2022-11-05/AlistOneDrive-2.png" alt="AlistOneDrive-2"></p><ul><li>这个就是client secert的值，先保存下来</li></ul><p>[<img src="/img/2022-11-05/AlistOneDrive-3.png" alt="AlistOneDrive-3"></p><ul><li>给api获取读写权限</li><li><strong>到这里<code>OneDrive</code>设置已经完成,下面去<a href="https://tool.nn.ci/onedrive/request">https://tool.nn.ci/onedrive/request</a> 获取刷新令牌, 莱斯沟~</strong></li></ul><p>[<img src="/img/2022-11-05/AlistOneDrive-Token.png" alt="AlistOneDrive-Token"></p><ul><li>生成refresh token</li></ul><p><a href="http://47.98.175.122/img/2022-11-05/AlistOneDrive-Tokenhou.png"><img src="/img/2022-11-05/AlistOneDrive-Tokenhou.png" alt="AlistOneDrive-Tokenhou"></a></p><ul><li><code>client_id</code> : 客户端ID</li><li><code>client_secret</code> : 客户端密钥</li><li><code>redirect_uri</code> : 重定向URL</li><li><code>refresh_token</code> : 刷新令牌</li></ul><h3 id="Alist是什么"><a href="#Alist是什么" class="headerlink" title="Alist是什么"></a>Alist是什么</h3><p>Alist 是一款支持多种存储的目录文件列表程序，支持 web 浏览与 webdav，后端基于<code>gin</code>，前端使用<code>react</code>。</p><ul><li><a href="https://alist-doc.nn.ci/"><strong>官网地址</strong></a></li><li><a href="https://alist-doc.nn.ci/docs/intro"><strong>官网文档</strong></a></li></ul><h3 id="支持存储类型"><a href="#支持存储类型" class="headerlink" title="支持存储类型"></a>支持存储类型</h3><ul><li>本地存储</li><li><a href="https://www.aliyundrive.com/">阿里云盘</a></li><li>OneDrive / Sharepoint</li><li><a href="https://cloud.189.cn/">天翼云盘</a></li><li><a href="https://drive.google.com/">GoogleDrive</a></li><li><a href="https://www.123pan.com/">123 云盘</a></li><li><a href="https://pc.woozooo.com/">蓝奏云</a></li><li><a href="https://github.com/Xhofe/alist">Alist</a></li><li>FTP</li><li><a href="https://www.mypikpak.com/">PikPak</a></li><li><a href="https://shandianpan.com/">闪电盘</a></li><li><a href="https://aws.amazon.com/cn/s3/">S3</a></li><li>WebDav</li><li>Teambition（<a href="https://www.teambition.com/">中国</a>，<a href="https://us.teambition.com/">国际</a>）</li><li><a href="https://www.mediatrack.cn/">分秒帧</a></li><li><a href="https://yun.139.com/">和彩云</a> (个人云, 家庭云)</li><li><a href="https://disk.yandex.com/">Yandex.Disk</a></li><li><a href="http://pan.baidu.com/">百度网盘</a></li><li><a href="https://pan.quark.cn/">夸克网盘</a></li><li><a href="https://pan.xunlei.com/">迅雷云盘</a></li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul><li><p>安装</p><p><code>curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install</code></p></li><li><p>更新</p><p><code>curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update</code></p></li><li><p>卸载</p><p><code>curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall</code></p></li><li><p>自定义安装路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> # 安装</span><br><span class="line">curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s install /home/power</span><br><span class="line"> # 更新</span><br><span class="line">curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s update /home/power</span><br><span class="line"> # 卸载</span><br><span class="line">curl -fsSL &quot;https://nn.ci/alist.sh&quot; | bash -s uninstall /home/power</span><br></pre></td></tr></table></figure><h3 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h3><p>脚本部署完成后，Alist默认分配5244端口，密码则会在安装后显示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://YOUR_IP:5244/</span><br></pre></td></tr></table></figure><h3 id="本地目录配置"><a href="#本地目录配置" class="headerlink" title="本地目录配置"></a>本地目录配置</h3><p><img src="/img/2022-11-05/AlistShow.jpg" alt="AlistShow">挂载路径：既网盘挂载后路径，可以随意。</p><ul><li>地区：选网盘所在地。</li><li>客户端ID：client-id</li><li>客户端秘钥：client-secret</li><li>重定向URI:<a href="https://tool.nn.ci/onedrive/callback">https://tool.nn.ci/onedrive/callback</a> （不保证时效）</li><li>刷新令牌：refresh-token</li></ul><p>将这些数据保存后就能看到主页的网盘目录了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://alist-doc.nn.ci/docs/driver/onedrive/">OneDrive | Alist Document (nn.ci)</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;首先白嫖OneDrive的5T云盘&quot;&gt;&lt;a href=&quot;#首先白嫖OneDrive的5T云盘&quot; class=&quot;headerlink&quot; title=&quot;首先白嫖OneDrive的5T云盘&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    
    <category term="网盘挂载" scheme="http://example.com/tags/%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
    
  </entry>
  
</feed>
