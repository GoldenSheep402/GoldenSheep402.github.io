<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金羊的部落阁</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-13T16:27:19.637Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Golden Sheep</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MATLAB 绘图</title>
    <link href="http://example.com/2023/04/13/12-Matlab/draw/"/>
    <id>http://example.com/2023/04/13/12-Matlab/draw/</id>
    <published>2023-04-13T14:50:54.000Z</published>
    <updated>2023-04-13T16:27:19.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB-绘图"><a href="#MATLAB-绘图" class="headerlink" title=" MATLAB 绘图"></a><span id="more"></span> MATLAB 绘图</h1><p>这篇博文就来浅浅得说说MATLAB中的图像绘制，众所周知数据可视化是科学计算以及数据统计计算非常重要的部分，谁都不喜欢对着一大堆数字分析，看到一幅干干净净的图总能令人赏心悦目(但是作为使用者，真的不太喜欢，问就是懒)</p><p><strong>这篇文章会提到以下内容：</strong></p><blockquote><ol><li><p>图形窗口控制</p></li><li><p>二维图像绘制</p></li><li><p>三维图像绘制</p><ul><li><p>三维曲线图(curve plot)</p></li><li><p>三维曲面&#x2F;网格图( surface&#x2F;grid plot)</p></li></ul></li></ol></blockquote><h2 id="图像窗口绘制"><a href="#图像窗口绘制" class="headerlink" title="图像窗口绘制"></a>图像窗口绘制</h2><h3 id="创建图形窗口：figure"><a href="#创建图形窗口：figure" class="headerlink" title="创建图形窗口：figure"></a>创建图形窗口：figure</h3><p><code>figure</code>是MATLAB中中用来创建新的图形窗口的函数。每个图形窗口可以包含一个或多个图形对象（如曲线、散点图、直方图等）以及与其相关的文本、标签等。</p><p><strong>语法如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">figure</span>(h)   <span class="comment">% h为窗口号</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="string">&#x27;PropertyName&#x27;</span>, PropertyValue, ...)</span><br></pre></td></tr></table></figure><h3 id="清除图形界面：clf"><a href="#清除图形界面：clf" class="headerlink" title="清除图形界面：clf"></a>清除图形界面：clf</h3><p><code>clf</code> 是 “clear current figure” 的缩写，用于清除当前图形窗口中的内容，使得该窗口可以绘制新的图形。</p><h3 id="关闭图形窗口：-close"><a href="#关闭图形窗口：-close" class="headerlink" title="关闭图形窗口： close"></a>关闭图形窗口： close</h3><p>在MATLAB中，close函数用于关闭一个图形窗口，释放与之相关联的内存和系统资源。</p><p><strong>语法如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close all</span><br><span class="line">close figure_handle</span><br><span class="line">close(<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">close(<span class="string">&#x27;figure&#x27;</span>, figure_handle)</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>close</code>: 关闭当前活动的图形窗口。</li><li><code>close all</code>: 关闭所有的图形窗口。</li><li><code>close figure_handle</code>: 关闭指定图形句柄对应的图形窗口。</li><li><code>close(&#39;all&#39;)</code>: 关闭所有的图形窗口。</li><li><code>close(&#39;figure&#39;, figure_handle)</code>: 关闭指定图形句柄对应的图形窗口。</li></ul><p>其中，<code>figure_handle</code> 是一个整数或整数向量，表示图形句柄或多个图形句柄。如果要关闭多个图形窗口，可以使用整数向量指定多个图形句柄，例如 <code>close([1, 2, 3])</code>。</p></blockquote><h3 id="保持图形窗口：hold"><a href="#保持图形窗口：hold" class="headerlink" title="保持图形窗口：hold"></a>保持图形窗口：hold</h3><p>在 MATLAB 绘图中，<code>hold</code> 函数用于控制图形窗口是否保持当前绘图而不清空。当使用 <code>hold on</code> 后，新的绘图会添加到当前的图形中，而不会清空前面的绘图。当使用 <code>hold off</code> 后，新的绘图会覆盖之前的绘图。可以使用 <code>hold</code> 语句来打开或关闭保持模式。</p><p><strong>语法如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hold</span> on/off</span><br></pre></td></tr></table></figure><p><strong>演示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = linspace(-pi, pi, 100);</span><br><span class="line">y1 = sin(x);</span><br><span class="line">y2 = cos(x);</span><br><span class="line">plot(x, y1);</span><br><span class="line">hold on;</span><br><span class="line">plot(x, y2);</span><br><span class="line">hold off;</span><br></pre></td></tr></table></figure><blockquote><p>在这个例子中，先使用 <code>plot</code> 函数绘制了 <code>y1</code> 的曲线，然后开启保持模式，并用 <code>plot</code> 函数绘制 <code>y2</code> 的曲线，最后关闭保持模式，这样 <code>y1</code> 和 <code>y2</code> 的曲线就会在同一个图形窗口中显示出来。</p></blockquote><h2 id="二维图形绘制"><a href="#二维图形绘制" class="headerlink" title="二维图形绘制"></a>二维图形绘制</h2><h4 id="绘制二维图形命令：-plot"><a href="#绘制二维图形命令：-plot" class="headerlink" title="绘制二维图形命令： plot"></a>绘制二维图形命令： plot</h4><p><code>plot</code> 是 MATLAB 中用于绘制二维图形的函数，它可以绘制折线图、散点图等多种类型的图形。</p><p><strong>语法如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot</span>(Y) <span class="comment">% 绘制 Y 的线图</span></span><br><span class="line"><span class="built_in">plot</span>(X, Y) <span class="comment">% 绘制 X, Y 的线图</span></span><br><span class="line"><span class="built_in">plot</span>(X1, Y1, ..., Xn, Yn) <span class="comment">% 绘制多个数据的线图</span></span><br><span class="line"><span class="built_in">plot</span>(___, LineSpec) <span class="comment">% 绘制指定类型的线图</span></span><br><span class="line"><span class="built_in">plot</span>(___, Name, Value) <span class="comment">% 使用属性值对自定义绘图</span></span><br></pre></td></tr></table></figure><h4 id="plot函数的常用参数"><a href="#plot函数的常用参数" class="headerlink" title="plot函数的常用参数"></a>plot函数的常用参数</h4><blockquote><ul><li>x：表示要绘制的数据点的 x 坐标，可以是向量或矩阵。</li><li>y：表示要绘制的数据点的 y 坐标，可以是向量或矩阵。</li><li>‘LineStyle’：表示线的样式，常用的有‘-’（实线），‘–’（虚线），‘:’（点线）等。</li><li>‘LineWidth’：表示线的宽度，可以是任何正数值。</li><li>‘Marker’：表示数据点的标记，常用的有‘o’（圆圈），‘x’（叉号），‘+’（加号），‘*’（星号）等。</li><li>‘MarkerSize’：表示数据点的大小，可以是任何正数值。</li><li>‘Color’：表示线的颜色，可以是预定义颜色名称（如’red’，’blue’等）或RGB三元组（如[0.5 0.5 0.5]表示灰色）。</li><li>‘DisplayName’：表示线的显示名称，在legend函数中使用。</li></ul><p>除了上述常用参数，plot函数还有其他参数，如’MarkerEdgeColor’（数据点的边框色），’MarkerFaceColor’（数据点的填充颜色），’MarkerIndices’（指定要绘制的数据点的索引），’LineStyleOrder’（指定多条线的样式序列），’MarkerOrder’（指定多个数据点标记的序列），’ColorOrder’（指定多条线的颜色序列）等。</p></blockquote><p><strong>例子：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">y = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">plot</span>(x, y);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码将绘制一个简单的折线图，x 轴的值为 1、2、3 和 4，y 轴的值为 2、4、6 和 8。</p></blockquote><p><code>**plot</code> 函数还支持传递额外的参数来控制绘图样式，例如：**</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">100</span>);</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;r--&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><blockquote><p>这段代码将绘制一个正弦曲线，线条颜色为红色，线条样式为虚线，线条宽度为 2。除了颜色、样式和宽度，<code>plot</code> 函数还支持传递其他参数，例如设置坐标轴标签、标题等。</p></blockquote><p><strong>例子：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">x = linspace(0, 2*pi, 100);</span><br><span class="line">y1 = sin(x);</span><br><span class="line">y2 = cos(x);</span><br><span class="line"></span><br><span class="line">% 画出两条曲线</span><br><span class="line">plot(x, y1, &#x27;r&#x27;, x, y2, &#x27;b--&#x27;);</span><br><span class="line"></span><br><span class="line">% 添加标题</span><br><span class="line">title(&#x27;Sin and Cos Waves&#x27;);</span><br><span class="line"></span><br><span class="line">% 添加x轴和y轴标签</span><br><span class="line">xlabel(&#x27;x&#x27;);</span><br><span class="line">ylabel(&#x27;y&#x27;);</span><br><span class="line"></span><br><span class="line">% 设置x轴和y轴的范围</span><br><span class="line">xlim([0, 2*pi]);</span><br><span class="line">ylim([-1.5, 1.5]);</span><br><span class="line"></span><br><span class="line">% 设置x轴和y轴的刻度</span><br><span class="line">xticks([0, pi/2, pi, 3*pi/2, 2*pi]);</span><br><span class="line">xticklabels(&#123;&#x27;0&#x27;, &#x27;\pi/2&#x27;, &#x27;\pi&#x27;, &#x27;3\pi/2&#x27;, &#x27;2\pi&#x27;&#125;);</span><br><span class="line">yticks([-1, 0, 1]);</span><br><span class="line"></span><br><span class="line">% 添加网格线</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/12-MATLAB/draw/plot.png" alt="plot"></p><h3 id="绘制二维图形的子图：-subplot"><a href="#绘制二维图形的子图：-subplot" class="headerlink" title="绘制二维图形的子图： subplot"></a>绘制二维图形的子图： subplot</h3><p>subplot 是一个用于将 MATLAB 图形窗口划分为小块的函数，以便在同一个窗口中显示多幅图像。</p><p><strong>语法如下：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subplot(m, n, p)</span><br></pre></td></tr></table></figure><p>其中，m 和 n 是将窗口划分成 m 行和 n 列，p 指当前要绘制的子图在整个窗口中的位置。</p><p>如果将窗口分成 m 行和 n 列，则总共会有 m*n 个小块，它们从左到右、从上到下编号，编号方式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  ...  n</span><br><span class="line">n+1 n+2 ... 2*n</span><br><span class="line">...</span><br><span class="line">(m-1)*n+1 ... m*n</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>;</span><br><span class="line">y1 = <span class="built_in">sin</span>(x);</span><br><span class="line">y2 = <span class="built_in">cos</span>(x.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">% 2行1列，当前绘制第1幅图</span></span><br><span class="line"><span class="built_in">plot</span>(x,y1)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(x,y1,<span class="string">&#x27;filled&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">% 2行1列，当前绘制第2幅图</span></span><br><span class="line"><span class="built_in">plot</span>(x,y2)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(x,y2,<span class="string">&#x27;filled&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/12-MATLAB/draw/subplot.png" alt="subplot"></p><h3 id="关于二维图形一些杂项设置X"><a href="#关于二维图形一些杂项设置X" class="headerlink" title="关于二维图形一些杂项设置X"></a>关于二维图形一些杂项设置X</h3><blockquote><p>一张让人一目了然，赏心悦目的图能给人带来舒适感，这时候就需要给图加上各种各种各样的标注来美化以及显得自己很专业<del>bushi</del></p></blockquote><h4 id="xlabel-ylabel-zlabel"><a href="#xlabel-ylabel-zlabel" class="headerlink" title="xlabel ylabel zlabel"></a>xlabel ylabel zlabel</h4><p>用于给坐标轴轴添加标签。</p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xlabel(<span class="string">&#x27;text&#x27;</span>)</span><br><span class="line"><span class="comment">% that&#x27;s easy</span></span><br><span class="line">xlabel(<span class="string">&#x27;Time (s)&#x27;</span>, <span class="string">&#x27;FontName&#x27;</span>, <span class="string">&#x27;Times New Roman&#x27;</span>, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><ul><li>xlabel(‘text’)：添加文本标签；</li><li>xlabel(‘text’, ‘Name’, Value, …)：添加文本标签并设置属性值，如颜色、字体、字号等，常用属性值如下：</li><li>‘FontAngle’：字体倾斜度，可选值为’normal’(默认),’italic’或’oblique’；</li><li>‘FontName’：字体名称，可选值为’Helvetica’(默认),’Arial’,’FixedWidth’,’等宽字体’,’Times’等；</li><li>‘FontSize’：字体大小，可选值为任意正整数；</li><li>‘FontWeight’：字体粗细，可选值为’normal’(默认),’bold’,’light’,’demi’或任意正整数；</li><li>‘Color’：文本颜色，可选值为RGB三元组或MATLAB预设的颜色名称。</li></ul></blockquote><h4 id="文字注释（Text）"><a href="#文字注释（Text）" class="headerlink" title="文字注释（Text）"></a>文字注释（Text）</h4><p>用于在图形中添加文字注释。 </p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text(x, y, str)</span><br><span class="line">text(x, y, z, str)</span><br><span class="line"><span class="comment">% 其中，x、y、z 分别为要添加文字的位置，可以是一个标量、向量或矩阵，分别表示 x、y、z 坐标轴上的位置。str 是要添加的文字内容。</span></span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(x, y)</span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;sin(x)&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;A Simple Sin Curve&#x27;</span>)</span><br><span class="line">text(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;Origin&#x27;</span>) <span class="comment">% 在坐标轴中心添加文字注释</span></span><br></pre></td></tr></table></figure><h4 id="坐标轴（Axis）"><a href="#坐标轴（Axis）" class="headerlink" title="坐标轴（Axis）"></a>坐标轴（Axis）</h4><p>axis 函数是用于设置坐标轴范围的 MATLAB 函数。它可以用来调整 x 和 y 轴的上下限。</p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axis([xmin xmax ymin ymax zmin zmax])</span><br></pre></td></tr></table></figure><p>其中<code>zmin</code> 和 <code>zmax</code> 分别是 z 轴的最小值和最大值。如果只需要设置 x 和 y 轴的范围，可以将 <code>zmin</code> 和 <code>zmax</code> 设置为 <code>auto</code> 或者忽略它们。</p><p>除了可以传入数值来设置坐标轴范围外，还可以使用 <code>axis equal</code> 和 <code>axis tight</code> 来设置坐标轴范围。<code>axis equal</code> 会将 x 和 y 轴的范围设置成相等的，并且保证图形在显示时宽高比例相等。<code>axis tight</code> 会将坐标轴范围设置为图形数据的最小包围盒。</p><p>例如，下面的代码可以绘制出一个正弦曲线，并且设置 x 轴范围为 0 到 2π，y 轴范围为 -1 到 1：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">100</span>);</span><br><span class="line">y = <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="built_in">plot</span>(x, y);</span><br><span class="line">axis([<span class="number">0</span>, <span class="number">2</span>*<span class="built_in">pi</span>, <span class="number">-1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ul><li>注释（Annotation）：用 annotation 函数可以在画布上添加文本、箭头、线段等注释元素。</li></ul><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">annotation(<span class="string">&#x27;Type&#x27;</span>, <span class="string">&#x27;text&#x27;</span>, <span class="string">&#x27;String&#x27;</span>, <span class="string">&#x27;text_string&#x27;</span>, <span class="string">&#x27;Property&#x27;</span>, <span class="string">&#x27;Value&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><ul><li>图例（Legend）：用 legend 函数可以在图像上添加图例，显示出各个线条或者曲面的含义。</li></ul><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;label1&#x27;</span>, <span class="string">&#x27;label2&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;y1=sin(x)&#x27;</span>, <span class="string">&#x27;y2=cos(x)&#x27;</span>, <span class="string">&#x27;y3=tan(x)&#x27;</span>, <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;northwest&#x27;</span>, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">% 其中 &#x27;Location&#x27;, &#x27;northwest&#x27; 选项表示将标注放在左上角。还可以使用 &#x27;FontSize&#x27; 选项指定标注的字体大小。</span></span><br><span class="line"><span class="comment">% 这语法真的晕了，太灵活反而反人类了</span></span><br></pre></td></tr></table></figure><h4 id="标题（Title）"><a href="#标题（Title）" class="headerlink" title="标题（Title）"></a>标题（Title）</h4><p>用 title 函数可以在图像上添加标题。</p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title(<span class="string">&#x27;Title text&#x27;</span>, <span class="string">&#x27;Property&#x27;</span>, <span class="string">&#x27;Value&#x27;</span>, ...)</span><br></pre></td></tr></table></figure><h4 id="网格线（Grid-Lines）"><a href="#网格线（Grid-Lines）" class="headerlink" title="网格线（Grid Lines）"></a>网格线（Grid Lines）</h4><p>用 grid 函数可以在坐标系上添加网格线。</p><p>语法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid on</span><br></pre></td></tr></table></figure><h4 id="刻度（Ticks）"><a href="#刻度（Ticks）" class="headerlink" title="刻度（Ticks）"></a>刻度（Ticks）</h4><p>用 xticks 和 yticks 函数可以设置坐标轴上的刻度。</p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xticks([x1 x2 ...])</span><br><span class="line">yticks([y1 y2 ...])</span><br></pre></td></tr></table></figure><h4 id="坐标框（Box）"><a href="#坐标框（Box）" class="headerlink" title="坐标框（Box）"></a>坐标框（Box）</h4><p>用 box 函数可以在坐标系周围添加一个矩形边框。</p><p><strong>语法：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box on</span><br></pre></td></tr></table></figure><h4 id="设置-（set）"><a href="#设置-（set）" class="headerlink" title="设置 （set）"></a>设置 （set）</h4><p>set 函数用于设置图形对象（例如图形窗口、坐标轴、线条、文本等）的属性，包括颜色、线型、线宽、字体大小等等。它的语法为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(handle, <span class="string">&#x27;PropertyName&#x27;</span>, propertyvalue, ...)</span><br></pre></td></tr></table></figure><p>其中 handle 为需要设置属性的对象句柄，PropertyName 和 propertyvalue 分别为属性名和属性值，可以设置多个属性。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="built_in">plot</span>(x, y);</span><br><span class="line">set(h, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用 set 函数设置该曲线的线宽为 2，颜色为红色。</p><p>除了设置单个对象的属性，也可以用 set 函数一次性设置多个对象的相同属性。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 = <span class="built_in">plot</span>(x1, y1);</span><br><span class="line">h2 = <span class="built_in">plot</span>(x2, y2);</span><br><span class="line">set([h1, h2], <span class="string">&#x27;LineStyle&#x27;</span>, <span class="string">&#x27;--&#x27;</span>, <span class="string">&#x27;LineWidth&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上述代码创建了两条曲线并将其句柄存储在变量 h1 和 h2 中，然后使用 set 函数设置这两条曲线的线型为虚线，线宽为 2。</p><p>此外，还可以使用结构体的方式传递属性值。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="built_in">plot</span>(x, y);</span><br><span class="line">myprop.LineWidth = <span class="number">2</span>;</span><br><span class="line">myprop.Color = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">set(h, myprop);</span><br></pre></td></tr></table></figure><p>上述代码创建了一个曲线并将其句柄存储在变量 h 中，然后使用结构体 myprop 设置该曲线的线宽为 2，颜色为红色。</p><h2 id="三维图形绘制"><a href="#三维图形绘制" class="headerlink" title="三维图形绘制"></a>三维图形绘制</h2><h3 id="三维图形绘制命令-：-plot3"><a href="#三维图形绘制命令-：-plot3" class="headerlink" title="三维图形绘制命令 ： plot3"></a>三维图形绘制命令 ： plot3</h3><p>plot3是MATLAB中用于绘制三维曲线图的函数。它的语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">plot3</span>(X, Y, Z);</span><br><span class="line"><span class="built_in">plot3</span>(X, Y, Z, LineSpec);</span><br><span class="line"><span class="built_in">plot3</span>(..., Name, Value);</span><br></pre></td></tr></table></figure><p>其中，<code>X</code>、<code>Y</code>和<code>Z</code>是表示数据点坐标的向量或矩阵，<code>LineSpec</code>是可选的参数，用于指定线条的样式和颜色，<code>Name</code> -<code>Value</code>是可选的名称-值对参数，用于指定其他属性。</p><p><code>plot3</code>函数将三维数据点绘制在三维坐标系中，每个点的位置由其在X、Y和Z向量或矩阵中的坐标决定。如果X、Y和Z都是向量，则绘制一条折线，如果它们都是矩阵，则绘制多条折线。</p><p><code>LineSpec</code>参数是一个字符串，用于指定线条的样式和颜色，例如’r–’表示红色虚线。可以使用多个属性，用逗号分隔，例如’ro–’表示红色圆形点和虚线。</p><p><code>Name</code>-<code>Value</code>参数是一组可选的名称-值对，用于指定其他属性，例如线条宽度、标记大小等。常见的属性名称包括：</p><ul><li>LineWidth：线条宽度</li><li>Marker：标记类型</li><li>MarkerEdgeColor：标记边框颜色</li><li>MarkerFaceColor：标记填充颜色</li><li>MarkerSize：标记大小</li><li>Color：线条颜色</li></ul><p>例如，<code>plot3(X, Y, Z, &#39;LineWidth&#39;, 2, &#39;Marker&#39;, &#39;o&#39;, &#39;MarkerSize&#39;, 10)</code>将绘制线条宽度为2、标记类型为圆形、标记大小为10的三维曲线图。</p><p><strong>例子</strong>：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成数据</span></span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>, <span class="number">4</span>*<span class="built_in">pi</span>, <span class="number">100</span>);</span><br><span class="line">x = <span class="built_in">sin</span>(t);</span><br><span class="line">y = <span class="built_in">cos</span>(t);</span><br><span class="line">z = t;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制图像</span></span><br><span class="line"><span class="built_in">plot3</span>(x, y, z);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加坐标轴标签</span></span><br><span class="line">xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加标题</span></span><br><span class="line">title(<span class="string">&#x27;三维线条图&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加网格线</span></span><br><span class="line">grid on;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 调整坐标轴范围</span></span><br><span class="line">xlim([<span class="number">-1.5</span>, <span class="number">1.5</span>]);</span><br><span class="line">ylim([<span class="number">-1.5</span>, <span class="number">1.5</span>]);</span><br><span class="line">zlim([<span class="number">0</span>, <span class="number">13</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/12-MATLAB/draw/plot3.png" alt="plot3"></p><h3 id="三维曲面-x2F-网线"><a href="#三维曲面-x2F-网线" class="headerlink" title="三维曲面&#x2F;网线"></a>三维曲面&#x2F;网线</h3><h4 id="网线（not-wire-line）：-mesh"><a href="#网线（not-wire-line）：-mesh" class="headerlink" title="网线（not wire line）： mesh"></a>网线（not wire line）： mesh</h4><p>mesh函数是MATLAB中用于绘制三维曲面图的函数。该函数将一个矩阵作为参数，并绘制该矩阵的3D图像。在绘制3D曲面时，可以使用mesh函数创建网格。例如，可以使用mesh函数来绘制z &#x3D; sin(x) * cos(y)的曲面：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>*<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="number">2</span>*<span class="built_in">pi</span>);</span><br><span class="line">z = <span class="built_in">sin</span>(x).*<span class="built_in">cos</span>(y);</span><br><span class="line">mesh(x, y, z);</span><br></pre></td></tr></table></figure><p>这段代码首先使用meshgrid函数创建一个坐标网格。然后使用这个网格和一个由sin和cos计算出的z矩阵来调用mesh函数绘制3D曲面。</p><p>mesh函数可以使用的参数很多，包括以下几个常用的参数：</p><p>x,y,z：表示曲面上的点坐标矩阵，其中x和y用于生成网格，z用于计算曲面高度。<br>c：表示曲面颜色或高度值的矩阵。</p><ul><li>‘EdgeColor’：表示曲面边缘颜色。</li><li>‘FaceColor’：表示曲面颜色。</li><li>‘FaceAlpha’：表示曲面透明度。</li></ul><p>以下是一个绘制网格线的示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 定义函数</span></span><br><span class="line">[X,Y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">0.2</span>:<span class="number">2</span>);</span><br><span class="line">Z = X.*<span class="built_in">exp</span>(-X.^<span class="number">2</span> - Y.^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制网格图</span></span><br><span class="line">mesh(X,Y,Z);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 添加坐标轴标签和标题</span></span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;3D Mesh Plot Example&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/12-MATLAB/draw/3d-mesh.png" alt="mesh"></p><h4 id="曲面：-surf"><a href="#曲面：-surf" class="headerlink" title="曲面： surf"></a>曲面： surf</h4><p>surf函数用于绘制三维曲面图，它可以根据给定的数据绘制三维曲面。</p><p>语法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">surf(Z)</span><br><span class="line">surf(X,Y,Z)</span><br><span class="line">surf(...,C)</span><br><span class="line">surf(...,<span class="string">&#x27;PropertyName&#x27;</span>,PropertyValue,...)</span><br><span class="line">h = surf(...)</span><br></pre></td></tr></table></figure><p>其中，Z 是矩阵，表示要绘制的数据，X 和 Y 分别是与 Z 大小相同的矩阵，表示 Z 中数据点的 x 和 y 坐标。C 是与 Z 大小相同的矩阵，表示要绘制的曲面颜色。</p><p>PropertyName 和 PropertyValue 是一些可选属性和值对，用于控制曲面的绘制方式，例如：</p><ul><li>‘EdgeColor’：曲面边缘颜色；</li><li>‘FaceColor’：曲面颜色；</li><li>‘FaceAlpha’：曲面的透明度；</li><li>‘LineStyle’：曲面线条样式；</li><li>‘LineWidth’：曲面线条宽度；</li><li>‘Marker’：曲面标记类型。</li></ul><p>h 是曲面对象的句柄。</p><p>例如，以下代码绘制了一个简单的三维曲面图：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-2</span>:<span class="number">0.2</span>:<span class="number">2</span>,<span class="number">-2</span>:<span class="number">0.2</span>:<span class="number">2</span>);</span><br><span class="line"><span class="comment">% 生成了两个矩阵x和y,x 矩阵中的元素由 -2 到 2，每隔 0.2 个单位，增加一列，y 矩阵同理。</span></span><br><span class="line"><span class="comment">% 在三维绘图中，x 矩阵和 y 矩阵可以作为横纵坐标轴的坐标值，从而形成一个平面。</span></span><br><span class="line">z = x.*<span class="built_in">exp</span>(-x.^<span class="number">2</span>-y.^<span class="number">2</span>);</span><br><span class="line">surf(x,y,z);</span><br><span class="line">xlabel(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Y&#x27;</span>);</span><br><span class="line">zlabel(<span class="string">&#x27;Z&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;3D Surface&#x27;</span>);</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/12-MATLAB/draw/3d-surf.png" alt="3d-surf"></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><blockquote><ul><li><code>mesh</code> 函数绘制的是曲面的线框图，即只有网格线的外形，不包含填充面，也就是所谓的“线框图”或“骨架图”。</li><li><code>surf</code> 函数则绘制了带有填充面的曲面，也就是可以看到立体的表面图。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MATLAB-绘图&quot;&gt;&lt;a href=&quot;#MATLAB-绘图&quot; class=&quot;headerlink&quot; title=&quot; MATLAB 绘图&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="http://example.com/categories/MATLAB/"/>
    
    <category term="Draw" scheme="http://example.com/categories/MATLAB/Draw/"/>
    
    
    <category term="MATLAB" scheme="http://example.com/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB Data&amp;IO初步</title>
    <link href="http://example.com/2023/04/13/12-Matlab/file/"/>
    <id>http://example.com/2023/04/13/12-Matlab/file/</id>
    <published>2023-04-13T08:44:54.000Z</published>
    <updated>2023-04-13T16:29:19.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB-中数据操作"><a href="#MATLAB-中数据操作" class="headerlink" title=" MATLAB 中数据操作"></a><span id="more"></span> MATLAB 中数据操作</h1><blockquote><ol><li>数据IO</li><li>文件IO</li><li>Excel IO</li></ol></blockquote><h2 id="数据的IO"><a href="#数据的IO" class="headerlink" title="数据的IO"></a>数据的IO</h2><h3 id="键盘接受数据"><a href="#键盘接受数据" class="headerlink" title="键盘接受数据"></a>键盘接受数据</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = input(<span class="string">&#x27;message for user&#x27;</span>);</span><br><span class="line">x1 = input(<span class="string">&#x27;message for user&#x27;</span>,<span class="string">&#x27;s&#x27;</span>); <span class="comment">% 第二个参数是说明强制将输入解释为字符串</span></span><br><span class="line"><span class="comment">% 这个参数还能是以下值</span></span><br><span class="line"><span class="comment">% double single int8 int16 int32 int64</span></span><br></pre></td></tr></table></figure><h3 id="数据的显示"><a href="#数据的显示" class="headerlink" title="数据的显示"></a>数据的显示</h3><p>在MATLAB中，<code>disp()</code>函数是一种常用的输出函数，用于在命令窗口中显示一个或多个值、表达式或者字符串。它的语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(expression);</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>expression</code>是一个MATLAB表达式，可以是一个数值、矩阵、字符向量、单元数组、结构体等。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 显示一个字符串</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;Hello, world!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示一个数值</span></span><br><span class="line">x = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">disp</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示一个矩阵</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line"><span class="built_in">disp</span>(A);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示一个单元数组</span></span><br><span class="line">str = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">disp</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示一个结构体</span></span><br><span class="line">s.name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">s.age = <span class="number">25</span>;</span><br><span class="line">s.gender = <span class="string">&#x27;Male&#x27;</span>;</span><br><span class="line"><span class="built_in">disp</span>(s);</span><br></pre></td></tr></table></figure><p><strong>输出如下</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  Hello, world!</span><br><span class="line"> 3.1400</span><br><span class="line">  1     2     3</span><br><span class="line">  4     5     6</span><br><span class="line">  7     8     9</span><br><span class="line"> <span class="string">&#x27;apple&#x27;</span>    <span class="string">&#x27;banana&#x27;</span>    <span class="string">&#x27;cherry&#x27;</span></span><br><span class="line">struct with fields:</span><br><span class="line">  </span><br><span class="line"> name: <span class="string">&#x27;John&#x27;</span></span><br><span class="line">  age: 25</span><br><span class="line"> gender: <span class="string">&#x27;Male&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，<code>disp()</code>函数在输出一个值或者表达式时，会自动添加一些格式化和分隔符，如空格、制表符等。如果需要对输出的格式进行更精确的控制，可以使用其他的输出函数，如<code>fprintf()</code>、<code>sprintf()</code>等。</p></blockquote><h3 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h3><p>在MATLAB中，<code>sprintf()</code>函数是一种常用的输出函数，用于将格式化的数据转换成字符串。它的语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = sprintf(format, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><blockquote><p>和常见格式化输出没啥区别，毕竟语言是互通的</p></blockquote><p><strong>例子：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3.1415926</span>;</span><br><span class="line">str = sprintf(<span class="string">&#x27;pi = %.2f&#x27;</span>, x);</span><br><span class="line"><span class="built_in">disp</span>(str);</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>sprintf()</code>函数将数值<code>x</code>转换成一个带有两位小数的字符串，并将其赋值给变量<code>str</code>。然后，<code>disp()</code>函数将输出这个字符串，结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi = 3.14</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>sprintf()</code>函数中的格式化字符串可以包含占位符和修饰符，用于控制输出的格式。常用的占位符包括<code>%d</code>（整数）、<code>%f</code>（浮点数）、<code>%s</code>（字符串）等，常用的修饰符包括精度控制符、宽度控制符、对齐控制符等。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str = sprintf(<span class="string">&#x27;The answer is %d.&#x27;</span>, <span class="number">42</span>);</span><br><span class="line"><span class="built_in">disp</span>(str);    <span class="comment">% 输出 &quot;The answer is 42.&quot;</span></span><br><span class="line"></span><br><span class="line">str = sprintf(<span class="string">&#x27;x = %f&#x27;</span>, <span class="number">3.1415926</span>);</span><br><span class="line"><span class="built_in">disp</span>(str);    <span class="comment">% 输出 &quot;x = 3.141593&quot;</span></span><br><span class="line"></span><br><span class="line">str = sprintf(<span class="string">&#x27;%.2f&#x27;</span>, <span class="number">3.1415926</span>);</span><br><span class="line"><span class="built_in">disp</span>(str);    <span class="comment">% 输出 &quot;3.14&quot;</span></span><br><span class="line"></span><br><span class="line">str = sprintf(<span class="string">&#x27;%10s&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(str);    <span class="comment">% 输出 &quot;     Hello&quot;</span></span><br><span class="line"></span><br><span class="line">str = sprintf(<span class="string">&#x27;%-10s&#x27;</span>, <span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(str);    <span class="comment">% 输出 &quot;Hello     &quot;</span></span><br></pre></td></tr></table></figure><p>具体还是得去看<a href="https://ww2.mathworks.cn/help/matlab/ref/sprintf.html">文档</a>，文档才是最好的教程~~~</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>在 MATLAB 中，<code>save()</code> 函数用于将变量保存到文件中，以便在以后的 MATLAB 会话中使用。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save(filename)</span><br><span class="line">save(filename, variables)</span><br><span class="line">save(filename, variables, <span class="string">&#x27;-option&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>filename</code> 是字符串类型的参数，指定要保存的文件名及其路径；<code>variables</code> 是一个变量名列表，指定要保存的变量。第三个可选参数 <code>-option</code> 可以用来指定保存选项，如格式、版本等。</p></blockquote><p><strong>示例：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 保存单个变量到文件中</span></span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">5</span>);</span><br><span class="line">save(<span class="string">&#x27;data.mat&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 保存多个变量到文件中</span></span><br><span class="line">y = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">z = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">save(<span class="string">&#x27;data.mat&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 保存指定格式的文件</span></span><br><span class="line">save(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;-ascii&#x27;</span>);</span><br></pre></td></tr></table></figure><p><a href="https://ww2.mathworks.cn/help/matlab/ref/save.html">open 函数</a></p><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>在 MATLAB 中，<code>load()</code> 函数用于从文件中加载变量到 MATLAB 工作空间中。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load filename</span><br><span class="line">load(filename, variables)</span><br></pre></td></tr></table></figure><p>其中<code>filename</code>是文件的路径，<code>variables</code>是变量名列表，指定要从文件中加载的变量。</p><blockquote><p>需要注意的是，使用 <code>load()</code> 函数加载 MAT 文件时，MATLAB 会将文件中的所有变量全部加载到内存中，这可能会导致内存溢出的问题。为了避免这种情况，可以使用 <code>load()</code> 函数的 <code>-mat</code> 选项，它只会加载指定的变量。此外，还可以使用其他选项，如 <code>-ascii</code>、<code>-double</code>、<code>-float</code> 等，用来加载文本文件或者二进制文件。看看文档喽</p></blockquote><p><a href="https://ww2.mathworks.cn/help/matlab/ref/load.html">load 函数</a></p><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><p>在 MATLAB 中，fopen() 函数用于打开文件，并返回一个文件标识符（file identifier），用于后续文件操作。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fid = fopen(filename, mode)</span><br></pre></td></tr></table></figure><p>其中，filename 是要打开的文件名，可以包括文件路径；mode 是打开文件的模式，如读取模式 ‘r’、写入模式 ‘w’、追加模式 ‘a’ 等。打开文件后，fopen() 函数会返回一个文件标识符 fid，它可以用于后续文件操作。</p><p>下面是一些示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 打开文本文件以读取数据</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 打开文本文件以写入数据</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 打开二进制文件以读取数据</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 打开二进制文件以写入数据</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;output.bin&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在上述示例中，第一个示例中打开了一个文本文件 data.txt，并指定打开模式为 ‘r’，表示以只读模式打开文件。第二个示例中打开了一个文本文件 output.txt，并指定打开模式为 ‘w’，表示以写入模式打开文件。第三个示例中打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。第四个示例中打开了一个二进制文件 output.bin，并指定打开模式为 ‘wb’，表示以二进制写入模式打开文件。</p><p>需要注意的是，在打开文件时，需要指定正确的文件名和路径，并根据文件类型和需要的操作，选择合适的打开模式。如果打开文件失败，fopen() 函数会返回 -1，表示打开失败。</p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/fopen.html">fopen 函数</a></p><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><p>在 MATLAB 中，<code>fclose()</code> 函数用于关闭之前打开的文件，释放文件资源并关闭文件连接。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(fid)</span><br></pre></td></tr></table></figure><p>其中，<code>fid</code> 是之前打开文件所得到的文件标识符。关闭文件后，该文件标识符将不再可用。</p><p>下面是一个示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 打开文件</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;data.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 读取数据</span></span><br><span class="line">data = fscanf(fid, <span class="string">&#x27;%f&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 关闭文件</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="comment">% fclose 其实会返回一个状态，-1代表fall，0代表success</span></span><br></pre></td></tr></table></figure><p>在上述示例中，<code>fopen()</code> 函数打开文件 <code>data.txt</code>，并指定打开模式为 <code>&#39;r&#39;</code>。接下来，使用 <code>fscanf()</code> 函数从文件中读取数据，并存储到变量 <code>data</code> 中。最后，使用 <code>fclose()</code> 函数关闭文件。</p><p>需要注意的是，在读取或写入文件完成后，必须使用 <code>fclose()</code> 函数关闭文件，否则会导致<strong>文件资源泄漏</strong>，影响系统性能。</p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/fclose.html">fclose 函数</a></p><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><p>在 MATLAB 中，fread() 函数用于从打开的文件中读取二进制数据。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = fread(fid, <span class="built_in">size</span>, precision, skip, machinefmt)</span><br><span class="line">A = fread(fid, [M, N], precision, skip, machinefmt)</span><br></pre></td></tr></table></figure><p>其中，各参数的含义如下：</p><ul><li>fid：文件标识符，之前使用 fopen() 函数打开文件时返回的值。</li><li>size：要读取的数据大小，可以是一个数字，表示读取 size 个字节的数据，也可以是一个向量，表示读取一个 size 元素的向量。在读取数据之前，必须知道数据大小。</li><li>precision：数据类型，即数据的编码格式。</li><li>skip：跳过的字节数，用于指定要从文件中跳过多少字节后开始读取数据。如果不指定，则默认从文件的开头读取数据。</li><li>machinefmt：机器格式，即字节顺序。可以是以下类型之一：<ul><li>‘n’：本机格式（默认）</li><li>‘l’：小端格式</li><li>‘b’：大端格式</li></ul></li><li>[M, N]：矩阵的行数和列数，用于指定要读取的数据是一个 M 行 N 列的矩阵。</li></ul><p>下面是一个示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 打开二进制文件</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;data.bin&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 读取 5 个双精度浮点数</span></span><br><span class="line">A = fread(fid, <span class="number">5</span>, <span class="string">&#x27;double&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 关闭文件</span></span><br><span class="line">fclose(fid);</span><br></pre></td></tr></table></figure><p>在上述示例中，fopen() 函数打开了一个二进制文件 data.bin，并指定打开模式为 ‘rb’，表示以二进制读取模式打开文件。接下来，使用 fread() 函数从文件中读取 5 个双精度浮点数，并存储到变量 A 中。最后，使用 fclose() 函数关闭文件。</p><h2 id="Excel文件IO"><a href="#Excel文件IO" class="headerlink" title="Excel文件IO"></a>Excel文件IO</h2><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>在 MATLAB 中，可以使用 xlsread() 函数读取 Excel 文件中的数据。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[num, txt, raw] = xlsread(filename, sheet, range)</span><br></pre></td></tr></table></figure><p>其中，<code>filename</code> 是 Excel 文件名，可以包括文件路径；<code>sheet</code> 是要读取的工作表名或索引；<code>range</code>是要读取的单元格范围。num 是一个数值矩阵，包含了读取的数值数据；txt 是一个文本矩阵，包含了读取的文本数据；raw 是一个单元格数组，包含了所有读取的数据，包括数值和文本。如果 Excel 文件中没有文本数据，则 txt 返回一个空矩阵。</p><p>下面是一个示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 读取 Excel 文件</span></span><br><span class="line">[num, txt, raw] = xlsread(<span class="string">&#x27;data.xlsx&#x27;</span>, <span class="string">&#x27;Sheet1&#x27;</span>, <span class="string">&#x27;A1:C3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在上述示例中，xlsread() 函数读取了 Excel 文件 data.xlsx 中第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’，并将数值、文本和原始数据分别存储到 num、txt 和 raw 中。</p><p>需要注意的是，xlsread() 函数只能读取 Excel 文件中的数值和文本数据，不能读取图表、公式等其他类型的数据。此外，如果要读取的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的读取函数，如 csvread() 函数、textscan() 函数等。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在 MATLAB 中，可以使用 xlswrite() 函数将数据写入 Excel 文件。它的基本语法如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xlswrite(filename, data, sheet, range)</span><br></pre></td></tr></table></figure><p>其中，filename 是 Excel 文件名，可以包括文件路径；data 是要写入 Excel 文件的数据，可以是数值、文本或逻辑值；sheet 是要写入的工作表名或索引；range 是要写入的单元格范围。如果省略 sheet 参数，则默认写入第一个工作表；如果省略 range 参数，则默认写入整个工作表。</p><p>下面是一个示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 写入 Excel 文件</span></span><br><span class="line">data = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">xlswrite(<span class="string">&#x27;data.xlsx&#x27;</span>, data, <span class="string">&#x27;Sheet1&#x27;</span>, <span class="string">&#x27;A1:C3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在上述示例中，xlswrite() 函数将一个 3x3 的矩阵数据写入 Excel 文件 data.xlsx 的第一个工作表（’Sheet1’）中的单元格范围 ‘A1:C3’。</p><p>需要注意的是，xlswrite() 函数只能写入数值、文本和逻辑值数据，不能写入图表、公式等其他类型的数据。此外，如果要写入的 Excel 文件格式不是 .xls 或 .xlsx 格式，则可能需要使用其他的写入函数，如 csvwrite() 函数、fprintf() 函数等。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MATLAB-中数据操作&quot;&gt;&lt;a href=&quot;#MATLAB-中数据操作&quot; class=&quot;headerlink&quot; title=&quot; MATLAB 中数据操作&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="http://example.com/categories/MATLAB/"/>
    
    <category term="File" scheme="http://example.com/categories/MATLAB/File/"/>
    
    
    <category term="MATLAB" scheme="http://example.com/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB Debug</title>
    <link href="http://example.com/2023/04/13/12-Matlab/debug/"/>
    <id>http://example.com/2023/04/13/12-Matlab/debug/</id>
    <published>2023-04-13T02:55:54.000Z</published>
    <updated>2023-04-13T16:23:59.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matlab-的-Debug"><a href="#Matlab-的-Debug" class="headerlink" title=" Matlab 的 Debug"></a><span id="more"></span> Matlab 的 Debug</h1><p>作为一个数据处理平台，假如没有调试这个基本的功能是多么可怕X，当然Matlab为我们提供了调试的功能。</p><p>本文大概分为三个段落</p><blockquote><ol><li>代码内调试</li><li>断点调试方法</li><li>指令调试</li></ol></blockquote><h2 id="代码内调试"><a href="#代码内调试" class="headerlink" title="代码内调试"></a>代码内调试</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Matlab-的-Debug&quot;&gt;&lt;a href=&quot;#Matlab-的-Debug&quot; class=&quot;headerlink&quot; title=&quot; Matlab 的 Debug&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="http://example.com/categories/MATLAB/"/>
    
    <category term="Debug" scheme="http://example.com/categories/MATLAB/Debug/"/>
    
    
    <category term="MATLAB" scheme="http://example.com/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB function初步</title>
    <link href="http://example.com/2023/04/13/12-Matlab/function/"/>
    <id>http://example.com/2023/04/13/12-Matlab/function/</id>
    <published>2023-04-13T02:50:54.000Z</published>
    <updated>2023-04-13T16:29:49.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MATLAB-中的函数"><a href="#MATLAB-中的函数" class="headerlink" title=" MATLAB 中的函数"></a><span id="more"></span> MATLAB 中的函数</h1><p>在MATLAB中也有函数的概念，（没有的话不就是个垃圾平台了X，对吧）</p><h2 id="函数文件与函数调用"><a href="#函数文件与函数调用" class="headerlink" title="函数文件与函数调用"></a>函数文件与函数调用</h2><blockquote><p>M文件根据调用方式的不同可以分为两类</p><ul><li>Script：脚本&#x2F;命令文件    可以直接输入文件名运行</li><li>Function： 函数文件，由function引导，通常带输入和输出参数</li></ul></blockquote><h3 id="函数文件"><a href="#函数文件" class="headerlink" title="函数文件"></a>函数文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[paras...]</span>=<span class="title">func_name</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 第一行是引导行，说明这个文件是个函数文件。</span></span><br><span class="line"><span class="comment">% 函数名必须以字母开头</span></span><br><span class="line"><span class="comment">% 输出参数大于一个时，用[]包裹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 函数文件名必须与函数名一致！</span></span><br></pre></td></tr></table></figure><p>支持递归</p><p>Matlab会传递两个永久变量<code>nargin</code>(number of arguments in)和<code> nargout</code>记录输入和输出实参个数。</p><p>这个还是相当有用的。</p><h3 id="函数文件中的多个函数"><a href="#函数文件中的多个函数" class="headerlink" title="函数文件中的多个函数"></a>函数文件中的多个函数</h3><p>在名为 stat2.m 的文件中定义两个函数，其中第一个函数调用第二个函数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m,s]</span> = <span class="title">stat2</span><span class="params">(x)</span></span></span><br><span class="line">    n = <span class="built_in">length</span>(x);</span><br><span class="line">    m = avg(x,n);</span><br><span class="line">    s = <span class="built_in">sqrt</span>(sum((x-m).^<span class="number">2</span>/n));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m</span> = <span class="title">avg</span><span class="params">(x,n)</span></span></span><br><span class="line">    m = sum(x)/n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>我的理解是，一个函数文件可以写多个函数，而与文件名相同的那个函数则是对外暴露的函数，这样对数据操作的安全性也有所保障。</p></blockquote><h3 id="全局与局部变量"><a href="#全局与局部变量" class="headerlink" title="全局与局部变量"></a>全局与局部变量</h3><p>在MATLAB中，变量可以被定义为全局变量或局部变量，具体含义如下：</p><p><strong>局部变量</strong>：局部变量指的是在函数内部定义的变量，只在函数内部可见。局部变量的作用域仅限于函数内部，函数外部无法访问这些变量。</p><p><strong>全局变量</strong>：全局变量指的是在函数外部定义的变量，可以被整个MATLAB程序中的任何函数访问。全局变量的作用域超出了函数内部，因此需要谨慎使用全局变量。</p><p>在函数中，可以通过以下方式定义和使用局部变量：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">myFunction</span><span class="params">(input)</span></span></span><br><span class="line">    <span class="comment">% 定义局部变量</span></span><br><span class="line">    localVariable = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">% 使用局部变量进行计算</span></span><br><span class="line">    result = input + localVariable;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个示例函数中，变量<code>localVariable</code>是一个局部变量，仅在<code>myFunction</code>函数内部可见。变量input是函数的输入参数，也是一个局部变量。</p><p>如果需要在函数中使用全局变量，可以使用global关键字进行声明。例如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">myFunction</span><span class="params">(input)</span></span></span><br><span class="line">    <span class="comment">% 声明全局变量</span></span><br><span class="line">    <span class="keyword">global</span> globalVariable;</span><br><span class="line">    <span class="comment">% 使用全局变量进行计算</span></span><br><span class="line">    result = input + globalVariable;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这个示例函数中，变量<code>globalVariable</code>是一个全局变量，使用global关键字进行声明。在函数内部，可以像使用局部变量一样使用全局变量。</p><p>需要注意的是，全局变量的使用会增加程序的复杂度和可维护性，因此应该尽量避免滥用全局变量。</p><blockquote><p>我的理解是将一些数据定义为全局变量可以方便用户计算时候更简单的使用一些常量，而不用在函数列表中传入过多无意义的参数。</p><p>个人更倾向于把全局变量作为常量，因为对其的修改可能会导致一些意外的影响。（如有错误请指正X）</p></blockquote><h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> numCalls; <span class="comment">% 声明全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化全局变量</span></span><br><span class="line">numCalls = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义一个函数，用于计算两个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">addNumbers</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">global</span> numCalls; <span class="comment">% 声明全局变量</span></span><br><span class="line">    numCalls = numCalls + <span class="number">1</span>;</span><br><span class="line">    result = a + b;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 调用函数，并多次计算两个数的和</span></span><br><span class="line">addNumbers(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addNumbers(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">addNumbers(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 输出全局变量的值，即函数被调用的次数</span></span><br><span class="line"><span class="built_in">disp</span>(numCalls);</span><br></pre></td></tr></table></figure><blockquote><p>output: 3</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MATLAB-中的函数&quot;&gt;&lt;a href=&quot;#MATLAB-中的函数&quot; class=&quot;headerlink&quot; title=&quot; MATLAB 中的函数&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="MATLAB" scheme="http://example.com/categories/MATLAB/"/>
    
    <category term="Function" scheme="http://example.com/categories/MATLAB/Function/"/>
    
    
    <category term="MATLAB" scheme="http://example.com/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>使用Github Action实现Hexo博客自动部署</title>
    <link href="http://example.com/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <id>http://example.com/2023/04/12/12%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</id>
    <published>2023-04-12T12:55:54.000Z</published>
    <updated>2023-04-12T08:13:22.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a><span id="more"></span>缘由</h1><p>一天在课上当我准备上传我的Hexo静态博客，但意外的报了个莫名其妙的错，表示无法连接到服务器。当时问了问群u，等我解决后，发现一位群u提到了可以用Github Action触发服务器自动拉取，我也意识到每次都全部上传一遍确实有点烦人，于是我有打算来试试水。</p><h2 id="什么是Github-Action"><a href="#什么是Github-Action" class="headerlink" title="什么是Github Action"></a>什么是Github Action</h2><blockquote><p>GitHub Actions 是一种持续集成和持续交付 (CI&#x2F;CD) 平台，可用于自动执行生成、测试和部署管道。  您可以创建工作流程来构建和测试存储库的每个拉取请求，或将合并的拉取请求部署到生产环境。(这么长看都懒得看)</p></blockquote><p>简单地说，Github Action 提供了 Linux、Windows 和 macOS 虚拟机，用户可以自定义脚本，当检测到特定事件发生是就会执行相应的脚本。</p><p>下回有时间写一篇博客详细说说吧。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>我的想法是当我在本地生成页面后，将页面push到Github的仓库中，同时触发Action，让服务器端自动pull页面，实现博客的部署。</p><h2 id="服务器端的配置"><a href="#服务器端的配置" class="headerlink" title="服务器端的配置"></a>服务器端的配置</h2><p>既然我需要服务器端自动pull我的页面，那么服务器必须安装git，这个应该不用多说。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ apt-git install git</span><br><span class="line">$ // 生成你的key，再去github填上</span><br><span class="line">$ <span class="built_in">cd</span> /path</span><br><span class="line">$ git <span class="built_in">clone</span> yourUrl</span><br></pre></td></tr></table></figure><p>不过因为我的博客之前是部署在<code>/var/www/html</code>下的，然后我也懒得改，于是在clone后就把文件夹直接改了个名。</p><h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p>回顾一下想法，首先是在push的时候触发，然后服务器自动pull页面。</p><h3 id="创建一个Action"><a href="#创建一个Action" class="headerlink" title="创建一个Action"></a>创建一个Action</h3><p>点击仓库中的Actions</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/00-action.png" alt="Action"></p><p>选择创建一个新的workflow</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/01-action.png" alt="workflow"></p><p>直接自己创建一个</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/02-action.png" alt="my workflow"></p><p>然后就可以看到一个编辑脚本的界面，我把它重命名为了<code>deply.yml</code>，接下去稍稍解释一下。</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/03-action.png" alt="deply"></p><p>这里是定义变量的地方：</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/11-%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/04-secret.png" alt="vars"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">deply</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">    <span class="attr">push:</span>  <span class="string">//</span> <span class="string">发生push操作时候执行</span></span><br><span class="line">        <span class="attr">branches:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">master</span>  <span class="string">//</span> <span class="string">在哪个分支上</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="attr">deply:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">auto</span> <span class="string">delpy</span></span><br><span class="line">        <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">        <span class="attr">steps:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">clone</span> <span class="string">pages</span></span><br><span class="line">              <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@master</span></span><br><span class="line">              <span class="attr">with:</span>   <span class="string">//</span> <span class="string">这几个变量可以在action中自己设置</span></span><br><span class="line">                  <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HOST</span> <span class="string">&#125;&#125;</span>       <span class="string">//</span> <span class="string">服务器地址</span></span><br><span class="line">                  <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.USER</span> <span class="string">&#125;&#125;</span>   <span class="string">//</span> <span class="string">用户名</span></span><br><span class="line">                  <span class="attr">password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PASSWD</span> <span class="string">&#125;&#125;</span>  <span class="string">//</span> <span class="string">密码</span></span><br><span class="line">                  <span class="attr">script:</span> <span class="string">cd</span> <span class="string">/var/www/html</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">pull</span> </span><br><span class="line">                  <span class="string">//</span> <span class="string">在服务器端的执行的脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里的意思是当我push到master分支后，会通过github在<code>HOST</code>上执行脚本，从而实现自动clone的操作。</p><p>接下去每当你push一次你的界面，过一会会你就会发现你的博客页面已经更新了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;缘由&quot;&gt;&lt;a href=&quot;#缘由&quot; class=&quot;headerlink&quot; title=&quot;缘由&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Github" scheme="http://example.com/categories/Github/"/>
    
    <category term="Github Action" scheme="http://example.com/categories/Github/Github-Action/"/>
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
    <category term="自动部署" scheme="http://example.com/tags/%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    
    <category term="博客" scheme="http://example.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能-01</title>
    <link href="http://example.com/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/"/>
    <id>http://example.com/2023/04/12/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-01/</id>
    <published>2023-04-12T12:50:54.000Z</published>
    <updated>2023-04-12T08:08:23.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="平均负载（Load-Average）是什么意思"><a href="#平均负载（Load-Average）是什么意思" class="headerlink" title=" 平均负载（Load Average）是什么意思"></a><span id="more"></span> 平均负载（Load Average）是什么意思</h1><p>每次发现系统变慢时，我们通常做的第一件事，就是执行 top 或者 uptime 命令，来了解系统的负载情况。比如像下面这样，我在命令行里输入了 uptime 命令，系统也随即给出了结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uptime</span></span><br><span class="line">02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88 </span><br></pre></td></tr></table></figure><p>在load average中分别是过去 1 分钟、5 分钟、15 分钟的平均负载。</p><blockquote><p>平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数</p></blockquote><p>所谓可运行的进程，指的是正在使用或者正在等待CPU的进程。而平均负载可以理解为单位时间内有几个<code>活跃</code>的进程(事实上要复杂得多,实际上是活跃进程数的指数衰减平均值<del>数学差的我根本不想去理解</del>)。</p><p>那么对一个系统而言，负载高了显然是一件糟糕的事情，假如负载小于CPU的核心个数那意味着还有一些空闲，假如负载高于CPU的核心数目那意味着有些进程没法得到处理<del>that’s bad</del>。</p><h2 id="平均负载为多少时合理"><a href="#平均负载为多少时合理" class="headerlink" title="平均负载为多少时合理"></a>平均负载为多少时合理</h2><p>可以想到，假如负载刚好等于CPU个数既不会有资源的浪费也没有进程无法得到处理。</p><p>为了知道CPU的个数可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>打个比方，平均负载的值越高，表示系统中需要运行的进程越多，系统越繁忙。反之，如果平均负载较低，表示系统相对空闲。为了更好地理解这个概念，我们可以将平均负载与现实生活中的一个例子相类比：超市的排队人数。假设超市有 4 个收银台，如果排队的人数为 4，那么每个收银台都有一个顾客在结账，系统运行得比较顺畅。如果排队的人数超过 4，那么一些顾客需要等待，系统开始变得繁忙。如果排队的人数远远超过 4，那么等待时间会变得很长，系统会变得非常繁忙。</p><p>其实在先前的<code> uptime</code>命令获取到的3个时间段的负载中可以分析出不少信息：</p><ul><li>首先，假如三个时间段的数值差距不大，这说明系统负载平稳，没有什么突发的进程。</li><li>假如1分钟的数值远小于15分钟的值，这说明在15分钟内有很高的负载，但在最近一分钟开始降低负载。</li><li>相反，假如1分钟的数值远大于15分钟的值，那说明最近系统负载正在上升。</li></ul><p>这时候我们也会疑惑，当平均负载高于多少时应该做出行动，网上的建议是平均负载超出CPU最大负载的70%的时候应该排查一下问题，因为此时就可能影响服务的正常运行。但更合适的做法是联系起系统的长期负载，进行更深层次的分析后再做出处理。</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpu核数: lscpu、 grep <span class="string">&#x27;model name&#x27;</span> /proc/cpuinfo | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line">显示平均负载：<span class="built_in">uptime</span>、top，显示的顺序是最近1分钟、5分钟、15分钟，从此可以看出平均负载的趋势</span><br><span class="line"></span><br><span class="line">watch -d <span class="built_in">uptime</span>: -d会高亮显示变化的区域</span><br><span class="line"></span><br><span class="line">strees: 压测命令，--cpu cpu压测选项，-i io压测选项，-c 进程数压测选项，--<span class="built_in">timeout</span> 执行时间</span><br><span class="line"></span><br><span class="line">mpstat: 多核cpu性能分析工具，-P ALL监视所有cpu</span><br><span class="line"></span><br><span class="line">pidstat:  进程性能分析工具，-u 显示cpu利用率</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>平均负载指的是：单位时间内，系统中处于可运行状态和不可中断状态的平均进程数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;平均负载（Load-Average）是什么意思&quot;&gt;&lt;a href=&quot;#平均负载（Load-Average）是什么意思&quot; class=&quot;headerlink&quot; title=&quot; 平均负载（Load Average）是什么意思&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能-00</title>
    <link href="http://example.com/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/"/>
    <id>http://example.com/2023/04/11/11-Linux%E6%80%A7%E8%83%BD/11Linux%E6%80%A7%E8%83%BD-00/</id>
    <published>2023-04-11T12:50:54.000Z</published>
    <updated>2023-04-11T14:15:12.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="何为性能指标？"><a href="#何为性能指标？" class="headerlink" title=" 何为性能指标？"></a><span id="more"></span> 何为性能指标？</h1><p>性能是什么？大多数人的第一反应大多是速度快，而这正对应着两个指标<code>吞吐</code>和<code>延时</code>。然而这两个指标是从用户体验来看的，这两个指标可以从应用负载的角度来考察。与之相反的就是从系统资源的角度来看，比如资源使用率等。</p><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/10-Linux%E6%80%A7%E8%83%BD/00%E8%A7%86%E8%A7%92.6l2ogn7t5vr4.png" alt="视角"></p><p>众所周知，随着负载的增加，消耗的系统资源也会随之上升，而性能问题的本质是系统资源耗尽，无法处理足够的请求。</p><p>性能分析，其实就是找出应用或者系统的瓶颈，并设法去避免或者缓解，从而处理更多的请求，一般保研以下步骤：</p><ul><li><p>选择指标评估应用程序和系统的性能；</p></li><li><p>为应用程序和系统设置性能目标；</p></li><li><p>进行性能基准测试；</p></li><li><p>性能分析定位瓶颈；</p></li><li><p>优化系统和应用程序；</p></li><li><p>性能监控和告警。</p></li></ul><h2 id="一些性能工具"><a href="#一些性能工具" class="headerlink" title="一些性能工具"></a>一些性能工具</h2><p><img src="https://cdn.staticaly.com/gh/GoldenSheep402/picx-images-hosting@master/Blog/10-Linux%E6%80%A7%E8%83%BD/perf-tool.3xixrmqdanuo.webp" alt="perf-tool"></p><p>你可以在<a href="https://github.com/brendangregg/perf-tools">这里</a>找到它们</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;何为性能指标？&quot;&gt;&lt;a href=&quot;#何为性能指标？&quot; class=&quot;headerlink&quot; title=&quot; 何为性能指标？&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/categories/Linux/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="性能调优" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop</title>
    <link href="http://example.com/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2023/04/08/10-docker%20desktop%E8%AE%B0%E5%BD%95/</id>
    <published>2023-04-08T12:50:54.000Z</published>
    <updated>2023-04-13T16:28:58.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Desktop使用记录"><a href="#Docker-Desktop使用记录" class="headerlink" title=" Docker Desktop使用记录"></a><span id="more"></span> Docker Desktop使用记录</h1><h2 id="安装-Win"><a href="#安装-Win" class="headerlink" title="安装(Win)"></a>安装(Win)</h2><p>我用的是Windows下的Docker Desktop，众所周知，docker 只有 linux 的发行版本，作为 windows 用户想要使用 docker 的功能自然仅能通过加装虚拟机这一条途径。同样，号称支持 windows 系统的 docker desktop 也是基于同样原理 —— 默认使用 windows 自带的 Hyper-V 服务允许 docker。</p><p>所以想安装 docker desktop 就要确保您的 windows 系统支持 wsl(适用于 Linux 的 Windows 子系统) 功能。我们可以直接在 cmd 或 powershell 中输入<code>wsl </code>来检查是否开启了wsl服务。</p><ul><li><p>打开 控制面板-&gt;程序-&gt;启用或关闭Windows功能，假如有 <code>Hyper-V</code> 和 适用于 <code>Linux 的 Windows 子系统</code>这两个选项，那就愉快得开启，假如没有那你就得去安装一下了</p></li><li><p>Hyper-V </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pushd &quot;%~dp0&quot;</span><br><span class="line"></span><br><span class="line">dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"></span><br><span class="line">for /f %%i in (&#x27;findstr /i . hyper-v.txt 2^&gt;nul&#x27;) do dism /online /norestart /add-package:&quot;%SystemRoot%\servicing\Packages\%%i&quot;</span><br><span class="line"></span><br><span class="line">del hyper-v.txt</span><br><span class="line"></span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL</span><br></pre></td></tr></table></figure></li><li><p>wsl</p></li></ul><p>在管理员模式下打开 PowerShell 或 Windows 命令提示符，输入 <code>wsl --install</code> 命令，然后重启电脑。</p><p>安装 <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop</a></p><blockquote><p>如果每次启动都闪退，可能是你开启了<code>SMB 1.0/CIFS 文件共享支持</code>,去windows功能里给它关了就行了</p></blockquote><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><h3 id="镜像站设置"><a href="#镜像站设置" class="headerlink" title="镜像站设置"></a>镜像站设置</h3><p>众所周知在天朝有些地方没法正常访问，所以为了加快拉取镜像的速度，需要设置一些镜像站。</p><p>来到这个页面更改里面的配置</p><p>以下是我的设置，当然你可以自己去找选择自己喜欢的。</p><p><img src="/%5Cimg%5C2023-4%5CDocker%5C01.png" alt="mirror"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://ccr.ccs.tencentyun.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><ol><li><p>在docker hub寻找需要下载的镜像（在cmd中执行docker search [镜像名]命令也可）</p></li><li><p>现在也可以直接在上面搜出来<br><img src="/%5Cimg%5C2023-4%5CDocker%5C02.png" alt="mirror"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-Desktop使用记录&quot;&gt;&lt;a href=&quot;#Docker-Desktop使用记录&quot; class=&quot;headerlink&quot; title=&quot; Docker Desktop使用记录&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Container" scheme="http://example.com/categories/Container/"/>
    
    <category term="Docker" scheme="http://example.com/categories/Container/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Container" scheme="http://example.com/tags/Container/"/>
    
  </entry>
  
  <entry>
    <title>写个TERTRIS</title>
    <link href="http://example.com/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/"/>
    <id>http://example.com/2023/03/16/09-%E7%94%A8go%E5%86%99%E4%BA%86%E4%B8%AATETRIS/</id>
    <published>2023-03-16T12:50:54.000Z</published>
    <updated>2023-04-13T16:28:39.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用go写了个TETRIS"><a href="#用go写了个TETRIS" class="headerlink" title=" 用go写了个TETRIS"></a><span id="more"></span> 用go写了个TETRIS</h1><p>突发奇想<del>闲来无事情</del>想用go写一个Tertris（俄罗斯方块）玩</p><p>上网小小检索了一下，确实有很多可以实现游戏ui的2D引擎，但比较懒，不是很像搞明白怎么去用，所以选择了直接在终端打印出来。</p><p>既然想做，那就想想应该如何设计</p><blockquote><p>先看看正版到底长啥样</p></blockquote><p><img src="/img/2023-3/Tetris/Typical_Tetris_Game.svg.png" alt="Typical_Tetris_Game.svg"></p><p>分析一下：</p><ol><li>有个方方的游戏区域（显而易见）</li><li>方块会自然下落（这个嘛，没想好怎么处理就设计成直接放置的那种）</li><li>一行满了消去一行，然后下落</li></ol><h2 id="开始写吧"><a href="#开始写吧" class="headerlink" title="开始写吧"></a>开始写吧</h2><p>先定义一个游戏结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Game <span class="keyword">struct</span> &#123;</span><br><span class="line">Board  [][]<span class="type">int</span> <span class="comment">// 游戏区域</span></span><br><span class="line">Active [][]<span class="type">int</span> <span class="comment">// 还没用上，原来打算用来保存可掉落信息的</span></span><br><span class="line">Score  <span class="type">int</span></span><br><span class="line">Level  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">WIDTH  = <span class="number">15</span>    <span class="comment">// 区域大小啦</span></span><br><span class="line">HEIGHT = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一步当然是初始化了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BoardInit</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化游戏板</span></span><br><span class="line">g.Board = <span class="built_in">make</span>([][]<span class="type">int</span>, define.HEIGHT)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Board &#123;</span><br><span class="line">g.Board[i] = <span class="built_in">make</span>([]<span class="type">int</span>, define.WIDTH)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是打印出游戏区域</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印游戏板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintBoard</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里是在每次出现变动时清除内容</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;cls&quot;</span>)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Run()</span><br><span class="line"><span class="comment">// ... ///</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.Board &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">4</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;------------------------------|\n|&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> g.Board[i] &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[i][j] == <span class="number">0</span> &#123;    <span class="comment">// 有方块的话就打印一个矩形</span></span><br><span class="line">fmt.Print(<span class="string">&quot;  &quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;■ &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;|\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot;|------------------------------|\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以看到像这样的输出</p><p><img src="/img/2023-3/Tetris/%E7%89%88%E9%9D%A2.png" alt="版面"></p><p>然后就应该在上方形成方块了</p><p>因为只有7种基本形状，于是为决定直接定义7个基本形状</p><p>至于为什么定义为4x4,是因为在游戏中这些方块是可以旋转的，为了简单起见，决定统一定义成4x4的结构，在旋转中只需修改它们的位置就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tetrominoes = [][][]<span class="type">int</span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次获取的方块都是随机的于是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandomTetromino</span><span class="params">()</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// 对随机数生成器进行种子随机化</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="comment">// 从Tetrominoes数组中随机选择一个形状</span></span><br><span class="line">shape := define.Tetrominoes[rand.Intn(<span class="built_in">len</span>(define.Tetrominoes))]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制所选形状的矩阵到游戏板里</span></span><br><span class="line">tetromino := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(shape))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> shape &#123;</span><br><span class="line">tetromino[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(shape[i]))</span><br><span class="line"><span class="built_in">copy</span>(tetromino[i], shape[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tetromino</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTetrominoIn</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// 生成新的俄罗斯方块</span></span><br><span class="line">nextTetromino := RandomTetromino()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> nextTetromino &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="keyword">range</span> nextTetromino[i] &#123;</span><br><span class="line"><span class="keyword">if</span> nextTetromino[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">g.Board[i][j] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以打印出类似于这样的界面</p><p><img src="/img/2023-3/Tetris/%E5%A4%B4%E9%83%A8.png" alt="例子"></p><p>至于移动或旋转就很简单了，只需找到生成的方块再作相应处理就好了，这里就不贴出代码了。</p><p>下面处理消去一行的操作</p><p>其实就是每次遍历一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ClearFullRows</span><span class="params">(g *define.Game)</span></span> &#123;</span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y := define.HEIGHT - <span class="number">1</span>; y &gt;= <span class="number">0</span>; y-- &#123;</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; define.WIDTH; x++ &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[y][x] == <span class="number">0</span> &#123;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> flag &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除被消去的行</span></span><br><span class="line"><span class="keyword">for</span> x := <span class="number">0</span>; x &lt; define.WIDTH; x++ &#123;</span><br><span class="line">g.Board[y][x] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有了个问题</p><p>如何下落？</p><ul><li>首先，相互连接的方块是不可以掉到底部的</li><li>消去的不一定是下一行</li><li>所有相连的方块是一个整体</li></ul><p>那这有有点头疼了，首先就是如何找到掉落方块整体，然后如何确定掉落高度</p><h3 id="那就先处理如何找到掉落方块整体区间"><a href="#那就先处理如何找到掉落方块整体区间" class="headerlink" title="那就先处理如何找到掉落方块整体区间"></a><strong>那就先处理如何找到掉落方块整体区间</strong></h3><p>由于只需要确定最小下落值，所以只用确定方块的左右范围就好了，但如何区查找呢？</p><p>因为整体说明这些方块左右上下想连，所以可以使用DFS算法去查找!</p><p>这里格外传入了<code>i</code>和<code>j</code>两个值代表开始检索的左下角，因为只有在清除行上的部分才会发生掉落，所以要传入坐标以确定起始位置</p><p>而传入的<code>left</code>和<code>right</code>就修改为得到的数值而继续使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dfs</span><span class="params">(grid [][]<span class="type">int</span>, i <span class="type">int</span>, j <span class="type">int</span>, visited [][]<span class="type">bool</span>, left *<span class="type">int</span>, right *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 检查当前位置是否已经被访问过，或者是否为0</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(grid) ||</span><br><span class="line">j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) ||</span><br><span class="line">grid[i][j] == <span class="number">0</span> || visited[i][j] &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将当前位置标记为已访问</span></span><br><span class="line">visited[i][j] = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 更新左右边界</span></span><br><span class="line"><span class="keyword">if</span> *left &gt; j &#123;</span><br><span class="line">*left = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *right &lt; j &#123;</span><br><span class="line">*right = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归遍历相邻的位置</span></span><br><span class="line">Dfs(grid, i<span class="number">-1</span>, j, visited, left, right) <span class="comment">// 上</span></span><br><span class="line">Dfs(grid, i+<span class="number">1</span>, j, visited, left, right) <span class="comment">// 下</span></span><br><span class="line">Dfs(grid, i, j<span class="number">-1</span>, visited, left, right) <span class="comment">// 左</span></span><br><span class="line">Dfs(grid, i, j+<span class="number">1</span>, visited, left, right) <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于掉落块的掉落高度"><a href="#关于掉落块的掉落高度" class="headerlink" title="关于掉落块的掉落高度"></a><strong>关于掉落块的掉落高度</strong></h3><p>emmm好像没啥好分析的，直接给出代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从左往右查找，这个方法比较蠢</span></span><br><span class="line"><span class="comment">// startLine 代表的是被消去的那一行</span></span><br><span class="line"><span class="comment">// 详细代码在仓库里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Drop</span><span class="params">(g *define.Game, startLine <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">column := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> column &lt; define.WIDTH &#123;</span><br><span class="line">        <span class="comment">// 左右开始是重合的</span></span><br><span class="line">left, right := column, column</span><br><span class="line"><span class="keyword">for</span> y := startLine; y &gt;= <span class="number">5</span>; y-- &#123;</span><br><span class="line">            <span class="comment">// 找到第一个方块，然后进行搜索</span></span><br><span class="line"><span class="keyword">if</span> g.Board[y][column] == <span class="number">1</span> &#123;</span><br><span class="line">visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(g.Board))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> visited &#123;</span><br><span class="line">visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(g.Board[i]))</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">// 通过Dfs查找范围</span></span><br><span class="line">utils.Dfs(g.Board, y, column, visited, &amp;left, &amp;right)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dropHeight <span class="type">int</span> = <span class="number">999</span></span><br><span class="line">top := startLine</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := startLine; y &gt;= <span class="number">0</span>; y-- &#123;</span><br><span class="line"><span class="keyword">if</span> g.Board[y][i] == <span class="number">1</span> &#123;</span><br><span class="line">top = y</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> y := top + <span class="number">1</span>; y &lt;= define.HEIGHT; y++ &#123;</span><br><span class="line"><span class="keyword">if</span> y == define.HEIGHT || g.Board[y][i] == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> dropHeight &gt; y-top<span class="number">-1</span> &#123;</span><br><span class="line">dropHeight = y - top - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取了掉落高度，将范围内的下移</span></span><br><span class="line"><span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> y := top; y &gt;= <span class="number">5</span>; y-- &#123;</span><br><span class="line">g.Board[y+dropHeight][i] = g.Board[y][i]</span><br><span class="line">g.Board[y][i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">column = right + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行例子，可能<del>一定还有一堆bug，不过能跑就好</del></p><p>这是我的<a href="https://github.com/GoldenSheep402/Tetris">代码仓库</a>，还有许多不足，望日后逐步修正</p><p><img src="/img/2023-3/Tetris/%E6%BC%94%E7%A4%BA.png" alt="演示"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用go写了个TETRIS&quot;&gt;&lt;a href=&quot;#用go写了个TETRIS&quot; class=&quot;headerlink&quot; title=&quot; 用go写了个TETRIS&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="go" scheme="http://example.com/categories/go/"/>
    
    
    <category term="game" scheme="http://example.com/tags/game/"/>
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>About JWT(JSON Web Token)</title>
    <link href="http://example.com/2023/01/27/08-About%20JSON%20Web%20Token/"/>
    <id>http://example.com/2023/01/27/08-About%20JSON%20Web%20Token/</id>
    <published>2023-01-27T12:50:54.000Z</published>
    <updated>2023-02-03T15:46:42.543Z</updated>
    
    <content type="html"><![CDATA[<p>JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。</p><h1 id="这玩意是个啥"><a href="#这玩意是个啥" class="headerlink" title=" 这玩意是个啥"></a><span id="more"></span> 这玩意是个啥</h1><blockquote><p>JSONweb token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></blockquote><h2 id="为什么要有JWT"><a href="#为什么要有JWT" class="headerlink" title="为什么要有JWT"></a>为什么要有JWT</h2><p>这需要提到基于token的身份认证和传统的session认证的区别</p><h3 id="传统的session认证"><a href="#传统的session认证" class="headerlink" title="传统的session认证"></a>传统的session认证</h3><p>访问网站是使用的http协议本身是无状态的，这就意味着如果用户需要进行身份认证，那么在下一次请求就需要再一次提交认证请求，而服务器必须存储用户登录的信息</p><p>这就意味着用户数量过高会使服务器无法承受访问压力</p><p><strong>问题</strong></p><ul><li><strong>Session</strong>: 用户经过我们的应用认证之后，都要在服务端做一次记录，从而分辨用户，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</li><li><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li><li><strong>CSRF</strong>: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</li></ul><h3 id="基于Token的鉴权"><a href="#基于Token的鉴权" class="headerlink" title="基于Token的鉴权"></a>基于Token的鉴权</h3><p>虽然也是无状态的协议，但是不需要服务端去保留用户的认证信息，从而降低了服务器的压力同时提高了拓展能力</p><p><strong>流程</strong></p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><h1 id="关于JWT"><a href="#关于JWT" class="headerlink" title="关于JWT"></a>关于JWT</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>JWT是由三段信息通过<code>.</code>连接组成的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure><h3 id="如何构成"><a href="#如何构成" class="headerlink" title="如何构成"></a>如何构成</h3><p>第一段被称为头部(header)，第二段被称为载荷(payload)，第三段称为(signature)</p><h4 id="header"><a href="#header" class="headerlink" title="header"></a>header</h4><p>这里承载了JWT的元数据，例如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;typ&#x27;<span class="punctuation">:</span> &#x27;JWT&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;alg&#x27;<span class="punctuation">:</span> &#x27;HS256&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>再对此使用Base64URL进行加密成为以下的样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>顾名思义，它承载了有效信息，除一些私有字段外，JWT官方规定了7个字段可供选用</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><blockquote><p>不过JWT默认时没有加密的，所以别把密码什么的私密信息写进去(<del>我干过</del>)</p></blockquote><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>其中的secret是只有服务端才知道，绝对不能泄露，然后使用header中指定的签名算法对其进行加密，以下以SHA256为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><h2 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h2><p>Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>一般是在请求头里加入<code>Authorization</code>，并同时加上<code>Bearer</code>标注(直接写query里也有)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;~~~~&#x27;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Authorization&#x27;: &#x27;Bearer &#x27; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/img/2023-1/Jwt/how_it_works.png" alt="how_it_works"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>由于JSON的通用性，所以JWT可以被很多语言通用</li><li>可以在payload中写入一些业务逻辑需要但非敏感的信息</li><li>利于传输</li><li>不需要在服务端保存信息，易于拓展</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSON Web Token(JWT)是目前使用广泛的跨域认证解决方案，苯人因一知半解而错误使用而对此稍稍有所了解。&lt;/p&gt;
&lt;h1 id=&quot;这玩意是个啥&quot;&gt;&lt;a href=&quot;#这玩意是个啥&quot; class=&quot;headerlink&quot; title=&quot; 这玩意是个啥&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="鉴权" scheme="http://example.com/categories/%E9%89%B4%E6%9D%83/"/>
    
    
    <category term="Web" scheme="http://example.com/tags/Web/"/>
    
    <category term="鉴权" scheme="http://example.com/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-06结构</title>
    <link href="http://example.com/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/12/05/07-RUST/07-RUST06%E7%BB%93%E6%9E%84/</id>
    <published>2022-12-05T12:50:00.000Z</published>
    <updated>2023-01-30T08:53:23.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-结构"><a href="#一-结构" class="headerlink" title=" 一.结构"></a><span id="more"></span> 一.结构</h1><blockquote><h2 id="定义-struct"><a href="#定义-struct" class="headerlink" title="定义 struct"></a>定义 struct</h2></blockquote><ul><li>使用 struct 关键字，并命名</li><li>在{…}内，为所有字段(Field)定义名称和类型</li><li>例如：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="实例化-stuct"><a href="#实例化-stuct" class="headerlink" title="实例化 stuct"></a>实例化 stuct</h2></blockquote><ul><li>要创建实例 (废话<del>但是废话好有道理啊</del>)<ul><li>为字段指定值(要全部指定)</li><li>无需按顺序</li></ul></li><li>例子</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;somename&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@what.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><h2 id="取-struct-中的值"><a href="#取-struct-中的值" class="headerlink" title="取 struct 中的值"></a>取 struct 中的值</h2><p> 使用点运算符：</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;somename&quot;</span>),</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@what.com&quot;</span>),</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;what?what?&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</p></blockquote><blockquote><h2 id="struct-作为函数返回值"><a href="#struct-作为函数返回值" class="headerlink" title="struct 作为函数返回值"></a>struct 作为函数返回值</h2></blockquote><p>此时这个 user 作为此函数的返回值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        username: username,</span><br><span class="line">        email: email,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h2><p>有一种更简单的定义和使用结构体的方式：元组结构体。</p></blockquote><p>元组结构体是一种形式是元组的结构体。</p><p>与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">f64</span>, <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>使用方式和元组一样，可以使用下标来访问：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">f64</span>, <span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;black = (&#123;&#125;, &#123;&#125;, &#123;&#125;)&quot;</span>, black.<span class="number">0</span>, black.<span class="number">1</span>, black.<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;origin = (&#123;&#125;, &#123;&#125;)&quot;</span>, origin.<span class="number">0</span>, origin.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体所有权"><a href="#结构体所有权" class="headerlink" title="结构体所有权"></a>结构体所有权</h1><p>结构体必须掌握字段值所有权，因为在结构体失效时会释放所有字段。</p><h2 id="输出结构体"><a href="#输出结构体" class="headerlink" title="输出结构体"></a>输出结构体</h2><p>可以加入 <code>#[derive(Debug)]</code>来输出整个结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="comment">// 使用&#123;:?&#125;占位符来输出整个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rect1 is Rectangle { width: 30, height: 50 }   使用{:?}</p><p>rect1 is Rectangle {                           使用{:#?}<br>   width: 30,<br>   height: 50<br>}</p></blockquote><h2 id="结构体方法"><a href="#结构体方法" class="headerlink" title="结构体方法"></a>结构体方法</h2><p>方法和函数是类似的，但是是通过结构体来实现。</p><p>Rust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象可以在 Rust 实现。</p><p>结构体方法的第一个参数必须是 &amp;self，不需声明类型，因为 self 不是一种风格而是关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123; width: <span class="number">30</span>, height: <span class="number">50</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1&#x27;s area is &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>rect1’s area is 1500</p></blockquote><h2 id="结构体关联函数"><a href="#结构体关联函数" class="headerlink" title="结构体关联函数"></a>结构体关联函数</h2><p>有些函数不依靠实例，但是使用需要注明是来自哪个impl模块</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">create</span>(width: <span class="type">u32</span>, height: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width, height &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle::<span class="title function_ invoke__">create</span>(<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-结构&quot;&gt;&lt;a href=&quot;#一-结构&quot; class=&quot;headerlink&quot; title=&quot; 一.结构&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-05切片</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST05%E5%88%87%E7%89%87/</id>
    <published>2022-12-04T12:50:54.000Z</published>
    <updated>2023-01-30T08:53:26.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-Rust-Slice"><a href="#一-Rust-Slice" class="headerlink" title="一.Rust Slice"></a><span id="more"></span>一.Rust Slice</h1><p>切片（Slice）是对数据值的部分引用。</p><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;broadcast&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part1</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part2</span> = &amp;s[<span class="number">5</span>..<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;=&#123;&#125;+&#123;&#125;&quot;</span>, s, part1, part2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>broadcast&#x3D;broad+cast</p></blockquote><p><img src="/img/2022-12/07-RUST/slice/rust-slice1.png" alt="slice"></p><p>x..y &#x3D;&#x3D; [x,y)</p><blockquote><p>..y 等价于 0..y<br>x.. 等价于位置 x 到数据结束<br>.. 等价于位置 0 到结束</p></blockquote><h2 id="非字符串切片"><a href="#非字符串切片" class="headerlink" title="非字符串切片"></a>非字符串切片</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">part</span> = &amp;arr[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> part.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1</p><p>2</p><p>3</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-Rust-Slice&quot;&gt;&lt;a href=&quot;#一-Rust-Slice&quot; class=&quot;headerlink&quot; title=&quot;一.Rust Slice&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-04所有权</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST04%E6%89%80%E6%9C%89%E6%9D%83/</id>
    <published>2022-12-04T04:50:03.000Z</published>
    <updated>2023-02-08T07:49:57.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-什么是所有权"><a href="#一-什么是所有权" class="headerlink" title="一.什么是所有权"></a><span id="more"></span>一.什么是所有权</h1><ul><li>Rust的核心特性是所有权</li><li>所有程序在运行是必须管理它们使用内存的方式<ul><li>有些语言有垃圾收集机制，在运行是，会自动去寻找不再使用的内存</li><li>其他语言中，必须手动地分配和释放内存</li></ul></li><li>Rust使用了第三种方式<ul><li>内存通过一个所有权系统来管理，其中包含一组编译器在编译时检查的规则</li><li>所以当程序运行是，所有权特性不会拖慢程序的运行速度</li></ul></li></ul><h2 id="Stack-amp-Heap"><a href="#Stack-amp-Heap" class="headerlink" title="Stack &amp; Heap"></a>Stack &amp; Heap</h2><ul><li>在Rust这样的系统级编程语言中，一个值是在stack还是再heap上对程序的行为和如何做决定有很大的影响</li></ul><blockquote><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3></blockquote><ul><li>stack 按值的接受顺序来存储,按相反的顺序移除(LIFO)<ul><li>push</li><li>pop</li></ul></li><li>所有存在stack上的数据必须有已知且固定的大小<ul><li>编译时未知大小的数据或是运行时大小可能发生改变的数据必须存储在heap上</li></ul></li></ul><blockquote><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3></blockquote><ul><li>将数据存入 heap 时，会请求一定空间</li><li>系统在 heap 中找到一块足够大的空间时，将它标记为在用，并返回一个指针</li></ul><h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><ul><li>将值压入 stack 不叫分配</li><li>因为指针是已知固定大小，可以把指针放在 stack 上<ul><li>想要实际数据可以使用指针来定位</li></ul></li><li>将数据压入 stack 比从 heap 中分配要快得多：<ul><li>因为系统无需寻找空间，只需要压入顶部</li></ul></li></ul><h3 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h3><ul><li>访问 heap 要比访问 stack 慢得多，因为要通过指针才能找到 heap 中的数据<ul><li>对于现代计算机，由于缓存的存在，指令在内存中跳转得越少，那么速度越快</li></ul></li></ul><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><ul><li>调用函数时，值被传入到函数(包括指向 heap 的指针)。函数的变量压入 stack 中。函数结束后，这些值会被弹出</li></ul><h2 id="所有权存在的原因"><a href="#所有权存在的原因" class="headerlink" title="所有权存在的原因"></a>所有权存在的原因</h2><blockquote><p>所有权解决了什么？</p></blockquote><ul><li>跟踪代码那些部分在使用 heap 的那些数据</li><li>最小化 heap 中的重复数据</li><li>清理 heap 上未使用的数据</li></ul><h2 id="所有权的规则"><a href="#所有权的规则" class="headerlink" title="所有权的规则"></a>所有权的规则</h2><ul><li>每个值都有一个变量，这个变量是该值的所有者</li><li>每个值同时只能有一个所有者</li><li>所有者超出作用域后，这个值会被删除</li></ul><h1 id="二-内存与分配"><a href="#二-内存与分配" class="headerlink" title="二.内存与分配"></a>二.内存与分配</h1><ul><li>Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用域的时候，内存自动还给操作系统</li><li>drop 函数</li></ul><h2 id="变量和数据交互的方式：Move"><a href="#变量和数据交互的方式：Move" class="headerlink" title="变量和数据交互的方式：Move"></a>变量和数据交互的方式：Move</h2><ul><li>多个变量可以与同一个数据使用一种独特的方式来交互<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure></li><li>整数是已知大小且固定大小的值，这两个5都被压入 stack 中</li></ul><h2 id="变量和数据交互的方式：Move-String"><a href="#变量和数据交互的方式：Move-String" class="headerlink" title="变量和数据交互的方式：Move(String)"></a>变量和数据交互的方式：Move(String)</h2><ul><li>一个 string 由三部分组成：<ul><li>指针 长度 容量</li></ul></li></ul><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/string%E7%BB%84%E6%88%90.png" alt="string"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><ul><li>将 s1 赋给 s2 时，将数据复制了一份：<ul><li>在 stack 上复制了一份（指针 长度 容量）</li><li>但是没有复制 heap 上的数据</li></ul></li><li>离开作用域后，会调用drop函数，将heap中的内存释放</li><li>当 s1、s2 都离开时，它们会尝试去释放相同的内存：<ul><li>二次释放(double free)</li></ul></li><li>为了保证内存安全：<ul><li>Rust 没有选择复制被分配的内存</li><li>Rust 使 s1 失效<ul><li>所以 s1 离开作用域的时候无需释放任何内存</li></ul></li></ul></li></ul><p>如果尝试使用 s1 会有以下错误<br><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/build-error.png" alt="error"></p><ul><li>浅拷贝(shallow copy)</li><li>深拷贝(deep copy)</li><li>由于 Rust 让 s1 失效，所以使用新的术语：移动(Move)</li><li>隐含的一个原则：Rust 不会自动创建数据的深拷贝<ul><li>就运行性能而言，任何自动赋值的操作都是廉价的</li></ul></li></ul><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/move.png" alt="move"></p><h2 id="克隆-clone"><a href="#克隆-clone" class="headerlink" title="克隆(clone)"></a>克隆(clone)</h2><p>如果想要 s1，s2 均有效，可以使用 clone方法(深度拷贝)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/05%E5%86%85%E5%AD%98%E4%B8%8E%E5%88%86%E9%85%8D/clone.png" alt="move"></p><h2 id="stack上：复制"><a href="#stack上：复制" class="headerlink" title="stack上：复制"></a>stack上：复制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);</span><br></pre></td></tr></table></figure><ul><li>Copy trait 可以用于想整数这样完全存放在 stack 上的类型</li><li>如果一个类型实现了 copy 这个 tarit ，那么旧的变量在赋值后仍然可用</li><li>如果一个类型或者该类型的一部分实现了 drop trait ，那么Rust不允许它再去实现 copy tarit</li></ul><h3 id="拥有-copy-trait的类型"><a href="#拥有-copy-trait的类型" class="headerlink" title="拥有 copy trait的类型"></a>拥有 copy trait的类型</h3><ul><li>任何简单标量的组合类型都可copy</li><li>需要分配资源的不可copy</li><li>有 copy tarit 的类型<ul><li>所有整数</li><li>bool</li><li>char</li><li>float</li><li>Tuple(如果所有字段可copy)</li></ul></li></ul><h1 id="三-涉及函数的所有权机制"><a href="#三-涉及函数的所有权机制" class="headerlink" title="三.涉及函数的所有权机制"></a>三.涉及函数的所有权机制</h1><ul><li>对于变量而言函数的所有权问题显得非常奇怪</li></ul><h2 id="函数参数的所有权机制"><a href="#函数参数的所有权机制" class="headerlink" title="函数参数的所有权机制"></a>函数参数的所有权机制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);</span><br><span class="line">    <span class="comment">// s 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);</span><br><span class="line">    <span class="comment">// x 的值被当作参数传入函数</span></span><br><span class="line">    <span class="comment">// 但 x 是基本类型，依然有效</span></span><br><span class="line">    <span class="comment">// 在这里依然可以使用 x 却不能使用 s</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="comment">// 一个 String 参数 some_string 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 函数结束, 参数 some_string 在这里释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="comment">// 一个 i32 参数 some_integer 传入，有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span></span><br></pre></td></tr></table></figure><p>如果将变量作为参数传入函数，那么它和移动的效果是一样的</p><h2 id="函数返回值的所有权机制"><a href="#函数返回值的所有权机制" class="headerlink" title="函数返回值的所有权机制"></a>函数返回值的所有权机制</h2><blockquote><p>被当作函数返回值的变量所有权将会被移动出函数并返回到调用函数的地方，而不会直接被无效释放。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line">    <span class="comment">// gives_ownership 移动它的返回值到 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s2 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">    <span class="comment">// s2 被当作参数移动, s3 获得返回值所有权</span></span><br><span class="line">&#125; <span class="comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// some_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> some_string;</span><br><span class="line">    <span class="comment">// some_string 被当作返回值移动出函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; </span><br><span class="line">    <span class="comment">// a_string 被声明有效</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// a_string 被当作返回值移出函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-引用与租借"><a href="#四-引用与租借" class="headerlink" title="四.引用与租借"></a>四.引用与租借</h1><h2 id="引用与租借简单解释"><a href="#引用与租借简单解释" class="headerlink" title="引用与租借简单解释"></a>引用与租借简单解释</h2><blockquote><p>引用（Reference）是 C++ 开发者较为熟悉的概念。<br>如果你熟悉指针的概念，你可以把它看作一种指针。<br>实质上”引用”是变量的间接访问方式。</p></blockquote><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 is &#123;&#125;, s2 is &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><blockquote><p>s1 is hello, s2 is hello</p></blockquote><p><strong>&amp;</strong> 运算符可以取变量的”引用”。</p><p>当一个变量的值被引用时，变量本身不会被认定无效。因为”引用”并没有在栈中复制变量的值：</p><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/reference.png" alt="reference"></p><p>函数参数传递的道理相同:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The length of   ‘hello’  is 5.</p></blockquote><ul><li>参数类型是 &amp;String 而不是 String</li><li>&amp; 符号表示引用：允许你引用某些值而不取得所有权</li><li>引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;<span class="comment">// 此时hello已经属于s3，不再属于s1，此时s2无法使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借：</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s2</span> = &amp;s1;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1;</span><br><span class="line">    s2 = &amp;s3; <span class="comment">// 重新从 s3 租借所有权</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段程序是正确的。既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。如果尝试利用租借来的权利来修改数据会被阻止：</p></blockquote><ul><li>把引用作为参数的行为成为借用</li><li>无法修改借用的东西</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// 错误，禁止修改租借的值</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/change-borrow.png" alt="错误信息"></p><p>和变量一样，引用默认也是不可变的</p><p>这段程序中 s2 尝试修改 s1 的值被阻止，租借的所有权不能修改所有者的值。</p><p>当然，也存在一种可变的租借方式，就像你租一个房子，如果物业规定房主可以修改房子结构，房主在租借时也在合同中声明赋予你这种权利，你是可以重新装修房子的：</p><blockquote><p>可变引用示例</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="comment">// s1可变</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;<span class="keyword">mut</span> s1);</span><br><span class="line">    <span class="comment">// 传入函数的是可变的引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  OUTPUT -<span class="punctuation">-&gt;</span> The length of <span class="symbol">&#x27;hello</span>, world!&#x27; is <span class="number">13</span>.</span><br></pre></td></tr></table></figure><p>这段程序就没有问题了。我们用 &amp;mut 修饰可变的引用类型。</p><p>可变引用与不可变引用相比除了权限不同以外，可变引用不允许多重引用，但不可变引用可以：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure><p>这段程序不正确，因为多重可变引用了 s。</p><blockquote><p>Rust 对可变引用的这种设计主要出于对并发状态下发生数据访问碰撞的考虑，在编译阶段就避免了这种事情的发生。</p><p>由于发生<strong>数据竞争</strong>的必要条件之一是数据被至少一个使用者写且同时被至少一个其他使用者读或写，所以在一个值被可变引用时不允许再次被任何引用。</p><p>以下三种行为会发生数据竞争：</p><ol><li><strong>两个或多个</strong>指针同时访问同一个数据</li><li>至少有一个指针用于写入数据</li><li>没有任何机制来同步数据的访问</li></ol></blockquote><ul><li><p>所以可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用；</p><ul><li>可以在编译时防止数据竞争</li></ul></li><li><p>可以通过创建新的作用域来创建多个可变引用</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    &#125; <span class="comment">// r1 goes out of scope here, so we can make a new reference with no problems </span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另一个限制</p></blockquote><ul><li>不可以同时拥有一个可变引用和一个不可变引用（因为有了一个不可变引用同时有一个可变说明不可变可变）</li><li>但是多个不可变引用是可以的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// no problem</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// BIG PROBLEM</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/%E5%A4%9A%E4%B8%AA%E5%BC%95%E7%94%A8.png" alt="多个引用"></p><h2 id="悬空引用-Dangling-Reference"><a href="#悬空引用-Dangling-Reference" class="headerlink" title="悬空引用(Dangling Reference)"></a>悬空引用(Dangling Reference)</h2><blockquote><p>悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块地址可能已经被释放并分配给其他人使用</p></blockquote><ul><li>在 Rust 里，编译器会保证引用永远不会悬空：<ul><li>如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle returns a reference to a String</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s is a new String</span></span><br><span class="line">    &amp;s <span class="comment">// we return a reference to the String, s</span></span><br><span class="line">&#125; <span class="comment">// Here, s goes out of scope, and is dropped. Its memory goes away. Danger!</span></span><br></pre></td></tr></table></figure><p><img src="/img/2022-12/07-RUST/06%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/dangle.png" alt="dangle"></p><blockquote><h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><ul><li>在任何给定的时刻，只能满足下列条件之一：<br>.  - 一个可变的引用</li><li>任意数量不可变的引用</li><li>引用必须一直有效</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一-什么是所有权&quot;&gt;&lt;a href=&quot;#一-什么是所有权&quot; class=&quot;headerlink&quot; title=&quot;一.什么是所有权&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-03函数</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST03%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B3%A8%E9%87%8A/</id>
    <published>2022-12-04T04:50:02.000Z</published>
    <updated>2023-01-30T08:54:46.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust-函数"><a href="#Rust-函数" class="headerlink" title="Rust 函数"></a><span id="more"></span>Rust 函数</h1><h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><blockquote><p>fn &lt;函数名&gt; ( &lt;参数&gt; ) &lt;函数体&gt;</p></blockquote><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>x 的值为 : 5<br>y 的值为 : 6</p></blockquote><h2 id="函数体的语句与表达式"><a href="#函数体的语句与表达式" class="headerlink" title="函数体的语句与表达式"></a>函数体的语句与表达式</h2><p>Rust 的函数体由以表达式(expression)结尾的语句(statement)组成</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span>     <span class="comment">// 这是一个表达式，它的值是整个函数的的结果值</span></span><br><span class="line">                  <span class="comment">// 被叫做函数体表达式(后面不能有;有的话就是一条statement)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x 的值为 : &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y 的值为 : &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>x 的值为 : 5<br>y 的值为 : 4</p></blockquote><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>在-&gt;符号后面声明函数的返回值类型，但不可为返回值命名</li><li>在Rust中，返回值是函数体中最后一个表达式的值</li><li>若需要提前返回，使用return关键字，并指定一个值<ul><li>大部分函数都是默认使用最后一个表达式作为返回的值</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">5</span> <span class="comment">//返回值就是5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rust-函数&quot;&gt;&lt;a href=&quot;#Rust-函数&quot; class=&quot;headerlink&quot; title=&quot;Rust 函数&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-02数据类型</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-12-04T04:50:01.000Z</published>
    <updated>2023-01-30T08:54:44.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><span id="more"></span>数据类型</h1><ul><li>标量和复合类型</li><li>Rust是静态编译语言，在编译的同时必须知道所有变量的类型<ul><li>基于使用的值，编译器通常能够推断出它的具体类型</li><li>但如果可能的类型太多（例如将string转换为整数的parse方法），就必须添加类型的标注</li></ul></li></ul><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><ul><li>一个标量代表一个单一的值</li><li>Rust有四个主要的标量类型：<ul><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ul></li></ul><blockquote><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3></blockquote><ul><li>就是个整数</li><li>例如u32是一个无符号整数类型，占据32位空间</li><li>无符号用u开头</li></ul><p><img src="/img/2022-12/07-RUST/02%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/type-pic.png" alt="type-pic"></p><blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3></blockquote><ul><li>Rust有两种基础的浮点类型<ul><li>f32</li><li>f64</li></ul></li><li>Rust的浮点类型使用了IEEE-754标注来表述</li><li>f64是默认类型，因为在现代CPU上f64和f32速度差不多，且精度更高</li></ul><blockquote><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3></blockquote><ul><li>true 和 false 两个值</li><li>一个字节</li><li>符号是bool</li></ul><blockquote><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3></blockquote><ul><li>Rust中的char类型用来表示最基础的单个字符</li><li>字符类型的字面值使用单引号</li><li>占用4个字节</li><li>使用Unicode编码</li></ul><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><blockquote><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3></blockquote><ul><li>可以使用模式匹配来解构一个Tuple来获取值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问Tuple的元素</p><ul><li>在Tuple变量使用点标记，后接元素索引</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3></blockquote><ul><li>声明方法：在一个中括号中，各值用逗号分隔</li></ul><h4 id="数组的用处"><a href="#数组的用处" class="headerlink" title="数组的用处"></a>数组的用处</h4><ul><li>如果想让数据存放在stack中而不是heap上，或者想保证有固定数量的元素，这时使用数组更有好处</li><li>数组没有Vector灵活<ul><li>Vector和数组类似，它由标准库提供</li><li>Vector的长度可以改变</li></ul></li></ul><h4 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h4><ul><li><h2 id="数组的类型可以以这种形式表示：-类型-长度-let-a-i32-5-x3D-1-2-3-4-5"><a href="#数组的类型可以以这种形式表示：-类型-长度-let-a-i32-5-x3D-1-2-3-4-5" class="headerlink" title="数组的类型可以以这种形式表示：[类型; 长度]- let a[i32;5] &#x3D; [1,2,3,4,5];"></a>数组的类型可以以这种形式表示：[类型; 长度]<br>- let a[i32;5] &#x3D; [1,2,3,4,5];</h2></li></ul><h4 id="另一种声明数组的方法"><a href="#另一种声明数组的方法" class="headerlink" title="另一种声明数组的方法"></a>另一种声明数组的方法</h4><ul><li>如果数组的每个元素值都相同，那么可以在：<ul><li>在中括号中指定初始值</li><li>然后是一个 ;</li><li>最后是数组长度</li></ul></li><li>let a[3;5]; 等价于 let a &#x3D; [3,3,3,3,3];</li><li></li></ul><h4 id="访问数组的元素"><a href="#访问数组的元素" class="headerlink" title="访问数组的元素"></a>访问数组的元素</h4><ul><li>数组是Stack上分配的单个块的内存</li><li>可以使用索引</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">months</span> = [</span><br><span class="line">        <span class="string">&quot;Jan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Feb&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Mar&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Apr&quot;</span>,</span><br><span class="line">        <span class="string">&quot;May&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Jun&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Jul&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Aug&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Sep&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Oct&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Nov&quot;</span>, </span><br><span class="line">        <span class="string">&quot;Dec&quot;</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = months[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = months[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果访问的索引超出了数组的范围，那么：</p><ul><li>编译会通过</li><li>运行保存（runtime时panic）</li><li>Rust不会允许其访问相应地址的内存</li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust-note-01变量与可变性</title>
    <link href="http://example.com/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/"/>
    <id>http://example.com/2022/12/04/07-RUST/07-RUST01%E5%8F%98%E9%87%8F%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7/</id>
    <published>2022-12-04T04:50:00.000Z</published>
    <updated>2023-02-03T12:50:08.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title=" 变量与可变性"></a><span id="more"></span> 变量与可变性</h1><ul><li>声明变量用let关键字</li><li>默认下是不可变（Immutable）</li><li>可以加入mut，使变量可变</li></ul><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul><li>常量（constant）,常量在绑定值后也是不可变，但是有许多不同：<ul><li>不可使用mut，常量永远不可变</li><li>声明常量使用const关键字，且类型必须被标注</li><li>常量可以在任何作用域中被声明</li></ul></li></ul><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><ul><li>可以使用相同的名字声明新的变量，新的变量会被shadow之前声明的同名变量</li><li>在后续代码中，这个名字代表的就是新的变量</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;变量与可变性&quot;&gt;&lt;a href=&quot;#变量与可变性&quot; class=&quot;headerlink&quot; title=&quot; 变量与可变性&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Rust" scheme="http://example.com/categories/Rust/"/>
    
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>再观《放牛班的春天》</title>
    <link href="http://example.com/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/"/>
    <id>http://example.com/2022/12/02/01%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/</id>
    <published>2022-12-02T14:58:54.000Z</published>
    <updated>2023-04-13T16:28:02.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小小的观后感"><a href="#小小的观后感" class="headerlink" title="小小的观后感"></a><span id="more"></span>小小的观后感</h2><p><img src="/img/2022-12/%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/1.jpg" alt="1"><br>有人说，这部电影让人明白了何为师德，何为园丁。</p><p>在这所叫做“池塘之底”的辅育院中，以为矮胖的老师和一群顽劣不堪的孩子们却碰撞出了动人的歌声。</p><p><strong>在这歌声中隐藏这的是孩子们对世界的渴望。</strong></p><p>这部电影，没有高饱和度，也没有宏大的场面，但它却像一部美丽的童话，满是对希望的赞颂。</p><p>它多面而又真实，没有一个孩子出生就是邪恶的，打骂和体罚只会令他们的肉体屈服。但在我看来，这些孩子们的调皮行为更像是为了引起他人的注意，而不是怀揣着恶意去伤害他人。</p><p>王尔德说，生活在阴沟里，依然有仰望星空的权利。是的，无论你是成年人还是孩童，无论现在是家财万贯还是一贫如洗，即使跌入“池塘之底”，也依然可以找寻自己内心的光明。不得不说，影片主题深刻，一帧帧画面和一句句台词都闪耀着人性的光芒。</p><p><strong>希望我也能变得更加温暖，让自己让身边的人变得更好，让生活让世界变得更美。</strong></p><p><strong>纸飞机飞出窗口，蓝天下挥舞的小手，童年像一串串鸽子，拍打翅膀，一飞就永不回头</strong></p><p><img src="/img/2022-12/%E6%94%BE%E7%89%9B%E7%8F%AD%E7%9A%84%E6%98%A5%E5%A4%A9/3.jpg" alt="3"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;小小的观后感&quot;&gt;&lt;a href=&quot;#小小的观后感&quot; class=&quot;headerlink&quot; title=&quot;小小的观后感&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="电影" scheme="http://example.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://example.com/tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>杂谈02</title>
    <link href="http://example.com/2022/11/27/06%E6%9D%82%E8%B0%88_02/"/>
    <id>http://example.com/2022/11/27/06%E6%9D%82%E8%B0%88_02/</id>
    <published>2022-11-27T15:57:54.000Z</published>
    <updated>2023-02-03T15:41:41.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一千零一面镜子"><a href="#一千零一面镜子" class="headerlink" title="一千零一面镜子"></a><span id="more"></span>一千零一面镜子</h1><p>我越是逃离<br>却越是靠近你<br>我越是背过脸<br>却越是看见你</p><p>我是一座孤岛<br>处在相思之水中<br>四面八方<br>隔绝我通向你</p><p>一千零一面镜子<br>转映着你的容颜<br>我从你开始<br>我在你结束</p><h1 id="林清玄：不要忘记飞翔的姿势"><a href="#林清玄：不要忘记飞翔的姿势" class="headerlink" title="林清玄：不要忘记飞翔的姿势"></a>林清玄：不要忘记飞翔的姿势</h1><p>在穿过林间的时候，<br>我觉得麻雀的死亡给我一些启示，<br>我们虽然在尘网中生活，<br>但永远不要失去想飞的心，不要忘记飞翔的姿势。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一千零一面镜子&quot;&gt;&lt;a href=&quot;#一千零一面镜子&quot; class=&quot;headerlink&quot; title=&quot;一千零一面镜子&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Life" scheme="http://example.com/categories/Life/"/>
    
    
    <category term="随记" scheme="http://example.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL概述</title>
    <link href="http://example.com/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/11/26/02-SQL/02SQL%E6%A6%82%E8%BF%B0/</id>
    <published>2022-11-26T04:50:54.000Z</published>
    <updated>2023-02-03T15:42:30.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1.SQL概述"></a><span id="more"></span>1.SQL概述</h2><h3 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1.1 SQL背景知识"></a>1.1 SQL背景知识</h3><ul><li>在1974年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，SQL 的半衰期可以说是非常长了。</li><li>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，与数据直接打交道 ，由IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有 SQL-86 ，SQL-89 ，SQL-92 ，SQL-99 等标准。</li><li>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</li></ul><p><img src="/img/2022-12/SQL%E6%A6%82%E8%BF%B0/1.png" alt="1"></p><h3 id="1-2-SQL分类"><a href="#1-2-SQL分类" class="headerlink" title="1.2 SQL分类"></a>1.2 SQL分类</h3><ul><li>DDL（Data Definition Languages 数据定义语言），这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</li><li>DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记录，并检查数据完整性。</li><li>DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和安全级别。</li></ul><h2 id="2-1-SQL语法的规则与规范"><a href="#2-1-SQL语法的规则与规范" class="headerlink" title="2.1 SQL语法的规则与规范"></a>2.1 SQL语法的规则与规范</h2><ul><li>SQL 可以写为一行或者是多行。为了提高可读性，可将字句分行。</li><li>每条命令以；or  \g  or  \G 结束。(部分数据库要求)</li></ul><h3 id="2-2-SQL大小写规范"><a href="#2-2-SQL大小写规范" class="headerlink" title="2.2 SQL大小写规范"></a>2.2 SQL大小写规范</h3><ul><li><p>MySQL 在 Windows下对大写不敏感。</p></li><li><p>MySQL 在Linux下对大小写敏感。</p><ul><li>数据库名、表名、表的别名、变量名严格区分大小写。</li><li>关键字、函数名、字段名、字段别名是忽略大小写的。</li></ul></li><li><p>推荐的书写规范：</p><ul><li>数据库名、表名、表别名、字段名、字段别名使用小写。</li><li>SQL关键字、函数名、绑定变量使用大写。</li></ul></li></ul><h3 id="2-3-命名规则"><a href="#2-3-命名规则" class="headerlink" title="2.3 命名规则"></a>2.3 命名规则</h3><ul><li>数据库、表名不得超过30个字符，变量名限制为29个。</li><li>只能包含 A–Z, a–z, 0–9, _共63个字符。</li><li>数据库名、表名、字段名等对象名中间不要包含空格。</li><li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名。</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用&#96;（着重号）引起来。</li><li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了。</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#以下两句是一样的，不区分大小写</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line">#创建表格</span><br><span class="line">#<span class="keyword">create</span> <span class="keyword">table</span> student info(...); #表名错误，因为表名有空格</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_info(...);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-SQL概述&quot;&gt;&lt;a href=&quot;#1-SQL概述&quot; class=&quot;headerlink&quot; title=&quot;1.SQL概述&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="SQL" scheme="http://example.com/categories/SQL/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>杂谈01</title>
    <link href="http://example.com/2022/11/23/05%E6%9D%82%E8%B0%88_01/"/>
    <id>http://example.com/2022/11/23/05%E6%9D%82%E8%B0%88_01/</id>
    <published>2022-11-23T08:50:17.000Z</published>
    <updated>2023-02-03T15:40:48.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来点闲话"><a href="#来点闲话" class="headerlink" title="来点闲话"></a><span id="more"></span>来点闲话</h2><p>2022/11/23 记</p><p>到大学已经3个多月了，emmm其实和我想象中区别不大，没有那么不堪也没有所谓的如此美好，总结一下算是满意吧。</p><p>到现在已经结束了期中考，不是很理想也不是很糟糕(主要没像高中一样这么认真，现在真就是全依我性子学了)，还算是过了3个月算是充实的大学生活吧。</p><p>原以为我到大学会和以前一样不爱搭理人，不过在期间还是遇见了不少有趣的人们，而且被学长学姐视为“老油条”（笑死，喜欢钻学校空子罢了，不过确实一直挑战防疫底线，kkk)，还是想多认识认识志同道合有趣的灵魂们，大学不能把我自己烂在寝室里嘞。</p><p>我认为高中期间我是个容易陷入低沉的家伙，其实就是内耗吧，三年下来没少折磨过自己，多亏了高中同学们的包容，让我多次在焦虑与折磨中感受到他人的善意。高考结束后觉得以前许多事实在是没有意义，但是成长过程中或许这些法难以避免吧，到了现在算是有所改观。我之所以有现在的这样的态度离不开他人对我我关心与善意，在这里对我过去无意伤害过的亲友道个歉，暑假后我发现我从来不是一个人，不论在家还是学校都有人愿意向我伸出援手，所以希望发现身边的善意，并以善意对待他人，前一阵子看到一句话说:脾气好的原因:因为根本不care大部分和事。 可能说的也对吧，虽然有人说人是自私的，也没错，有可能这些乐于帮助他人的人最后没多少收获，但为了得到什么而去帮助他人是否有些太功利了？虽然人确实是复杂，但我相信从好的角度去看待他人与事情能改变自己的心境，高考前我对大多数人都抱有一丝怨气，当时看什么都难受，但是到大学呆了3个月，给足了自己空间，发觉把人想得更好自己才会更舒服。虽然说社会上也充斥着恶意，但我觉得以温和的方式去处置，没必要太有棱角，这样大家都能有自己的空间。有人说我过的太简单，以后会吃亏，但至少目前我觉得无所谓了，简单是我的方式吧。(不善言辞，兴起一写)</p><p>至于生活方面，因为高中养成的习惯，想在生活中掺入一些艺术气息，毕竟生活不能太无趣对吧(<del>不喜勿喷，只是我自己喜欢而已</del>)。</p><p>以上是浅薄之见，个人想法而已~</p><h3 id="说点倒霉的"><a href="#说点倒霉的" class="headerlink" title="说点倒霉的"></a>说点倒霉的</h3><ul><li>多次睡觉发现晒被子没收(记性极差)</li><li>长达半个月丢了伞，而且懒得买，一直淋雨，前两天刚下决心重买(好心疼生活费) PS:今天又忘餐厅了。。。</li></ul><h3 id="谈谈期待"><a href="#谈谈期待" class="headerlink" title="谈谈期待"></a>谈谈期待</h3><ul><li>一直耽搁的阅读计划总算有点起色，不多看看书可不行嘞~</li><li>再匀点时间到<del>有趣的</del>学业上</li><li>再瞎学点杂七杂八的技术实现需求(但是找不到需求)~</li><li>想学乐器(天赋没有，也没学费，哇要哭了)~~</li></ul><h3 id="已经实现的"><a href="#已经实现的" class="headerlink" title="已经实现的"></a>已经实现的</h3><ul><li><p>买了马克西姆12月21号的音乐会的场次，还是比较期待的，毕竟可以见到本人诶！</p></li><li><p>混进了杭助~~</p></li><li><p>没有错过11月8号的月食，好开心嘞！</p><p>晚点再加！出门了~</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;来点闲话&quot;&gt;&lt;a href=&quot;#来点闲话&quot; class=&quot;headerlink&quot; title=&quot;来点闲话&quot;&gt;&lt;/a&gt;</summary>
    
    
    
    <category term="Life" scheme="http://example.com/categories/Life/"/>
    
    
    <category term="随记" scheme="http://example.com/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
